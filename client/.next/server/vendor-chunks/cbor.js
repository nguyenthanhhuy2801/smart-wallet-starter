"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cbor";
exports.ids = ["vendor-chunks/cbor"];
exports.modules = {

/***/ "(ssr)/./node_modules/cbor/lib/cbor.js":
/*!***************************************!*\
  !*** ./node_modules/cbor/lib/cbor.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Commented = __webpack_require__(/*! ./commented */ \"(ssr)/./node_modules/cbor/lib/commented.js\")\nconst Diagnose = __webpack_require__(/*! ./diagnose */ \"(ssr)/./node_modules/cbor/lib/diagnose.js\")\nconst Decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/./node_modules/cbor/lib/decoder.js\")\nconst Encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/./node_modules/cbor/lib/encoder.js\")\nconst Simple = __webpack_require__(/*! ./simple */ \"(ssr)/./node_modules/cbor/lib/simple.js\")\nconst Tagged = __webpack_require__(/*! ./tagged */ \"(ssr)/./node_modules/cbor/lib/tagged.js\")\nconst Map = __webpack_require__(/*! ./map */ \"(ssr)/./node_modules/cbor/lib/map.js\")\nconst SharedValueEncoder = __webpack_require__(/*! ./sharedValueEncoder */ \"(ssr)/./node_modules/cbor/lib/sharedValueEncoder.js\")\n\nmodule.exports = {\n  Commented,\n  Diagnose,\n  Decoder,\n  Encoder,\n  Simple,\n  Tagged,\n  Map,\n  SharedValueEncoder,\n\n  /**\n   * Convenience name for {@linkcode Commented.comment}.\n   */\n  comment: Commented.comment,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeAll}.\n   */\n  decodeAll: Decoder.decodeAll,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirst}.\n   */\n  decodeFirst: Decoder.decodeFirst,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeAllSync}.\n   */\n  decodeAllSync: Decoder.decodeAllSync,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirstSync}.\n   */\n  decodeFirstSync: Decoder.decodeFirstSync,\n\n  /**\n   * Convenience name for {@linkcode Diagnose.diagnose}.\n   */\n  diagnose: Diagnose.diagnose,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encode}.\n   */\n  encode: Encoder.encode,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeCanonical}.\n   */\n  encodeCanonical: Encoder.encodeCanonical,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeOne}.\n   */\n  encodeOne: Encoder.encodeOne,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeAsync}.\n   */\n  encodeAsync: Encoder.encodeAsync,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirstSync}.\n   */\n  decode: Decoder.decodeFirstSync,\n\n  /**\n   * The codec information for\n   * {@link https://github.com/Level/encoding-down encoding-down}, which is a\n   * codec framework for leveldb.  CBOR is a particularly convenient format for\n   * both keys and values, as it can deal with a lot of types that JSON can't\n   * handle without losing type information.\n   *\n   * @example\n   * const level = require('level')\n   * const cbor = require('cbor')\n   *\n   * async function putget() {\n   *   const db = level('./db', {\n   *     keyEncoding: cbor.leveldb,\n   *     valueEncoding: cbor.leveldb,\n   *   })\n   *\n   *   await db.put({a: 1}, 9857298342094820394820394820398234092834n)\n   *   const val = await db.get({a: 1})\n   * }\n   */\n  leveldb: {\n    decode: Decoder.decodeFirstSync,\n    encode: Encoder.encode,\n    buffer: true,\n    name: 'cbor',\n  },\n\n  /**\n   * Reset everything that we can predict a plugin might have altered in good\n   * faith.  For now that includes the default set of tags that decoding and\n   * encoding will use.\n   */\n  reset() {\n    Encoder.reset()\n    Tagged.reset()\n  },\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvY2Jvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixrQkFBa0IsbUJBQU8sQ0FBQywrREFBYTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyw2REFBWTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBVztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBVztBQUNuQyxlQUFlLG1CQUFPLENBQUMseURBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHlEQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyxtREFBTztBQUMzQiwyQkFBMkIsbUJBQU8sQ0FBQyxpRkFBc0I7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixrQ0FBa0M7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixrQ0FBa0M7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixrQ0FBa0M7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSwyREFBMkQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUIsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Nib3IvbGliL2Nib3IuanM/Y2JmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgQ29tbWVudGVkID0gcmVxdWlyZSgnLi9jb21tZW50ZWQnKVxuY29uc3QgRGlhZ25vc2UgPSByZXF1aXJlKCcuL2RpYWdub3NlJylcbmNvbnN0IERlY29kZXIgPSByZXF1aXJlKCcuL2RlY29kZXInKVxuY29uc3QgRW5jb2RlciA9IHJlcXVpcmUoJy4vZW5jb2RlcicpXG5jb25zdCBTaW1wbGUgPSByZXF1aXJlKCcuL3NpbXBsZScpXG5jb25zdCBUYWdnZWQgPSByZXF1aXJlKCcuL3RhZ2dlZCcpXG5jb25zdCBNYXAgPSByZXF1aXJlKCcuL21hcCcpXG5jb25zdCBTaGFyZWRWYWx1ZUVuY29kZXIgPSByZXF1aXJlKCcuL3NoYXJlZFZhbHVlRW5jb2RlcicpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDb21tZW50ZWQsXG4gIERpYWdub3NlLFxuICBEZWNvZGVyLFxuICBFbmNvZGVyLFxuICBTaW1wbGUsXG4gIFRhZ2dlZCxcbiAgTWFwLFxuICBTaGFyZWRWYWx1ZUVuY29kZXIsXG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG5hbWUgZm9yIHtAbGlua2NvZGUgQ29tbWVudGVkLmNvbW1lbnR9LlxuICAgKi9cbiAgY29tbWVudDogQ29tbWVudGVkLmNvbW1lbnQsXG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG5hbWUgZm9yIHtAbGlua2NvZGUgRGVjb2Rlci5kZWNvZGVBbGx9LlxuICAgKi9cbiAgZGVjb2RlQWxsOiBEZWNvZGVyLmRlY29kZUFsbCxcblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbmFtZSBmb3Ige0BsaW5rY29kZSBEZWNvZGVyLmRlY29kZUZpcnN0fS5cbiAgICovXG4gIGRlY29kZUZpcnN0OiBEZWNvZGVyLmRlY29kZUZpcnN0LFxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBuYW1lIGZvciB7QGxpbmtjb2RlIERlY29kZXIuZGVjb2RlQWxsU3luY30uXG4gICAqL1xuICBkZWNvZGVBbGxTeW5jOiBEZWNvZGVyLmRlY29kZUFsbFN5bmMsXG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG5hbWUgZm9yIHtAbGlua2NvZGUgRGVjb2Rlci5kZWNvZGVGaXJzdFN5bmN9LlxuICAgKi9cbiAgZGVjb2RlRmlyc3RTeW5jOiBEZWNvZGVyLmRlY29kZUZpcnN0U3luYyxcblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbmFtZSBmb3Ige0BsaW5rY29kZSBEaWFnbm9zZS5kaWFnbm9zZX0uXG4gICAqL1xuICBkaWFnbm9zZTogRGlhZ25vc2UuZGlhZ25vc2UsXG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG5hbWUgZm9yIHtAbGlua2NvZGUgRW5jb2Rlci5lbmNvZGV9LlxuICAgKi9cbiAgZW5jb2RlOiBFbmNvZGVyLmVuY29kZSxcblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbmFtZSBmb3Ige0BsaW5rY29kZSBFbmNvZGVyLmVuY29kZUNhbm9uaWNhbH0uXG4gICAqL1xuICBlbmNvZGVDYW5vbmljYWw6IEVuY29kZXIuZW5jb2RlQ2Fub25pY2FsLFxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBuYW1lIGZvciB7QGxpbmtjb2RlIEVuY29kZXIuZW5jb2RlT25lfS5cbiAgICovXG4gIGVuY29kZU9uZTogRW5jb2Rlci5lbmNvZGVPbmUsXG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG5hbWUgZm9yIHtAbGlua2NvZGUgRW5jb2Rlci5lbmNvZGVBc3luY30uXG4gICAqL1xuICBlbmNvZGVBc3luYzogRW5jb2Rlci5lbmNvZGVBc3luYyxcblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbmFtZSBmb3Ige0BsaW5rY29kZSBEZWNvZGVyLmRlY29kZUZpcnN0U3luY30uXG4gICAqL1xuICBkZWNvZGU6IERlY29kZXIuZGVjb2RlRmlyc3RTeW5jLFxuXG4gIC8qKlxuICAgKiBUaGUgY29kZWMgaW5mb3JtYXRpb24gZm9yXG4gICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vTGV2ZWwvZW5jb2RpbmctZG93biBlbmNvZGluZy1kb3dufSwgd2hpY2ggaXMgYVxuICAgKiBjb2RlYyBmcmFtZXdvcmsgZm9yIGxldmVsZGIuICBDQk9SIGlzIGEgcGFydGljdWxhcmx5IGNvbnZlbmllbnQgZm9ybWF0IGZvclxuICAgKiBib3RoIGtleXMgYW5kIHZhbHVlcywgYXMgaXQgY2FuIGRlYWwgd2l0aCBhIGxvdCBvZiB0eXBlcyB0aGF0IEpTT04gY2FuJ3RcbiAgICogaGFuZGxlIHdpdGhvdXQgbG9zaW5nIHR5cGUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGxldmVsID0gcmVxdWlyZSgnbGV2ZWwnKVxuICAgKiBjb25zdCBjYm9yID0gcmVxdWlyZSgnY2JvcicpXG4gICAqXG4gICAqIGFzeW5jIGZ1bmN0aW9uIHB1dGdldCgpIHtcbiAgICogICBjb25zdCBkYiA9IGxldmVsKCcuL2RiJywge1xuICAgKiAgICAga2V5RW5jb2Rpbmc6IGNib3IubGV2ZWxkYixcbiAgICogICAgIHZhbHVlRW5jb2Rpbmc6IGNib3IubGV2ZWxkYixcbiAgICogICB9KVxuICAgKlxuICAgKiAgIGF3YWl0IGRiLnB1dCh7YTogMX0sIDk4NTcyOTgzNDIwOTQ4MjAzOTQ4MjAzOTQ4MjAzOTgyMzQwOTI4MzRuKVxuICAgKiAgIGNvbnN0IHZhbCA9IGF3YWl0IGRiLmdldCh7YTogMX0pXG4gICAqIH1cbiAgICovXG4gIGxldmVsZGI6IHtcbiAgICBkZWNvZGU6IERlY29kZXIuZGVjb2RlRmlyc3RTeW5jLFxuICAgIGVuY29kZTogRW5jb2Rlci5lbmNvZGUsXG4gICAgYnVmZmVyOiB0cnVlLFxuICAgIG5hbWU6ICdjYm9yJyxcbiAgfSxcblxuICAvKipcbiAgICogUmVzZXQgZXZlcnl0aGluZyB0aGF0IHdlIGNhbiBwcmVkaWN0IGEgcGx1Z2luIG1pZ2h0IGhhdmUgYWx0ZXJlZCBpbiBnb29kXG4gICAqIGZhaXRoLiAgRm9yIG5vdyB0aGF0IGluY2x1ZGVzIHRoZSBkZWZhdWx0IHNldCBvZiB0YWdzIHRoYXQgZGVjb2RpbmcgYW5kXG4gICAqIGVuY29kaW5nIHdpbGwgdXNlLlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgRW5jb2Rlci5yZXNldCgpXG4gICAgVGFnZ2VkLnJlc2V0KClcbiAgfSxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/cbor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/lib/commented.js":
/*!********************************************!*\
  !*** ./node_modules/cbor/lib/commented.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst stream = __webpack_require__(/*! stream */ \"stream\")\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/cbor/lib/utils.js\")\nconst Decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/./node_modules/cbor/lib/decoder.js\")\nconst NoFilter = __webpack_require__(/*! nofilter */ \"(ssr)/./node_modules/nofilter/lib/index.js\")\nconst {MT, NUMBYTES, SYMS} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/cbor/lib/constants.js\")\nconst {Buffer} = __webpack_require__(/*! buffer */ \"buffer\")\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's'\n  }\n  return ''\n}\n\n/**\n * @typedef CommentOptions\n * @property {number} [max_depth=10] How many times to indent\n *   the dashes.\n * @property {number} [depth=1] Initial indentation depth.\n * @property {boolean} [no_summary=false] If true, omit the summary\n *   of the full bytes read at the end.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] Encoding to use for input, if it\n *   is a string.\n */\n/**\n * @callback commentCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [commented] The comment string.\n * @returns {void}\n */\n/**\n * Normalize inputs to the static functions.\n *\n * @param {CommentOptions|commentCallback|string|number} opts Encoding,\n *   max_depth, or callback.\n * @param {commentCallback} [cb] Called on completion.\n * @returns {{options: CommentOptions, cb: commentCallback}} Normalized value.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {commentCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'number':\n      return {options: {max_depth: opts}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Generate the expanded format of RFC 8949, section 3.2.2.\n *\n * @extends stream.Transform\n */\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {CommentOptions} [options={}] Stream options.\n   */\n  constructor(options = {}) {\n    const {\n      depth = 1,\n      max_depth = 10,\n      no_summary = false,\n      // Decoder options\n      tags = {},\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    })\n\n    this.depth = depth\n    this.max_depth = max_depth\n    this.all = new NoFilter()\n\n    if (!tags[24]) {\n      tags[24] = this._tag_24.bind(this)\n    }\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    })\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('start-string', this._on_start_string.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n    if (!no_summary) {\n      this.parser.on('data', this._on_data.bind(this))\n    }\n    this.parser.bs.on('read', this._on_read.bind(this))\n  }\n\n  /**\n   * @param {Buffer} v Descend into embedded CBOR.\n   * @private\n   */\n  _tag_24(v) {\n    const c = new Commented({depth: this.depth + 1, no_summary: true})\n\n    c.on('data', b => this.push(b))\n    c.on('error', er => this.emit('error', er))\n    c.end(v)\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb)\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb)\n  }\n\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input Something to parse.\n   * @param {CommentOptions|commentCallback|string|number} [options={}]\n   *   Encoding, max_depth, or callback.\n   * @param {commentCallback} [cb] If specified, called on completion.\n   * @returns {Promise} If cb not specified.\n   * @throws {Error} Input required.\n   * @static\n   */\n  static comment(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new Error('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const bs = new NoFilter()\n    const {encoding = 'hex', ...opts} = options\n    const d = new Commented(opts)\n    let p = null\n\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'))\n      })\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'))\n        })\n        d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    utils.guessEncoding(input, encoding).pipe(d)\n    return p\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    this.push('ERROR: ')\n    this.push(er.toString())\n    this.push('\\n')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_read(buf) {\n    this.all.write(buf)\n    const hex = buf.toString('hex')\n\n    this.push(new Array(this.depth + 1).join('  '))\n    this.push(hex)\n\n    let ind = ((this.max_depth - this.depth) * 2) - hex.length\n    if (ind < 1) {\n      ind = 1\n    }\n    this.push(new Array(ind + 1).join(' '))\n    this.push('-- ')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_more(mt, len, parent_mt, pos) {\n    let desc = ''\n\n    this.depth++\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,'\n        break\n      case MT.NEG_INT:\n        desc = 'Negative number,'\n        break\n      case MT.ARRAY:\n        desc = 'Array, length'\n        break\n      case MT.MAP:\n        desc = 'Map, count'\n        break\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length'\n        break\n      case MT.UTF8_STRING:\n        desc = 'String, length'\n        break\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,'\n        } else {\n          desc = 'Float,'\n        }\n        break\n    }\n    this.push(`${desc} next ${len} byte${plural(len)}\\n`)\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start_string(mt, len, parent_mt, pos) {\n    let desc = ''\n\n    this.depth++\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = `Bytes, length: ${len}`\n        break\n      case MT.UTF8_STRING:\n        desc = `String, length: ${len.toString()}`\n        break\n    }\n    this.push(`${desc}\\n`)\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++\n    switch (parent_mt) {\n      case MT.ARRAY:\n        this.push(`[${pos}], `)\n        break\n      case MT.MAP:\n        if (pos % 2) {\n          this.push(`{Val:${Math.floor(pos / 2)}}, `)\n        } else {\n          this.push(`{Key:${Math.floor(pos / 2)}}, `)\n        }\n        break\n    }\n    switch (mt) {\n      case MT.TAG:\n        this.push(`Tag #${tag}`)\n        if (tag === 24) {\n          this.push(' Encoded CBOR data item')\n        }\n        break\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)')\n        } else {\n          this.push(`Array, ${tag} item${plural(tag)}`)\n        }\n        break\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)')\n        } else {\n          this.push(`Map, ${tag} pair${plural(tag)}`)\n        }\n        break\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)')\n        break\n      case MT.UTF8_STRING:\n        this.push('String (streaming)')\n        break\n    }\n    this.push('\\n')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_stop(mt) {\n    this.depth--\n  }\n\n  /**\n   * @private\n   */\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `)\n          break\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `)\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `)\n          }\n          break\n      }\n    }\n    const str = utils.cborValueToString(val, -Infinity)\n\n    if ((typeof val === 'string') ||\n        (Buffer.isBuffer(val))) {\n      if (val.length > 0) {\n        this.push(str)\n        this.push('\\n')\n      }\n      this.depth--\n    } else {\n      this.push(str)\n      this.push('\\n')\n    }\n\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  _on_data() {\n    this.push('0x')\n    this.push(this.all.read().toString('hex'))\n    this.push('\\n')\n  }\n}\n\nmodule.exports = Commented\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvY29tbWVudGVkLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixjQUFjLG1CQUFPLENBQUMsdURBQVM7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVc7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsNERBQVU7QUFDbkMsT0FBTyxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLCtEQUFhO0FBQ2xELE9BQU8sUUFBUSxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBOEM7QUFDekQ7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixjQUFjLCtDQUErQztBQUM3RCxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxpQkFBaUIsaUJBQWlCO0FBQzNEO0FBQ0EsY0FBYyxVQUFVLHFCQUFxQixnQkFBZ0IsVUFBVTtBQUN2RTtBQUNBLGNBQWMsVUFBVSxnQkFBZ0I7QUFDeEM7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQixXQUFXO0FBQ3hDO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix3Q0FBd0M7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLGdCQUFnQjtBQUM3QixhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixrQ0FBa0M7QUFDbEMsYUFBYSw4Q0FBOEMsV0FBVztBQUN0RTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGVBQWUsU0FBUztBQUN4QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7QUFDbkI7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNLE9BQU8sS0FBSyxNQUFNLFlBQVk7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7QUFDQTtBQUNBLGlCQUFpQixLQUFLO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU0scUJBQXFCO0FBQ2pELFVBQVU7QUFDVixzQkFBc0IsTUFBTSxxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDhCQUE4QixLQUFLLE1BQU0sWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDRCQUE0QixLQUFLLE1BQU0sWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixJQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNLHFCQUFxQjtBQUNuRCxZQUFZO0FBQ1osd0JBQXdCLE1BQU0scUJBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0LWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yL2xpYi9jb21tZW50ZWQuanM/MzI2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBEZWNvZGVyID0gcmVxdWlyZSgnLi9kZWNvZGVyJylcbmNvbnN0IE5vRmlsdGVyID0gcmVxdWlyZSgnbm9maWx0ZXInKVxuY29uc3Qge01ULCBOVU1CWVRFUywgU1lNU30gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7QnVmZmVyfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbmZ1bmN0aW9uIHBsdXJhbChjKSB7XG4gIGlmIChjID4gMSkge1xuICAgIHJldHVybiAncydcbiAgfVxuICByZXR1cm4gJydcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBDb21tZW50T3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhfZGVwdGg9MTBdIEhvdyBtYW55IHRpbWVzIHRvIGluZGVudFxuICogICB0aGUgZGFzaGVzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkZXB0aD0xXSBJbml0aWFsIGluZGVudGF0aW9uIGRlcHRoLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbbm9fc3VtbWFyeT1mYWxzZV0gSWYgdHJ1ZSwgb21pdCB0aGUgc3VtbWFyeVxuICogICBvZiB0aGUgZnVsbCBieXRlcyByZWFkIGF0IHRoZSBlbmQuXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3RhZ3NdIE1hcHBpbmcgZnJvbSB0YWcgbnVtYmVyIHRvIGZ1bmN0aW9uKHYpLFxuICogICB3aGVyZSB2IGlzIHRoZSBkZWNvZGVkIHZhbHVlIHRoYXQgY29tZXMgYWZ0ZXIgdGhlIHRhZywgYW5kIHdoZXJlIHRoZVxuICogICBmdW5jdGlvbiByZXR1cm5zIHRoZSBjb3JyZWN0bHktY3JlYXRlZCB2YWx1ZSBmb3IgdGhhdCB0YWcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwcmVmZXJXZWI9ZmFsc2VdIElmIHRydWUsIHByZWZlciBVaW50OEFycmF5cyB0b1xuICogICBiZSBnZW5lcmF0ZWQgaW5zdGVhZCBvZiBub2RlIEJ1ZmZlcnMuICBUaGlzIG1pZ2h0IHR1cm4gb24gc29tZSBtb3JlXG4gKiAgIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZSwgc28gZm9yd2FyZC1jb21wYXRpYmlsaXR5IGlzIG5vdCBndWFyYW50ZWVkIHlldC5cbiAqIEBwcm9wZXJ0eSB7QnVmZmVyRW5jb2Rpbmd9IFtlbmNvZGluZz0naGV4J10gRW5jb2RpbmcgdG8gdXNlIGZvciBpbnB1dCwgaWYgaXRcbiAqICAgaXMgYSBzdHJpbmcuXG4gKi9cbi8qKlxuICogQGNhbGxiYWNrIGNvbW1lbnRDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gW2Vycm9yXSBJZiBvbmUgd2FzIGdlbmVyYXRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudGVkXSBUaGUgY29tbWVudCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuLyoqXG4gKiBOb3JtYWxpemUgaW5wdXRzIHRvIHRoZSBzdGF0aWMgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7Q29tbWVudE9wdGlvbnN8Y29tbWVudENhbGxiYWNrfHN0cmluZ3xudW1iZXJ9IG9wdHMgRW5jb2RpbmcsXG4gKiAgIG1heF9kZXB0aCwgb3IgY2FsbGJhY2suXG4gKiBAcGFyYW0ge2NvbW1lbnRDYWxsYmFja30gW2NiXSBDYWxsZWQgb24gY29tcGxldGlvbi5cbiAqIEByZXR1cm5zIHt7b3B0aW9uczogQ29tbWVudE9wdGlvbnMsIGNiOiBjb21tZW50Q2FsbGJhY2t9fSBOb3JtYWxpemVkIHZhbHVlLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBVbmtub3duIG9wdGlvbiB0eXBlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhvcHRzLCBjYikge1xuICBzd2l0Y2ggKHR5cGVvZiBvcHRzKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIHtvcHRpb25zOiB7fSwgY2I6IC8qKiBAdHlwZSB7Y29tbWVudENhbGxiYWNrfSAqLyAob3B0cyl9XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB7b3B0aW9uczoge2VuY29kaW5nOiAvKiogQHR5cGUge0J1ZmZlckVuY29kaW5nfSAqLyAob3B0cyl9LCBjYn1cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIHtvcHRpb25zOiB7bWF4X2RlcHRoOiBvcHRzfSwgY2J9XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiB7b3B0aW9uczogb3B0cyB8fCB7fSwgY2J9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gb3B0aW9uIHR5cGUnKVxuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIGV4cGFuZGVkIGZvcm1hdCBvZiBSRkMgODk0OSwgc2VjdGlvbiAzLjIuMi5cbiAqXG4gKiBAZXh0ZW5kcyBzdHJlYW0uVHJhbnNmb3JtXG4gKi9cbmNsYXNzIENvbW1lbnRlZCBleHRlbmRzIHN0cmVhbS5UcmFuc2Zvcm0ge1xuICAvKipcbiAgICogQ3JlYXRlIGEgQ0JPUiBjb21tZW50ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tbWVudE9wdGlvbnN9IFtvcHRpb25zPXt9XSBTdHJlYW0gb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlcHRoID0gMSxcbiAgICAgIG1heF9kZXB0aCA9IDEwLFxuICAgICAgbm9fc3VtbWFyeSA9IGZhbHNlLFxuICAgICAgLy8gRGVjb2RlciBvcHRpb25zXG4gICAgICB0YWdzID0ge30sXG4gICAgICBwcmVmZXJXZWIsXG4gICAgICBlbmNvZGluZyxcbiAgICAgIC8vIFN0cmVhbS5UcmFuc2Zvcm0gb3B0aW9uc1xuICAgICAgLi4uc3VwZXJPcHRzXG4gICAgfSA9IG9wdGlvbnNcblxuICAgIHN1cGVyKHtcbiAgICAgIC4uLnN1cGVyT3B0cyxcbiAgICAgIHJlYWRhYmxlT2JqZWN0TW9kZTogZmFsc2UsXG4gICAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlLFxuICAgIH0pXG5cbiAgICB0aGlzLmRlcHRoID0gZGVwdGhcbiAgICB0aGlzLm1heF9kZXB0aCA9IG1heF9kZXB0aFxuICAgIHRoaXMuYWxsID0gbmV3IE5vRmlsdGVyKClcblxuICAgIGlmICghdGFnc1syNF0pIHtcbiAgICAgIHRhZ3NbMjRdID0gdGhpcy5fdGFnXzI0LmJpbmQodGhpcylcbiAgICB9XG4gICAgdGhpcy5wYXJzZXIgPSBuZXcgRGVjb2Rlcih7XG4gICAgICB0YWdzLFxuICAgICAgbWF4X2RlcHRoLFxuICAgICAgcHJlZmVyV2ViLFxuICAgICAgZW5jb2RpbmcsXG4gICAgfSlcbiAgICB0aGlzLnBhcnNlci5vbigndmFsdWUnLCB0aGlzLl9vbl92YWx1ZS5iaW5kKHRoaXMpKVxuICAgIHRoaXMucGFyc2VyLm9uKCdzdGFydCcsIHRoaXMuX29uX3N0YXJ0LmJpbmQodGhpcykpXG4gICAgdGhpcy5wYXJzZXIub24oJ3N0YXJ0LXN0cmluZycsIHRoaXMuX29uX3N0YXJ0X3N0cmluZy5iaW5kKHRoaXMpKVxuICAgIHRoaXMucGFyc2VyLm9uKCdzdG9wJywgdGhpcy5fb25fc3RvcC5iaW5kKHRoaXMpKVxuICAgIHRoaXMucGFyc2VyLm9uKCdtb3JlLWJ5dGVzJywgdGhpcy5fb25fbW9yZS5iaW5kKHRoaXMpKVxuICAgIHRoaXMucGFyc2VyLm9uKCdlcnJvcicsIHRoaXMuX29uX2Vycm9yLmJpbmQodGhpcykpXG4gICAgaWYgKCFub19zdW1tYXJ5KSB7XG4gICAgICB0aGlzLnBhcnNlci5vbignZGF0YScsIHRoaXMuX29uX2RhdGEuYmluZCh0aGlzKSlcbiAgICB9XG4gICAgdGhpcy5wYXJzZXIuYnMub24oJ3JlYWQnLCB0aGlzLl9vbl9yZWFkLmJpbmQodGhpcykpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHYgRGVzY2VuZCBpbnRvIGVtYmVkZGVkIENCT1IuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdGFnXzI0KHYpIHtcbiAgICBjb25zdCBjID0gbmV3IENvbW1lbnRlZCh7ZGVwdGg6IHRoaXMuZGVwdGggKyAxLCBub19zdW1tYXJ5OiB0cnVlfSlcblxuICAgIGMub24oJ2RhdGEnLCBiID0+IHRoaXMucHVzaChiKSlcbiAgICBjLm9uKCdlcnJvcicsIGVyID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcikpXG4gICAgYy5lbmQodilcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBmcmVzaCBCdWZmZXIgdG8gdHJhbnNjb2RlLlxuICAgKiBAcGFyYW0ge0J1ZmZlckVuY29kaW5nfSBlbmNvZGluZyBOYW1lIG9mIGVuY29kaW5nLlxuICAgKiBAcGFyYW0ge3N0cmVhbS5UcmFuc2Zvcm1DYWxsYmFja30gY2IgQ2FsbGJhY2sgd2hlbiBkb25lLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfdHJhbnNmb3JtKGZyZXNoLCBlbmNvZGluZywgY2IpIHtcbiAgICB0aGlzLnBhcnNlci53cml0ZShmcmVzaCwgZW5jb2RpbmcsIGNiKVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmVhbS5UcmFuc2Zvcm1DYWxsYmFja30gY2IgQ2FsbGJhY2sgd2hlbiBkb25lLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfZmx1c2goY2IpIHtcbiAgICAvLyBUT0RPOiBmaW5kIHRoZSB0ZXN0IHRoYXQgY292ZXJzIHRoaXMsIGFuZCBsb29rIGF0IHRoZSByZXR1cm4gdmFsdWVcbiAgICByZXR1cm4gdGhpcy5wYXJzZXIuX2ZsdXNoKGNiKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbW1lbnQgb24gYW4gaW5wdXQgQnVmZmVyIG9yIHN0cmluZywgY3JlYXRpbmcgYSBzdHJpbmcgcGFzc2VkIHRvIHRoZVxuICAgKiBjYWxsYmFjay4gIElmIGNhbGxiYWNrIG5vdCBzcGVjaWZpZWQsIGEgcHJvbWlzZSBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8VWludDhDbGFtcGVkQXJyYXlcbiAgICogICB8RGF0YVZpZXd8c3RyZWFtLlJlYWRhYmxlfSBpbnB1dCBTb21ldGhpbmcgdG8gcGFyc2UuXG4gICAqIEBwYXJhbSB7Q29tbWVudE9wdGlvbnN8Y29tbWVudENhbGxiYWNrfHN0cmluZ3xudW1iZXJ9IFtvcHRpb25zPXt9XVxuICAgKiAgIEVuY29kaW5nLCBtYXhfZGVwdGgsIG9yIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0ge2NvbW1lbnRDYWxsYmFja30gW2NiXSBJZiBzcGVjaWZpZWQsIGNhbGxlZCBvbiBjb21wbGV0aW9uLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gSWYgY2Igbm90IHNwZWNpZmllZC5cbiAgICogQHRocm93cyB7RXJyb3J9IElucHV0IHJlcXVpcmVkLlxuICAgKiBAc3RhdGljXG4gICAqL1xuICBzdGF0aWMgY29tbWVudChpbnB1dCwgb3B0aW9ucyA9IHt9LCBjYiA9IG51bGwpIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCByZXF1aXJlZCcpXG4gICAgfVxuICAgICh7b3B0aW9ucywgY2J9ID0gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zLCBjYikpXG4gICAgY29uc3QgYnMgPSBuZXcgTm9GaWx0ZXIoKVxuICAgIGNvbnN0IHtlbmNvZGluZyA9ICdoZXgnLCAuLi5vcHRzfSA9IG9wdGlvbnNcbiAgICBjb25zdCBkID0gbmV3IENvbW1lbnRlZChvcHRzKVxuICAgIGxldCBwID0gbnVsbFxuXG4gICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZC5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICBjYihudWxsLCBicy50b1N0cmluZygndXRmOCcpKVxuICAgICAgfSlcbiAgICAgIGQub24oJ2Vycm9yJywgY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGQub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGJzLnRvU3RyaW5nKCd1dGY4JykpXG4gICAgICAgIH0pXG4gICAgICAgIGQub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgfSlcbiAgICB9XG4gICAgZC5waXBlKGJzKVxuICAgIHV0aWxzLmd1ZXNzRW5jb2RpbmcoaW5wdXQsIGVuY29kaW5nKS5waXBlKGQpXG4gICAgcmV0dXJuIHBcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfb25fZXJyb3IoZXIpIHtcbiAgICB0aGlzLnB1c2goJ0VSUk9SOiAnKVxuICAgIHRoaXMucHVzaChlci50b1N0cmluZygpKVxuICAgIHRoaXMucHVzaCgnXFxuJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfb25fcmVhZChidWYpIHtcbiAgICB0aGlzLmFsbC53cml0ZShidWYpXG4gICAgY29uc3QgaGV4ID0gYnVmLnRvU3RyaW5nKCdoZXgnKVxuXG4gICAgdGhpcy5wdXNoKG5ldyBBcnJheSh0aGlzLmRlcHRoICsgMSkuam9pbignICAnKSlcbiAgICB0aGlzLnB1c2goaGV4KVxuXG4gICAgbGV0IGluZCA9ICgodGhpcy5tYXhfZGVwdGggLSB0aGlzLmRlcHRoKSAqIDIpIC0gaGV4Lmxlbmd0aFxuICAgIGlmIChpbmQgPCAxKSB7XG4gICAgICBpbmQgPSAxXG4gICAgfVxuICAgIHRoaXMucHVzaChuZXcgQXJyYXkoaW5kICsgMSkuam9pbignICcpKVxuICAgIHRoaXMucHVzaCgnLS0gJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfb25fbW9yZShtdCwgbGVuLCBwYXJlbnRfbXQsIHBvcykge1xuICAgIGxldCBkZXNjID0gJydcblxuICAgIHRoaXMuZGVwdGgrK1xuICAgIHN3aXRjaCAobXQpIHtcbiAgICAgIGNhc2UgTVQuUE9TX0lOVDpcbiAgICAgICAgZGVzYyA9ICdQb3NpdGl2ZSBudW1iZXIsJ1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBNVC5ORUdfSU5UOlxuICAgICAgICBkZXNjID0gJ05lZ2F0aXZlIG51bWJlciwnXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIE1ULkFSUkFZOlxuICAgICAgICBkZXNjID0gJ0FycmF5LCBsZW5ndGgnXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIE1ULk1BUDpcbiAgICAgICAgZGVzYyA9ICdNYXAsIGNvdW50J1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBNVC5CWVRFX1NUUklORzpcbiAgICAgICAgZGVzYyA9ICdCeXRlcywgbGVuZ3RoJ1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBNVC5VVEY4X1NUUklORzpcbiAgICAgICAgZGVzYyA9ICdTdHJpbmcsIGxlbmd0aCdcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgTVQuU0lNUExFX0ZMT0FUOlxuICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgZGVzYyA9ICdTaW1wbGUgdmFsdWUsJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlc2MgPSAnRmxvYXQsJ1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHRoaXMucHVzaChgJHtkZXNjfSBuZXh0ICR7bGVufSBieXRlJHtwbHVyYWwobGVuKX1cXG5gKVxuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF9vbl9zdGFydF9zdHJpbmcobXQsIGxlbiwgcGFyZW50X210LCBwb3MpIHtcbiAgICBsZXQgZGVzYyA9ICcnXG5cbiAgICB0aGlzLmRlcHRoKytcbiAgICBzd2l0Y2ggKG10KSB7XG4gICAgICBjYXNlIE1ULkJZVEVfU1RSSU5HOlxuICAgICAgICBkZXNjID0gYEJ5dGVzLCBsZW5ndGg6ICR7bGVufWBcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgTVQuVVRGOF9TVFJJTkc6XG4gICAgICAgIGRlc2MgPSBgU3RyaW5nLCBsZW5ndGg6ICR7bGVuLnRvU3RyaW5nKCl9YFxuICAgICAgICBicmVha1xuICAgIH1cbiAgICB0aGlzLnB1c2goYCR7ZGVzY31cXG5gKVxuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF9vbl9zdGFydChtdCwgdGFnLCBwYXJlbnRfbXQsIHBvcykge1xuICAgIHRoaXMuZGVwdGgrK1xuICAgIHN3aXRjaCAocGFyZW50X210KSB7XG4gICAgICBjYXNlIE1ULkFSUkFZOlxuICAgICAgICB0aGlzLnB1c2goYFske3Bvc31dLCBgKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBNVC5NQVA6XG4gICAgICAgIGlmIChwb3MgJSAyKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKGB7VmFsOiR7TWF0aC5mbG9vcihwb3MgLyAyKX19LCBgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHVzaChge0tleToke01hdGguZmxvb3IocG9zIC8gMil9fSwgYClcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICBzd2l0Y2ggKG10KSB7XG4gICAgICBjYXNlIE1ULlRBRzpcbiAgICAgICAgdGhpcy5wdXNoKGBUYWcgIyR7dGFnfWApXG4gICAgICAgIGlmICh0YWcgPT09IDI0KSB7XG4gICAgICAgICAgdGhpcy5wdXNoKCcgRW5jb2RlZCBDQk9SIGRhdGEgaXRlbScpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgTVQuQVJSQVk6XG4gICAgICAgIGlmICh0YWcgPT09IFNZTVMuU1RSRUFNKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKCdBcnJheSAoc3RyZWFtaW5nKScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wdXNoKGBBcnJheSwgJHt0YWd9IGl0ZW0ke3BsdXJhbCh0YWcpfWApXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgTVQuTUFQOlxuICAgICAgICBpZiAodGFnID09PSBTWU1TLlNUUkVBTSkge1xuICAgICAgICAgIHRoaXMucHVzaCgnTWFwIChzdHJlYW1pbmcpJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnB1c2goYE1hcCwgJHt0YWd9IHBhaXIke3BsdXJhbCh0YWcpfWApXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgTVQuQllURV9TVFJJTkc6XG4gICAgICAgIHRoaXMucHVzaCgnQnl0ZXMgKHN0cmVhbWluZyknKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBNVC5VVEY4X1NUUklORzpcbiAgICAgICAgdGhpcy5wdXNoKCdTdHJpbmcgKHN0cmVhbWluZyknKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICB0aGlzLnB1c2goJ1xcbicpXG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX29uX3N0b3AobXQpIHtcbiAgICB0aGlzLmRlcHRoLS1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uX3ZhbHVlKHZhbCwgcGFyZW50X210LCBwb3MsIGFpKSB7XG4gICAgaWYgKHZhbCAhPT0gU1lNUy5CUkVBSykge1xuICAgICAgc3dpdGNoIChwYXJlbnRfbXQpIHtcbiAgICAgICAgY2FzZSBNVC5BUlJBWTpcbiAgICAgICAgICB0aGlzLnB1c2goYFske3Bvc31dLCBgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgTVQuTUFQOlxuICAgICAgICAgIGlmIChwb3MgJSAyKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2goYHtWYWw6JHtNYXRoLmZsb29yKHBvcyAvIDIpfX0sIGApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChge0tleToke01hdGguZmxvb3IocG9zIC8gMil9fSwgYClcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RyID0gdXRpbHMuY2JvclZhbHVlVG9TdHJpbmcodmFsLCAtSW5maW5pdHkpXG5cbiAgICBpZiAoKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB8fFxuICAgICAgICAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpKSB7XG4gICAgICBpZiAodmFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5wdXNoKHN0cilcbiAgICAgICAgdGhpcy5wdXNoKCdcXG4nKVxuICAgICAgfVxuICAgICAgdGhpcy5kZXB0aC0tXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHVzaChzdHIpXG4gICAgICB0aGlzLnB1c2goJ1xcbicpXG4gICAgfVxuXG4gICAgc3dpdGNoIChhaSkge1xuICAgICAgY2FzZSBOVU1CWVRFUy5PTkU6XG4gICAgICBjYXNlIE5VTUJZVEVTLlRXTzpcbiAgICAgIGNhc2UgTlVNQllURVMuRk9VUjpcbiAgICAgIGNhc2UgTlVNQllURVMuRUlHSFQ6XG4gICAgICAgIHRoaXMuZGVwdGgtLVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfb25fZGF0YSgpIHtcbiAgICB0aGlzLnB1c2goJzB4JylcbiAgICB0aGlzLnB1c2godGhpcy5hbGwucmVhZCgpLnRvU3RyaW5nKCdoZXgnKSlcbiAgICB0aGlzLnB1c2goJ1xcbicpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21tZW50ZWRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/commented.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/lib/constants.js":
/*!********************************************!*\
  !*** ./node_modules/cbor/lib/constants.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n/**\n * @enum {number}\n */\nexports.MT = {\n  POS_INT: 0,\n  NEG_INT: 1,\n  BYTE_STRING: 2,\n  UTF8_STRING: 3,\n  ARRAY: 4,\n  MAP: 5,\n  TAG: 6,\n  SIMPLE_FLOAT: 7,\n}\n\n/**\n * @enum {number}\n */\nexports.TAG = {\n  DATE_STRING: 0,\n  DATE_EPOCH: 1,\n  POS_BIGINT: 2,\n  NEG_BIGINT: 3,\n  DECIMAL_FRAC: 4,\n  BIGFLOAT: 5,\n  BASE64URL_EXPECTED: 21,\n  BASE64_EXPECTED: 22,\n  BASE16_EXPECTED: 23,\n  CBOR: 24,\n  URI: 32,\n  BASE64URL: 33,\n  BASE64: 34,\n  REGEXP: 35,\n  MIME: 36,\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  SET: 258,\n}\n\n/**\n * @enum {number}\n */\nexports.NUMBYTES = {\n  ZERO: 0,\n  ONE: 24,\n  TWO: 25,\n  FOUR: 26,\n  EIGHT: 27,\n  INDEFINITE: 31,\n}\n\n/**\n * @enum {number}\n */\nexports.SIMPLE = {\n  FALSE: 20,\n  TRUE: 21,\n  NULL: 22,\n  UNDEFINED: 23,\n}\n\nexports.SYMS = {\n  NULL: Symbol.for('github.com/hildjj/node-cbor/null'),\n  UNDEFINED: Symbol.for('github.com/hildjj/node-cbor/undef'),\n  PARENT: Symbol.for('github.com/hildjj/node-cbor/parent'),\n  BREAK: Symbol.for('github.com/hildjj/node-cbor/break'),\n  STREAM: Symbol.for('github.com/hildjj/node-cbor/stream'),\n}\n\nexports.SHIFT32 = 0x100000000\n\nexports.BI = {\n  MINUS_ONE: BigInt(-1),\n  NEG_MAX: BigInt(-1) - BigInt(Number.MAX_SAFE_INTEGER),\n  MAXINT32: BigInt('0xffffffff'),\n  MAXINT64: BigInt('0xffffffffffffffff'),\n  SHIFT32: BigInt(exports.SHIFT32),\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7O0FBRWYsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC1jbGllbnQvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvY29uc3RhbnRzLmpzP2U5MmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0cy5NVCA9IHtcbiAgUE9TX0lOVDogMCxcbiAgTkVHX0lOVDogMSxcbiAgQllURV9TVFJJTkc6IDIsXG4gIFVURjhfU1RSSU5HOiAzLFxuICBBUlJBWTogNCxcbiAgTUFQOiA1LFxuICBUQUc6IDYsXG4gIFNJTVBMRV9GTE9BVDogNyxcbn1cblxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnRzLlRBRyA9IHtcbiAgREFURV9TVFJJTkc6IDAsXG4gIERBVEVfRVBPQ0g6IDEsXG4gIFBPU19CSUdJTlQ6IDIsXG4gIE5FR19CSUdJTlQ6IDMsXG4gIERFQ0lNQUxfRlJBQzogNCxcbiAgQklHRkxPQVQ6IDUsXG4gIEJBU0U2NFVSTF9FWFBFQ1RFRDogMjEsXG4gIEJBU0U2NF9FWFBFQ1RFRDogMjIsXG4gIEJBU0UxNl9FWFBFQ1RFRDogMjMsXG4gIENCT1I6IDI0LFxuICBVUkk6IDMyLFxuICBCQVNFNjRVUkw6IDMzLFxuICBCQVNFNjQ6IDM0LFxuICBSRUdFWFA6IDM1LFxuICBNSU1FOiAzNixcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lucHV0LW91dHB1dC1oay9jYm9yLXNldHMtc3BlYy9ibG9iL21hc3Rlci9DQk9SX1NFVFMubWRcbiAgU0VUOiAyNTgsXG59XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0cy5OVU1CWVRFUyA9IHtcbiAgWkVSTzogMCxcbiAgT05FOiAyNCxcbiAgVFdPOiAyNSxcbiAgRk9VUjogMjYsXG4gIEVJR0hUOiAyNyxcbiAgSU5ERUZJTklURTogMzEsXG59XG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0cy5TSU1QTEUgPSB7XG4gIEZBTFNFOiAyMCxcbiAgVFJVRTogMjEsXG4gIE5VTEw6IDIyLFxuICBVTkRFRklORUQ6IDIzLFxufVxuXG5leHBvcnRzLlNZTVMgPSB7XG4gIE5VTEw6IFN5bWJvbC5mb3IoJ2dpdGh1Yi5jb20vaGlsZGpqL25vZGUtY2Jvci9udWxsJyksXG4gIFVOREVGSU5FRDogU3ltYm9sLmZvcignZ2l0aHViLmNvbS9oaWxkamovbm9kZS1jYm9yL3VuZGVmJyksXG4gIFBBUkVOVDogU3ltYm9sLmZvcignZ2l0aHViLmNvbS9oaWxkamovbm9kZS1jYm9yL3BhcmVudCcpLFxuICBCUkVBSzogU3ltYm9sLmZvcignZ2l0aHViLmNvbS9oaWxkamovbm9kZS1jYm9yL2JyZWFrJyksXG4gIFNUUkVBTTogU3ltYm9sLmZvcignZ2l0aHViLmNvbS9oaWxkamovbm9kZS1jYm9yL3N0cmVhbScpLFxufVxuXG5leHBvcnRzLlNISUZUMzIgPSAweDEwMDAwMDAwMFxuXG5leHBvcnRzLkJJID0ge1xuICBNSU5VU19PTkU6IEJpZ0ludCgtMSksXG4gIE5FR19NQVg6IEJpZ0ludCgtMSkgLSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLFxuICBNQVhJTlQzMjogQmlnSW50KCcweGZmZmZmZmZmJyksXG4gIE1BWElOVDY0OiBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpLFxuICBTSElGVDMyOiBCaWdJbnQoZXhwb3J0cy5TSElGVDMyKSxcbn1cblxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/lib/decoder.js":
/*!******************************************!*\
  !*** ./node_modules/cbor/lib/decoder.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst BinaryParseStream = __webpack_require__(/*! ../vendor/binary-parse-stream */ \"(ssr)/./node_modules/cbor/vendor/binary-parse-stream/index.js\")\nconst Tagged = __webpack_require__(/*! ./tagged */ \"(ssr)/./node_modules/cbor/lib/tagged.js\")\nconst Simple = __webpack_require__(/*! ./simple */ \"(ssr)/./node_modules/cbor/lib/simple.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/cbor/lib/utils.js\")\nconst NoFilter = __webpack_require__(/*! nofilter */ \"(ssr)/./node_modules/nofilter/lib/index.js\")\nconst stream = __webpack_require__(/*! stream */ \"stream\")\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/cbor/lib/constants.js\")\nconst {MT, NUMBYTES, SYMS, BI} = constants\nconst {Buffer} = __webpack_require__(/*! buffer */ \"buffer\")\n\nconst COUNT = Symbol('count')\nconst MAJOR = Symbol('major type')\nconst ERROR = Symbol('error')\nconst NOT_FOUND = Symbol('not found')\n\nfunction parentArray(parent, typ, count) {\n  const a = []\n\n  a[COUNT] = count\n  a[SYMS.PARENT] = parent\n  a[MAJOR] = typ\n  return a\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter()\n\n  b[COUNT] = -1\n  b[SYMS.PARENT] = parent\n  b[MAJOR] = typ\n  return b\n}\n\nclass UnexpectedDataError extends Error {\n  constructor(byte, value) {\n    super(`Unexpected data: 0x${byte.toString(16)}`)\n    this.name = 'UnexpectedDataError'\n    this.byte = byte\n    this.value = value\n  }\n}\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n/**\n * @typedef ExtendedResults\n * @property {any} value The value that was found.\n * @property {number} length The number of bytes of the original input that\n *   were read.\n * @property {Buffer} bytes The bytes of the original input that were used\n *   to produce the value.\n * @property {Buffer} [unused] The bytes that were left over from the original\n *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or\n *   {@linkcode Decoder.decodeFirstSync} was called.\n */\n/**\n * @typedef DecoderOptions\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of the input.\n *   Ignored if input is a Buffer.\n * @property {boolean} [required=false] Should an error be thrown when no\n *   data is in the input?\n * @property {boolean} [extendedResults=false] If true, emit extended\n *   results, which will be an object with shape {@link ExtendedResults}.\n *   The value will already have been null-checked.\n * @property {boolean} [preventDuplicateKeys=false] If true, error is\n *   thrown if a map has duplicate keys.\n */\n/**\n * @callback decodeCallback\n * @param {Error} [error] If one was generated.\n * @param {any} [value] The decoded value.\n * @returns {void}\n */\n/**\n * @param {DecoderOptions|decodeCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {decodeCallback} [cb] Called on completion.\n * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.\n * @throws {TypeError} On unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {decodeCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends BinaryParseStream\n */\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {DecoderOptions} [options={}] Options.\n   */\n  constructor(options = {}) {\n    const {\n      tags = {},\n      max_depth = -1,\n      preferWeb = false,\n      required = false,\n      encoding = 'hex',\n      extendedResults = false,\n      preventDuplicateKeys = false,\n      ...superOpts\n    } = options\n\n    super({defaultEncoding: encoding, ...superOpts})\n\n    this.running = true\n    this.max_depth = max_depth\n    this.tags = tags\n    this.preferWeb = preferWeb\n    this.extendedResults = extendedResults\n    this.required = required\n    this.preventDuplicateKeys = preventDuplicateKeys\n\n    if (extendedResults) {\n      this.bs.on('read', this._onRead.bind(this))\n      this.valueBytes = /** @type {NoFilter} */ (new NoFilter())\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @param {any} val The value to check.\n   * @returns {any} The corrected value.\n   * @throws {Error} Nothing was found.\n   * @static\n   * @example\n   * myDecoder.on('data', val => {\n   *   val = Decoder.nullcheck(val)\n   *   // ...\n   * })\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null\n      case SYMS.UNDEFINED:\n        return undefined\n      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure\n      // it can't happen.\n      /* istanbul ignore next */\n      case NOT_FOUND:\n        /* istanbul ignore next */\n        throw new Error('Value not found')\n      default:\n        return val\n    }\n  }\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw\n   * an exception if the input is not valid CBOR, or if there are more bytes\n   * left over at the end (if options.extendedResults is not true).\n   *\n   * @param {BufferLike} input If a Readable stream, must have\n   *   received the `readable` event already, or you will get an error\n   *   claiming \"Insufficient data\".\n   * @param {DecoderOptions|string} [options={}] Options or encoding for input.\n   * @returns {ExtendedResults|any} The decoded value.\n   * @throws {UnexpectedDataError} Data is left over after decoding.\n   * @throws {Error} Insufficient data.\n   * @static\n   */\n  static decodeFirstSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options} = normalizeOptions(options))\n    const {encoding = 'hex', ...opts} = options\n    const c = new Decoder(opts)\n    const s = utils.guessEncoding(input, encoding)\n\n    // For/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse()\n    let state = parser.next()\n\n    while (!state.done) {\n      const b = s.read(state.value)\n\n      if ((b == null) || (b.length !== state.value)) {\n        throw new Error('Insufficient data')\n      }\n      if (c.extendedResults) {\n        c.valueBytes.write(b)\n      }\n      state = parser.next(b)\n    }\n\n    let val = null\n    if (c.extendedResults) {\n      val = state.value\n      val.unused = s.read()\n    } else {\n      val = Decoder.nullcheck(state.value)\n      if (s.length > 0) {\n        const nextByte = s.read(1)\n\n        s.unshift(nextByte)\n        throw new UnexpectedDataError(nextByte[0], val)\n      }\n    }\n    return val\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|string} [options={}] Options or encoding\n   *   for input.\n   * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.\n   * @throws {TypeError} No input provided.\n   * @throws {Error} Insufficient data provided.\n   * @static\n   */\n  static decodeAllSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options} = normalizeOptions(options))\n    const {encoding = 'hex', ...opts} = options\n    const c = new Decoder(opts)\n    const s = utils.guessEncoding(input, encoding)\n    const res = []\n\n    while (s.length > 0) {\n      const parser = c._parse()\n      let state = parser.next()\n\n      while (!state.done) {\n        const b = s.read(state.value)\n\n        if ((b == null) || (b.length !== state.value)) {\n          throw new Error('Insufficient data')\n        }\n        if (c.extendedResults) {\n          c.valueBytes.write(b)\n        }\n        state = parser.next(b)\n      }\n      res.push(Decoder.nullcheck(state.value))\n    }\n    return res\n  }\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are\n   * more bytes left over at the end (if options.extendedResults is not true),\n   * and optionally if there were no valid CBOR bytes in the input.  Emits the\n   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the\n   * `required` option is false.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the\n   *   callback, or input encoding.\n   * @param {decodeCallback} [cb] Callback.\n   * @returns {Promise<ExtendedResults|any>} Returned even if callback is\n   *   specified.\n   * @throws {TypeError} No input provided.\n   * @static\n   */\n  static decodeFirst(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', required = false, ...opts} = options\n\n    const c = new Decoder(opts)\n    let v = /** @type {any} */ (NOT_FOUND)\n    const s = utils.guessEncoding(input, encoding)\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val)\n        c.close()\n      })\n      c.once('error', er => {\n        if (c.extendedResults && (er instanceof UnexpectedDataError)) {\n          v.unused = c.bs.slice()\n          return resolve(v)\n        }\n        if (v !== NOT_FOUND) {\n          // Typescript work-around\n          // eslint-disable-next-line dot-notation\n          er['value'] = v\n        }\n        v = ERROR\n        c.close()\n        return reject(er)\n      })\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'))\n            }\n            return resolve(v)\n          // Pretty sure this can't happen, but not *certain*.\n          /* istanbul ignore next */\n          case ERROR:\n            /* istanbul ignore next */\n            return undefined\n          default:\n            return resolve(v)\n        }\n      })\n    })\n\n    if (typeof cb === 'function') {\n      p.then(val => cb(null, val), cb)\n    }\n    s.pipe(c)\n    return p\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error If one was generated.\n   * @param {Array<ExtendedResults>|Array<any>} value All of the decoded\n   *   values, wrapped in an Array.\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeAllCallback|string} [options={}]\n   *   Decoding options, the callback, or the input encoding.\n   * @param {decodeAllCallback} [cb] Callback.\n   * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback\n   *   is specified.\n   * @throws {TypeError} No input specified.\n   * @static\n   */\n  static decodeAll(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', ...opts} = options\n\n    const c = new Decoder(opts)\n    const vals = []\n\n    c.on('data', val => vals.push(Decoder.nullcheck(val)))\n\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject)\n      c.on('end', () => resolve(vals))\n    })\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(undefined, v), er => cb(er, undefined))\n    }\n    utils.guessEncoding(input, encoding).pipe(c)\n    return p\n  }\n\n  /**\n   * Stop processing.\n   */\n  close() {\n    this.running = false\n    this.__fresh = true\n  }\n\n  /**\n   * Only called if extendedResults is true.\n   *\n   * @ignore\n   */\n  _onRead(data) {\n    this.valueBytes.write(data)\n  }\n\n  /**\n   * @returns {Generator<number, any, Buffer>} Yields a number of bytes,\n   *   returns anything, next returns a Buffer.\n   * @throws {Error} Maximum depth exceeded.\n   * @yields {number} Number of bytes to read.\n   * @ignore\n   */\n  *_parse() {\n    let parent = null\n    let depth = 0\n    let val = null\n\n    while (true) {\n      if ((this.max_depth >= 0) && (depth > this.max_depth)) {\n        throw new Error(`Maximum depth ${this.max_depth} exceeded`)\n      }\n\n      const [octet] = yield 1\n      if (!this.running) {\n        this.bs.unshift(Buffer.from([octet]))\n        throw new UnexpectedDataError(octet)\n      }\n      const mt = octet >> 5\n      const ai = octet & 0x1f\n      const parent_major = (parent == null) ? undefined : parent[MAJOR]\n      const parent_length = (parent == null) ? undefined : parent.length\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length)\n          ;[val] = yield 1\n          break\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT: {\n          const numbytes = 1 << (ai - 24)\n\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length)\n          const buf = yield numbytes\n          val = (mt === MT.SIMPLE_FLOAT) ?\n            buf :\n            utils.parseCBORint(ai, buf)\n          break\n        }\n        case 28:\n        case 29:\n        case 30:\n          this.running = false\n          throw new Error(`Additional info not implemented: ${ai}`)\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`)\n          }\n          val = -1\n          break\n        default:\n          val = ai\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // Val already decoded\n          break\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BI.NEG_MAX\n          } else {\n            val = (typeof val === 'bigint') ? BI.MINUS_ONE - val : -1 - val\n          }\n          break\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              if (mt === MT.UTF8_STRING) {\n                val = ''\n              } else {\n                val = this.preferWeb ? new Uint8Array(0) : Buffer.allocUnsafe(0)\n              }\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentBufferStream(parent, mt)\n              depth++\n              continue\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = yield val\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val)\n              } else if (this.preferWeb) {\n                val = new Uint8Array(val.buffer, val.byteOffset, val.length)\n              }\n          }\n          break\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = (mt === MT.MAP) ? {} : []\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentArray(parent, mt, -1)\n              depth++\n              continue\n            default:\n              this.emit('start', mt, val, parent_major, parent_length)\n              parent = parentArray(parent, mt, val * (mt - 3))\n              depth++\n              continue\n          }\n          break\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length)\n          parent = parentArray(parent, mt, 1)\n          parent.push(val)\n          depth++\n          continue\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if ((ai === NUMBYTES.ONE) && (val < 32)) {\n              throw new Error(\n                `Invalid two-byte encoding of simple value ${val}`\n              )\n            }\n            const hasParent = (parent != null)\n            val = Simple.decode(\n              val,\n              hasParent,\n              hasParent && (parent[COUNT] < 0)\n            )\n          } else {\n            val = utils.parseCBORfloat(val)\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai)\n      let again = false\n      while (parent != null) {\n        if (val === SYMS.BREAK) {\n          parent[COUNT] = 1\n        } else if (Array.isArray(parent)) {\n          parent.push(val)\n        } else {\n          // Assert: parent instanceof NoFilter\n          const pm = parent[MAJOR]\n\n          if ((pm != null) && (pm !== mt)) {\n            this.running = false\n            throw new Error('Invalid major type in indefinite encoding')\n          }\n          parent.write(val)\n        }\n\n        if ((--parent[COUNT]) !== 0) {\n          again = true\n          break\n        }\n        --depth\n        delete parent[COUNT]\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent\n              break\n            case MT.MAP: {\n              let allstrings = true\n\n              if ((parent.length % 2) !== 0) {\n                throw new Error(`Invalid map length: ${parent.length}`)\n              }\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if ((typeof parent[i] !== 'string') ||\n                    (parent[i] === '__proto__')) {\n                  allstrings = false\n                  break\n                }\n              }\n              if (allstrings) {\n                val = {}\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys &&\n                    Object.prototype.hasOwnProperty.call(val, parent[i])) {\n                    throw new Error('Duplicate keys in a map')\n                  }\n                  val[parent[i]] = parent[i + 1]\n                }\n              } else {\n                val = new Map()\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys && val.has(parent[i])) {\n                    throw new Error('Duplicate keys in a map')\n                  }\n                  val.set(parent[i], parent[i + 1])\n                }\n              }\n              break\n            }\n            case MT.TAG: {\n              const t = new Tagged(parent[0], parent[1])\n\n              val = t.convert(this.tags)\n              break\n            }\n          }\n        } else /* istanbul ignore else */ if (parent instanceof NoFilter) {\n          // Only parent types are Array and NoFilter for (Array/Map) and\n          // (bytes/string) respectively.\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice()\n              if (this.preferWeb) {\n                val = new Uint8Array(\n                  /** @type {Buffer} */ (val).buffer,\n                  /** @type {Buffer} */ (val).byteOffset,\n                  /** @type {Buffer} */ (val).length\n                )\n              }\n              break\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8')\n              break\n          }\n        }\n        this.emit('stop', parent[MAJOR])\n\n        const old = parent\n        parent = parent[SYMS.PARENT]\n        delete old[SYMS.PARENT]\n        delete old[MAJOR]\n      }\n      if (!again) {\n        if (this.extendedResults) {\n          const bytes = this.valueBytes.slice()\n          const ret = {\n            value: Decoder.nullcheck(val),\n            bytes,\n            length: bytes.length,\n          }\n\n          this.valueBytes = new NoFilter()\n          return ret\n        }\n        return val\n      }\n    }\n  }\n}\n\nDecoder.NOT_FOUND = NOT_FOUND\nmodule.exports = Decoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWiwwQkFBMEIsbUJBQU8sQ0FBQyxvR0FBK0I7QUFDakUsZUFBZSxtQkFBTyxDQUFDLHlEQUFVO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyx5REFBVTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsdURBQVM7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsNERBQVU7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLCtEQUFhO0FBQ3ZDLE9BQU8sd0JBQXdCO0FBQy9CLE9BQU8sUUFBUSxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQixjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFFBQVE7QUFDdEIsMkNBQTJDLCtCQUErQjtBQUMxRSxNQUFNLG1DQUFtQztBQUN6QztBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsU0FBUztBQUN2QixrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxP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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC1jbGllbnQvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvZGVjb2Rlci5qcz9jZGMwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBCaW5hcnlQYXJzZVN0cmVhbSA9IHJlcXVpcmUoJy4uL3ZlbmRvci9iaW5hcnktcGFyc2Utc3RyZWFtJylcbmNvbnN0IFRhZ2dlZCA9IHJlcXVpcmUoJy4vdGFnZ2VkJylcbmNvbnN0IFNpbXBsZSA9IHJlcXVpcmUoJy4vc2ltcGxlJylcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBOb0ZpbHRlciA9IHJlcXVpcmUoJ25vZmlsdGVyJylcbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7TVQsIE5VTUJZVEVTLCBTWU1TLCBCSX0gPSBjb25zdGFudHNcbmNvbnN0IHtCdWZmZXJ9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuY29uc3QgQ09VTlQgPSBTeW1ib2woJ2NvdW50JylcbmNvbnN0IE1BSk9SID0gU3ltYm9sKCdtYWpvciB0eXBlJylcbmNvbnN0IEVSUk9SID0gU3ltYm9sKCdlcnJvcicpXG5jb25zdCBOT1RfRk9VTkQgPSBTeW1ib2woJ25vdCBmb3VuZCcpXG5cbmZ1bmN0aW9uIHBhcmVudEFycmF5KHBhcmVudCwgdHlwLCBjb3VudCkge1xuICBjb25zdCBhID0gW11cblxuICBhW0NPVU5UXSA9IGNvdW50XG4gIGFbU1lNUy5QQVJFTlRdID0gcGFyZW50XG4gIGFbTUFKT1JdID0gdHlwXG4gIHJldHVybiBhXG59XG5cbmZ1bmN0aW9uIHBhcmVudEJ1ZmZlclN0cmVhbShwYXJlbnQsIHR5cCkge1xuICBjb25zdCBiID0gbmV3IE5vRmlsdGVyKClcblxuICBiW0NPVU5UXSA9IC0xXG4gIGJbU1lNUy5QQVJFTlRdID0gcGFyZW50XG4gIGJbTUFKT1JdID0gdHlwXG4gIHJldHVybiBiXG59XG5cbmNsYXNzIFVuZXhwZWN0ZWREYXRhRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGJ5dGUsIHZhbHVlKSB7XG4gICAgc3VwZXIoYFVuZXhwZWN0ZWQgZGF0YTogMHgke2J5dGUudG9TdHJpbmcoMTYpfWApXG4gICAgdGhpcy5uYW1lID0gJ1VuZXhwZWN0ZWREYXRhRXJyb3InXG4gICAgdGhpcy5ieXRlID0gYnl0ZVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB9XG59XG5cbi8qKlxuICogVGhpbmdzIHRoYXQgY2FuIGFjdCBhcyBpbnB1dHMsIGZyb20gd2hpY2ggYSBOb0ZpbHRlciBjYW4gYmUgY3JlYXRlZC5cbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fFVpbnQ4Q2xhbXBlZEFycmF5XG4gKiAgIHxEYXRhVmlld3xzdHJlYW0uUmVhZGFibGV9IEJ1ZmZlckxpa2VcbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiBFeHRlbmRlZFJlc3VsdHNcbiAqIEBwcm9wZXJ0eSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCB3YXMgZm91bmQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgdGhlIG9yaWdpbmFsIGlucHV0IHRoYXRcbiAqICAgd2VyZSByZWFkLlxuICogQHByb3BlcnR5IHtCdWZmZXJ9IGJ5dGVzIFRoZSBieXRlcyBvZiB0aGUgb3JpZ2luYWwgaW5wdXQgdGhhdCB3ZXJlIHVzZWRcbiAqICAgdG8gcHJvZHVjZSB0aGUgdmFsdWUuXG4gKiBAcHJvcGVydHkge0J1ZmZlcn0gW3VudXNlZF0gVGhlIGJ5dGVzIHRoYXQgd2VyZSBsZWZ0IG92ZXIgZnJvbSB0aGUgb3JpZ2luYWxcbiAqICAgaW5wdXQuICBUaGlzIHByb3BlcnR5IG9ubHkgZXhpc3RzIGlmIHtAbGlua2NvZGUgRGVjb2Rlci5kZWNvZGVGaXJzdH0gb3JcbiAqICAge0BsaW5rY29kZSBEZWNvZGVyLmRlY29kZUZpcnN0U3luY30gd2FzIGNhbGxlZC5cbiAqL1xuLyoqXG4gKiBAdHlwZWRlZiBEZWNvZGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhfZGVwdGg9LTFdIFRoZSBtYXhpbXVtIGRlcHRoIHRvIHBhcnNlLlxuICogICBVc2UgLTEgZm9yIFwidW50aWwgeW91IHJ1biBvdXQgb2YgbWVtb3J5XCIuICBTZXQgdGhpcyB0byBhIGZpbml0ZVxuICogICBwb3NpdGl2ZSBudW1iZXIgZm9yIHVuLXRydXN0ZWQgaW5wdXRzLiAgTW9zdCBzdGFuZGFyZCBpbnB1dHMgd29uJ3QgbmVzdFxuICogICBtb3JlIHRoYW4gMTAwIG9yIHNvIGxldmVsczsgSSd2ZSB0ZXN0ZWQgaW50byB0aGUgbWlsbGlvbnMgYmVmb3JlXG4gKiAgIHJ1bm5pbmcgb3V0IG9mIG1lbW9yeS5cbiAqIEBwcm9wZXJ0eSB7VGFnZ2VkLlRhZ01hcH0gW3RhZ3NdIE1hcHBpbmcgZnJvbSB0YWcgbnVtYmVyIHRvIGZ1bmN0aW9uKHYpLFxuICogICB3aGVyZSB2IGlzIHRoZSBkZWNvZGVkIHZhbHVlIHRoYXQgY29tZXMgYWZ0ZXIgdGhlIHRhZywgYW5kIHdoZXJlIHRoZVxuICogICBmdW5jdGlvbiByZXR1cm5zIHRoZSBjb3JyZWN0bHktY3JlYXRlZCB2YWx1ZSBmb3IgdGhhdCB0YWcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwcmVmZXJXZWI9ZmFsc2VdIElmIHRydWUsIHByZWZlciBVaW50OEFycmF5cyB0b1xuICogICBiZSBnZW5lcmF0ZWQgaW5zdGVhZCBvZiBub2RlIEJ1ZmZlcnMuICBUaGlzIG1pZ2h0IHR1cm4gb24gc29tZSBtb3JlXG4gKiAgIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZSwgc28gZm9yd2FyZC1jb21wYXRpYmlsaXR5IGlzIG5vdCBndWFyYW50ZWVkIHlldC5cbiAqIEBwcm9wZXJ0eSB7QnVmZmVyRW5jb2Rpbmd9IFtlbmNvZGluZz0naGV4J10gVGhlIGVuY29kaW5nIG9mIHRoZSBpbnB1dC5cbiAqICAgSWdub3JlZCBpZiBpbnB1dCBpcyBhIEJ1ZmZlci5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVpcmVkPWZhbHNlXSBTaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIHdoZW4gbm9cbiAqICAgZGF0YSBpcyBpbiB0aGUgaW5wdXQ/XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtleHRlbmRlZFJlc3VsdHM9ZmFsc2VdIElmIHRydWUsIGVtaXQgZXh0ZW5kZWRcbiAqICAgcmVzdWx0cywgd2hpY2ggd2lsbCBiZSBhbiBvYmplY3Qgd2l0aCBzaGFwZSB7QGxpbmsgRXh0ZW5kZWRSZXN1bHRzfS5cbiAqICAgVGhlIHZhbHVlIHdpbGwgYWxyZWFkeSBoYXZlIGJlZW4gbnVsbC1jaGVja2VkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcHJldmVudER1cGxpY2F0ZUtleXM9ZmFsc2VdIElmIHRydWUsIGVycm9yIGlzXG4gKiAgIHRocm93biBpZiBhIG1hcCBoYXMgZHVwbGljYXRlIGtleXMuXG4gKi9cbi8qKlxuICogQGNhbGxiYWNrIGRlY29kZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBbZXJyb3JdIElmIG9uZSB3YXMgZ2VuZXJhdGVkLlxuICogQHBhcmFtIHthbnl9IFt2YWx1ZV0gVGhlIGRlY29kZWQgdmFsdWUuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJPcHRpb25zfGRlY29kZUNhbGxiYWNrfHN0cmluZ30gb3B0cyBPcHRpb25zLFxuICogICB0aGUgY2FsbGJhY2ssIG9yIGlucHV0IGluY29kaW5nLlxuICogQHBhcmFtIHtkZWNvZGVDYWxsYmFja30gW2NiXSBDYWxsZWQgb24gY29tcGxldGlvbi5cbiAqIEByZXR1cm5zIHt7b3B0aW9uczogRGVjb2Rlck9wdGlvbnMsIGNiOiBkZWNvZGVDYWxsYmFja319IE5vcm1hbGl6ZWQuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IE9uIHVua25vd24gb3B0aW9uIHR5cGUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKG9wdHMsIGNiKSB7XG4gIHN3aXRjaCAodHlwZW9mIG9wdHMpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4ge29wdGlvbnM6IHt9LCBjYjogLyoqIEB0eXBlIHtkZWNvZGVDYWxsYmFja30gKi8gKG9wdHMpfVxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4ge29wdGlvbnM6IHtlbmNvZGluZzogLyoqIEB0eXBlIHtCdWZmZXJFbmNvZGluZ30gKi8gKG9wdHMpfSwgY2J9XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiB7b3B0aW9uczogb3B0cyB8fCB7fSwgY2J9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gb3B0aW9uIHR5cGUnKVxuICB9XG59XG5cbi8qKlxuICogRGVjb2RlIGEgc3RyZWFtIG9mIENCT1IgYnl0ZXMgYnkgdHJhbnNmb3JtaW5nIHRoZW0gaW50byBlcXVpdmFsZW50XG4gKiBKYXZhU2NyaXB0IGRhdGEuICBCZWNhdXNlIG9mIHRoZSBsaW1pdGF0aW9ucyBvZiBOb2RlIG9iamVjdCBzdHJlYW1zLFxuICogc3BlY2lhbCBzeW1ib2xzIGFyZSBlbWl0dGVkIGluc3RlYWQgb2YgTlVMTCBvciBVTkRFRklORUQuICBGaXggdGhvc2VcbiAqIHVwIGJ5IGNhbGxpbmcge0BsaW5rIERlY29kZXIubnVsbGNoZWNrfS5cbiAqXG4gKiBAZXh0ZW5kcyBCaW5hcnlQYXJzZVN0cmVhbVxuICovXG5jbGFzcyBEZWNvZGVyIGV4dGVuZHMgQmluYXJ5UGFyc2VTdHJlYW0ge1xuICAvKipcbiAgICogQ3JlYXRlIGEgcGFyc2luZyBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7RGVjb2Rlck9wdGlvbnN9IFtvcHRpb25zPXt9XSBPcHRpb25zLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFncyA9IHt9LFxuICAgICAgbWF4X2RlcHRoID0gLTEsXG4gICAgICBwcmVmZXJXZWIgPSBmYWxzZSxcbiAgICAgIHJlcXVpcmVkID0gZmFsc2UsXG4gICAgICBlbmNvZGluZyA9ICdoZXgnLFxuICAgICAgZXh0ZW5kZWRSZXN1bHRzID0gZmFsc2UsXG4gICAgICBwcmV2ZW50RHVwbGljYXRlS2V5cyA9IGZhbHNlLFxuICAgICAgLi4uc3VwZXJPcHRzXG4gICAgfSA9IG9wdGlvbnNcblxuICAgIHN1cGVyKHtkZWZhdWx0RW5jb2Rpbmc6IGVuY29kaW5nLCAuLi5zdXBlck9wdHN9KVxuXG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZVxuICAgIHRoaXMubWF4X2RlcHRoID0gbWF4X2RlcHRoXG4gICAgdGhpcy50YWdzID0gdGFnc1xuICAgIHRoaXMucHJlZmVyV2ViID0gcHJlZmVyV2ViXG4gICAgdGhpcy5leHRlbmRlZFJlc3VsdHMgPSBleHRlbmRlZFJlc3VsdHNcbiAgICB0aGlzLnJlcXVpcmVkID0gcmVxdWlyZWRcbiAgICB0aGlzLnByZXZlbnREdXBsaWNhdGVLZXlzID0gcHJldmVudER1cGxpY2F0ZUtleXNcblxuICAgIGlmIChleHRlbmRlZFJlc3VsdHMpIHtcbiAgICAgIHRoaXMuYnMub24oJ3JlYWQnLCB0aGlzLl9vblJlYWQuYmluZCh0aGlzKSlcbiAgICAgIHRoaXMudmFsdWVCeXRlcyA9IC8qKiBAdHlwZSB7Tm9GaWx0ZXJ9ICovIChuZXcgTm9GaWx0ZXIoKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGdpdmVuIHZhbHVlIGZvciBhIHN5bWJvbCBlbmNvZGluZyBhIE5VTEwgb3IgVU5ERUZJTkVEIHZhbHVlIGluXG4gICAqIHRoZSBDQk9SIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IHZhbCBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjb3JyZWN0ZWQgdmFsdWUuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBOb3RoaW5nIHdhcyBmb3VuZC5cbiAgICogQHN0YXRpY1xuICAgKiBAZXhhbXBsZVxuICAgKiBteURlY29kZXIub24oJ2RhdGEnLCB2YWwgPT4ge1xuICAgKiAgIHZhbCA9IERlY29kZXIubnVsbGNoZWNrKHZhbClcbiAgICogICAvLyAuLi5cbiAgICogfSlcbiAgICovXG4gIHN0YXRpYyBudWxsY2hlY2sodmFsKSB7XG4gICAgc3dpdGNoICh2YWwpIHtcbiAgICAgIGNhc2UgU1lNUy5OVUxMOlxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgY2FzZSBTWU1TLlVOREVGSU5FRDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgLy8gTGVhdmluZyB0aGlzIGluIGZvciBub3cgYXMgYmVsdC1hbmQtc3VzcGVuZGVycywgYnV0IEknbSBwcmV0dHkgc3VyZVxuICAgICAgLy8gaXQgY2FuJ3QgaGFwcGVuLlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGNhc2UgTk9UX0ZPVU5EOlxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIG5vdCBmb3VuZCcpXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdmFsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSB0aGUgZmlyc3QgQ0JPUiBpdGVtIGluIHRoZSBpbnB1dCwgc3luY2hyb25vdXNseS4gIFRoaXMgd2lsbCB0aHJvd1xuICAgKiBhbiBleGNlcHRpb24gaWYgdGhlIGlucHV0IGlzIG5vdCB2YWxpZCBDQk9SLCBvciBpZiB0aGVyZSBhcmUgbW9yZSBieXRlc1xuICAgKiBsZWZ0IG92ZXIgYXQgdGhlIGVuZCAoaWYgb3B0aW9ucy5leHRlbmRlZFJlc3VsdHMgaXMgbm90IHRydWUpLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlckxpa2V9IGlucHV0IElmIGEgUmVhZGFibGUgc3RyZWFtLCBtdXN0IGhhdmVcbiAgICogICByZWNlaXZlZCB0aGUgYHJlYWRhYmxlYCBldmVudCBhbHJlYWR5LCBvciB5b3Ugd2lsbCBnZXQgYW4gZXJyb3JcbiAgICogICBjbGFpbWluZyBcIkluc3VmZmljaWVudCBkYXRhXCIuXG4gICAqIEBwYXJhbSB7RGVjb2Rlck9wdGlvbnN8c3RyaW5nfSBbb3B0aW9ucz17fV0gT3B0aW9ucyBvciBlbmNvZGluZyBmb3IgaW5wdXQuXG4gICAqIEByZXR1cm5zIHtFeHRlbmRlZFJlc3VsdHN8YW55fSBUaGUgZGVjb2RlZCB2YWx1ZS5cbiAgICogQHRocm93cyB7VW5leHBlY3RlZERhdGFFcnJvcn0gRGF0YSBpcyBsZWZ0IG92ZXIgYWZ0ZXIgZGVjb2RpbmcuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJbnN1ZmZpY2llbnQgZGF0YS5cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIGRlY29kZUZpcnN0U3luYyhpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IHJlcXVpcmVkJylcbiAgICB9XG4gICAgKHtvcHRpb25zfSA9IG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucykpXG4gICAgY29uc3Qge2VuY29kaW5nID0gJ2hleCcsIC4uLm9wdHN9ID0gb3B0aW9uc1xuICAgIGNvbnN0IGMgPSBuZXcgRGVjb2RlcihvcHRzKVxuICAgIGNvbnN0IHMgPSB1dGlscy5ndWVzc0VuY29kaW5nKGlucHV0LCBlbmNvZGluZylcblxuICAgIC8vIEZvci9vZiBkb2Vzbid0IHdvcmsgd2hlbiB5b3UgbmVlZCB0byBjYWxsIG5leHQoKSB3aXRoIGEgdmFsdWVcbiAgICAvLyBnZW5lcmF0b3IgY3JlYXRlZCBieSBwYXJzZXIgd2lsbCBiZSBcImRvbmVcIiBhZnRlciBlYWNoIENCT1IgZW50aXR5XG4gICAgLy8gcGFyc2VyIHdpbGwgeWllbGQgbnVtYmVycyBvZiBieXRlcyB0aGF0IGl0IHdhbnRzXG4gICAgY29uc3QgcGFyc2VyID0gYy5fcGFyc2UoKVxuICAgIGxldCBzdGF0ZSA9IHBhcnNlci5uZXh0KClcblxuICAgIHdoaWxlICghc3RhdGUuZG9uZSkge1xuICAgICAgY29uc3QgYiA9IHMucmVhZChzdGF0ZS52YWx1ZSlcblxuICAgICAgaWYgKChiID09IG51bGwpIHx8IChiLmxlbmd0aCAhPT0gc3RhdGUudmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdWZmaWNpZW50IGRhdGEnKVxuICAgICAgfVxuICAgICAgaWYgKGMuZXh0ZW5kZWRSZXN1bHRzKSB7XG4gICAgICAgIGMudmFsdWVCeXRlcy53cml0ZShiKVxuICAgICAgfVxuICAgICAgc3RhdGUgPSBwYXJzZXIubmV4dChiKVxuICAgIH1cblxuICAgIGxldCB2YWwgPSBudWxsXG4gICAgaWYgKGMuZXh0ZW5kZWRSZXN1bHRzKSB7XG4gICAgICB2YWwgPSBzdGF0ZS52YWx1ZVxuICAgICAgdmFsLnVudXNlZCA9IHMucmVhZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IERlY29kZXIubnVsbGNoZWNrKHN0YXRlLnZhbHVlKVxuICAgICAgaWYgKHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0Qnl0ZSA9IHMucmVhZCgxKVxuXG4gICAgICAgIHMudW5zaGlmdChuZXh0Qnl0ZSlcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWREYXRhRXJyb3IobmV4dEJ5dGVbMF0sIHZhbClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbGwgb2YgdGhlIENCT1IgaXRlbXMgaW4gdGhlIGlucHV0IGludG8gYW4gYXJyYXkuICBUaGlzIHdpbGwgdGhyb3dcbiAgICogYW4gZXhjZXB0aW9uIGlmIHRoZSBpbnB1dCBpcyBub3QgdmFsaWQgQ0JPUjsgYSB6ZXJvLWxlbmd0aCBpbnB1dCB3aWxsXG4gICAqIHJldHVybiBhbiBlbXB0eSBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJMaWtlfSBpbnB1dCBXaGF0IHRvIHBhcnNlP1xuICAgKiBAcGFyYW0ge0RlY29kZXJPcHRpb25zfHN0cmluZ30gW29wdGlvbnM9e31dIE9wdGlvbnMgb3IgZW5jb2RpbmdcbiAgICogICBmb3IgaW5wdXQuXG4gICAqIEByZXR1cm5zIHtBcnJheTxFeHRlbmRlZFJlc3VsdHM+fEFycmF5PGFueT59IEFycmF5IG9mIGFsbCBmb3VuZCBpdGVtcy5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBObyBpbnB1dCBwcm92aWRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IEluc3VmZmljaWVudCBkYXRhIHByb3ZpZGVkLlxuICAgKiBAc3RhdGljXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQWxsU3luYyhpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IHJlcXVpcmVkJylcbiAgICB9XG4gICAgKHtvcHRpb25zfSA9IG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucykpXG4gICAgY29uc3Qge2VuY29kaW5nID0gJ2hleCcsIC4uLm9wdHN9ID0gb3B0aW9uc1xuICAgIGNvbnN0IGMgPSBuZXcgRGVjb2RlcihvcHRzKVxuICAgIGNvbnN0IHMgPSB1dGlscy5ndWVzc0VuY29kaW5nKGlucHV0LCBlbmNvZGluZylcbiAgICBjb25zdCByZXMgPSBbXVxuXG4gICAgd2hpbGUgKHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcGFyc2VyID0gYy5fcGFyc2UoKVxuICAgICAgbGV0IHN0YXRlID0gcGFyc2VyLm5leHQoKVxuXG4gICAgICB3aGlsZSAoIXN0YXRlLmRvbmUpIHtcbiAgICAgICAgY29uc3QgYiA9IHMucmVhZChzdGF0ZS52YWx1ZSlcblxuICAgICAgICBpZiAoKGIgPT0gbnVsbCkgfHwgKGIubGVuZ3RoICE9PSBzdGF0ZS52YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3VmZmljaWVudCBkYXRhJylcbiAgICAgICAgfVxuICAgICAgICBpZiAoYy5leHRlbmRlZFJlc3VsdHMpIHtcbiAgICAgICAgICBjLnZhbHVlQnl0ZXMud3JpdGUoYilcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IHBhcnNlci5uZXh0KGIpXG4gICAgICB9XG4gICAgICByZXMucHVzaChEZWNvZGVyLm51bGxjaGVjayhzdGF0ZS52YWx1ZSkpXG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgdGhlIGZpcnN0IENCT1IgaXRlbSBpbiB0aGUgaW5wdXQuICBUaGlzIHdpbGwgZXJyb3IgaWYgdGhlcmUgYXJlXG4gICAqIG1vcmUgYnl0ZXMgbGVmdCBvdmVyIGF0IHRoZSBlbmQgKGlmIG9wdGlvbnMuZXh0ZW5kZWRSZXN1bHRzIGlzIG5vdCB0cnVlKSxcbiAgICogYW5kIG9wdGlvbmFsbHkgaWYgdGhlcmUgd2VyZSBubyB2YWxpZCBDQk9SIGJ5dGVzIGluIHRoZSBpbnB1dC4gIEVtaXRzIHRoZVxuICAgKiB7RGVjb2Rlci5OT1RfRk9VTkR9IFN5bWJvbCBpbiB0aGUgY2FsbGJhY2sgaWYgbm8gZGF0YSB3YXMgZm91bmQgYW5kIHRoZVxuICAgKiBgcmVxdWlyZWRgIG9wdGlvbiBpcyBmYWxzZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJMaWtlfSBpbnB1dCBXaGF0IHRvIHBhcnNlP1xuICAgKiBAcGFyYW0ge0RlY29kZXJPcHRpb25zfGRlY29kZUNhbGxiYWNrfHN0cmluZ30gW29wdGlvbnM9e31dIE9wdGlvbnMsIHRoZVxuICAgKiAgIGNhbGxiYWNrLCBvciBpbnB1dCBlbmNvZGluZy5cbiAgICogQHBhcmFtIHtkZWNvZGVDYWxsYmFja30gW2NiXSBDYWxsYmFjay5cbiAgICogQHJldHVybnMge1Byb21pc2U8RXh0ZW5kZWRSZXN1bHRzfGFueT59IFJldHVybmVkIGV2ZW4gaWYgY2FsbGJhY2sgaXNcbiAgICogICBzcGVjaWZpZWQuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gTm8gaW5wdXQgcHJvdmlkZWQuXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIHN0YXRpYyBkZWNvZGVGaXJzdChpbnB1dCwgb3B0aW9ucyA9IHt9LCBjYiA9IG51bGwpIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXQgcmVxdWlyZWQnKVxuICAgIH1cbiAgICAoe29wdGlvbnMsIGNifSA9IG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucywgY2IpKVxuICAgIGNvbnN0IHtlbmNvZGluZyA9ICdoZXgnLCByZXF1aXJlZCA9IGZhbHNlLCAuLi5vcHRzfSA9IG9wdGlvbnNcblxuICAgIGNvbnN0IGMgPSBuZXcgRGVjb2RlcihvcHRzKVxuICAgIGxldCB2ID0gLyoqIEB0eXBlIHthbnl9ICovIChOT1RfRk9VTkQpXG4gICAgY29uc3QgcyA9IHV0aWxzLmd1ZXNzRW5jb2RpbmcoaW5wdXQsIGVuY29kaW5nKVxuICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjLm9uKCdkYXRhJywgdmFsID0+IHtcbiAgICAgICAgdiA9IERlY29kZXIubnVsbGNoZWNrKHZhbClcbiAgICAgICAgYy5jbG9zZSgpXG4gICAgICB9KVxuICAgICAgYy5vbmNlKCdlcnJvcicsIGVyID0+IHtcbiAgICAgICAgaWYgKGMuZXh0ZW5kZWRSZXN1bHRzICYmIChlciBpbnN0YW5jZW9mIFVuZXhwZWN0ZWREYXRhRXJyb3IpKSB7XG4gICAgICAgICAgdi51bnVzZWQgPSBjLmJzLnNsaWNlKClcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh2KVxuICAgICAgICB9XG4gICAgICAgIGlmICh2ICE9PSBOT1RfRk9VTkQpIHtcbiAgICAgICAgICAvLyBUeXBlc2NyaXB0IHdvcmstYXJvdW5kXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgICAgIGVyWyd2YWx1ZSddID0gdlxuICAgICAgICB9XG4gICAgICAgIHYgPSBFUlJPUlxuICAgICAgICBjLmNsb3NlKClcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcilcbiAgICAgIH0pXG4gICAgICBjLm9uY2UoJ2VuZCcsICgpID0+IHtcbiAgICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgICAgY2FzZSBOT1RfRk9VTkQ6XG4gICAgICAgICAgICBpZiAocmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIENCT1IgZm91bmQnKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHYpXG4gICAgICAgICAgLy8gUHJldHR5IHN1cmUgdGhpcyBjYW4ndCBoYXBwZW4sIGJ1dCBub3QgKmNlcnRhaW4qLlxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgY2FzZSBFUlJPUjpcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHYpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHAudGhlbih2YWwgPT4gY2IobnVsbCwgdmFsKSwgY2IpXG4gICAgfVxuICAgIHMucGlwZShjKVxuICAgIHJldHVybiBwXG4gIH1cblxuICAvKipcbiAgICogQGNhbGxiYWNrIGRlY29kZUFsbENhbGxiYWNrXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIElmIG9uZSB3YXMgZ2VuZXJhdGVkLlxuICAgKiBAcGFyYW0ge0FycmF5PEV4dGVuZGVkUmVzdWx0cz58QXJyYXk8YW55Pn0gdmFsdWUgQWxsIG9mIHRoZSBkZWNvZGVkXG4gICAqICAgdmFsdWVzLCB3cmFwcGVkIGluIGFuIEFycmF5LlxuICAgKi9cblxuICAvKipcbiAgICogRGVjb2RlIGFsbCBvZiB0aGUgQ0JPUiBpdGVtcyBpbiB0aGUgaW5wdXQuICBUaGlzIHdpbGwgZXJyb3IgaWYgdGhlcmUgYXJlXG4gICAqIG1vcmUgYnl0ZXMgbGVmdCBvdmVyIGF0IHRoZSBlbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyTGlrZX0gaW5wdXQgV2hhdCB0byBwYXJzZT9cbiAgICogQHBhcmFtIHtEZWNvZGVyT3B0aW9uc3xkZWNvZGVBbGxDYWxsYmFja3xzdHJpbmd9IFtvcHRpb25zPXt9XVxuICAgKiAgIERlY29kaW5nIG9wdGlvbnMsIHRoZSBjYWxsYmFjaywgb3IgdGhlIGlucHV0IGVuY29kaW5nLlxuICAgKiBAcGFyYW0ge2RlY29kZUFsbENhbGxiYWNrfSBbY2JdIENhbGxiYWNrLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxFeHRlbmRlZFJlc3VsdHM+fEFycmF5PGFueT4+fSBFdmVuIGlmIGNhbGxiYWNrXG4gICAqICAgaXMgc3BlY2lmaWVkLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IE5vIGlucHV0IHNwZWNpZmllZC5cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbChpbnB1dCwgb3B0aW9ucyA9IHt9LCBjYiA9IG51bGwpIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXQgcmVxdWlyZWQnKVxuICAgIH1cbiAgICAoe29wdGlvbnMsIGNifSA9IG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucywgY2IpKVxuICAgIGNvbnN0IHtlbmNvZGluZyA9ICdoZXgnLCAuLi5vcHRzfSA9IG9wdGlvbnNcblxuICAgIGNvbnN0IGMgPSBuZXcgRGVjb2RlcihvcHRzKVxuICAgIGNvbnN0IHZhbHMgPSBbXVxuXG4gICAgYy5vbignZGF0YScsIHZhbCA9PiB2YWxzLnB1c2goRGVjb2Rlci5udWxsY2hlY2sodmFsKSkpXG5cbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgYy5vbignZXJyb3InLCByZWplY3QpXG4gICAgICBjLm9uKCdlbmQnLCAoKSA9PiByZXNvbHZlKHZhbHMpKVxuICAgIH0pXG5cbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwLnRoZW4odiA9PiBjYih1bmRlZmluZWQsIHYpLCBlciA9PiBjYihlciwgdW5kZWZpbmVkKSlcbiAgICB9XG4gICAgdXRpbHMuZ3Vlc3NFbmNvZGluZyhpbnB1dCwgZW5jb2RpbmcpLnBpcGUoYylcbiAgICByZXR1cm4gcFxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgcHJvY2Vzc2luZy5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlXG4gICAgdGhpcy5fX2ZyZXNoID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgY2FsbGVkIGlmIGV4dGVuZGVkUmVzdWx0cyBpcyB0cnVlLlxuICAgKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfb25SZWFkKGRhdGEpIHtcbiAgICB0aGlzLnZhbHVlQnl0ZXMud3JpdGUoZGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7R2VuZXJhdG9yPG51bWJlciwgYW55LCBCdWZmZXI+fSBZaWVsZHMgYSBudW1iZXIgb2YgYnl0ZXMsXG4gICAqICAgcmV0dXJucyBhbnl0aGluZywgbmV4dCByZXR1cm5zIGEgQnVmZmVyLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gTWF4aW11bSBkZXB0aCBleGNlZWRlZC5cbiAgICogQHlpZWxkcyB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgKl9wYXJzZSgpIHtcbiAgICBsZXQgcGFyZW50ID0gbnVsbFxuICAgIGxldCBkZXB0aCA9IDBcbiAgICBsZXQgdmFsID0gbnVsbFxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICgodGhpcy5tYXhfZGVwdGggPj0gMCkgJiYgKGRlcHRoID4gdGhpcy5tYXhfZGVwdGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWF4aW11bSBkZXB0aCAke3RoaXMubWF4X2RlcHRofSBleGNlZWRlZGApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFtvY3RldF0gPSB5aWVsZCAxXG4gICAgICBpZiAoIXRoaXMucnVubmluZykge1xuICAgICAgICB0aGlzLmJzLnVuc2hpZnQoQnVmZmVyLmZyb20oW29jdGV0XSkpXG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkRGF0YUVycm9yKG9jdGV0KVxuICAgICAgfVxuICAgICAgY29uc3QgbXQgPSBvY3RldCA+PiA1XG4gICAgICBjb25zdCBhaSA9IG9jdGV0ICYgMHgxZlxuICAgICAgY29uc3QgcGFyZW50X21ham9yID0gKHBhcmVudCA9PSBudWxsKSA/IHVuZGVmaW5lZCA6IHBhcmVudFtNQUpPUl1cbiAgICAgIGNvbnN0IHBhcmVudF9sZW5ndGggPSAocGFyZW50ID09IG51bGwpID8gdW5kZWZpbmVkIDogcGFyZW50Lmxlbmd0aFxuXG4gICAgICBzd2l0Y2ggKGFpKSB7XG4gICAgICAgIGNhc2UgTlVNQllURVMuT05FOlxuICAgICAgICAgIHRoaXMuZW1pdCgnbW9yZS1ieXRlcycsIG10LCAxLCBwYXJlbnRfbWFqb3IsIHBhcmVudF9sZW5ndGgpXG4gICAgICAgICAgO1t2YWxdID0geWllbGQgMVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgTlVNQllURVMuVFdPOlxuICAgICAgICBjYXNlIE5VTUJZVEVTLkZPVVI6XG4gICAgICAgIGNhc2UgTlVNQllURVMuRUlHSFQ6IHtcbiAgICAgICAgICBjb25zdCBudW1ieXRlcyA9IDEgPDwgKGFpIC0gMjQpXG5cbiAgICAgICAgICB0aGlzLmVtaXQoJ21vcmUtYnl0ZXMnLCBtdCwgbnVtYnl0ZXMsIHBhcmVudF9tYWpvciwgcGFyZW50X2xlbmd0aClcbiAgICAgICAgICBjb25zdCBidWYgPSB5aWVsZCBudW1ieXRlc1xuICAgICAgICAgIHZhbCA9IChtdCA9PT0gTVQuU0lNUExFX0ZMT0FUKSA/XG4gICAgICAgICAgICBidWYgOlxuICAgICAgICAgICAgdXRpbHMucGFyc2VDQk9SaW50KGFpLCBidWYpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI4OlxuICAgICAgICBjYXNlIDI5OlxuICAgICAgICBjYXNlIDMwOlxuICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZGRpdGlvbmFsIGluZm8gbm90IGltcGxlbWVudGVkOiAke2FpfWApXG4gICAgICAgIGNhc2UgTlVNQllURVMuSU5ERUZJTklURTpcbiAgICAgICAgICBzd2l0Y2ggKG10KSB7XG4gICAgICAgICAgICBjYXNlIE1ULlBPU19JTlQ6XG4gICAgICAgICAgICBjYXNlIE1ULk5FR19JTlQ6XG4gICAgICAgICAgICBjYXNlIE1ULlRBRzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGluZGVmaW5pdGUgZW5jb2RpbmcgZm9yIE1UICR7bXR9YClcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsID0gLTFcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhbCA9IGFpXG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG10KSB7XG4gICAgICAgIGNhc2UgTVQuUE9TX0lOVDpcbiAgICAgICAgICAvLyBWYWwgYWxyZWFkeSBkZWNvZGVkXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBNVC5ORUdfSU5UOlxuICAgICAgICAgIGlmICh2YWwgPT09IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICB2YWwgPSBCSS5ORUdfTUFYXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbCA9ICh0eXBlb2YgdmFsID09PSAnYmlnaW50JykgPyBCSS5NSU5VU19PTkUgLSB2YWwgOiAtMSAtIHZhbFxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIE1ULkJZVEVfU1RSSU5HOlxuICAgICAgICBjYXNlIE1ULlVURjhfU1RSSU5HOlxuICAgICAgICAgIHN3aXRjaCAodmFsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQtc3RyaW5nJywgbXQsIHZhbCwgcGFyZW50X21ham9yLCBwYXJlbnRfbGVuZ3RoKVxuICAgICAgICAgICAgICBpZiAobXQgPT09IE1ULlVURjhfU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gJydcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLnByZWZlcldlYiA/IG5ldyBVaW50OEFycmF5KDApIDogQnVmZmVyLmFsbG9jVW5zYWZlKDApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnLCBtdCwgU1lNUy5TVFJFQU0sIHBhcmVudF9tYWpvciwgcGFyZW50X2xlbmd0aClcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50QnVmZmVyU3RyZWFtKHBhcmVudCwgbXQpXG4gICAgICAgICAgICAgIGRlcHRoKytcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQtc3RyaW5nJywgbXQsIHZhbCwgcGFyZW50X21ham9yLCBwYXJlbnRfbGVuZ3RoKVxuICAgICAgICAgICAgICB2YWwgPSB5aWVsZCB2YWxcbiAgICAgICAgICAgICAgaWYgKG10ID09PSBNVC5VVEY4X1NUUklORykge1xuICAgICAgICAgICAgICAgIHZhbCA9IHV0aWxzLnV0ZjgodmFsKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJlZmVyV2ViKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gbmV3IFVpbnQ4QXJyYXkodmFsLmJ1ZmZlciwgdmFsLmJ5dGVPZmZzZXQsIHZhbC5sZW5ndGgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBNVC5BUlJBWTpcbiAgICAgICAgY2FzZSBNVC5NQVA6XG4gICAgICAgICAgc3dpdGNoICh2YWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgdmFsID0gKG10ID09PSBNVC5NQVApID8ge30gOiBbXVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIG10LCBTWU1TLlNUUkVBTSwgcGFyZW50X21ham9yLCBwYXJlbnRfbGVuZ3RoKVxuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRBcnJheShwYXJlbnQsIG10LCAtMSlcbiAgICAgICAgICAgICAgZGVwdGgrK1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIG10LCB2YWwsIHBhcmVudF9tYWpvciwgcGFyZW50X2xlbmd0aClcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50QXJyYXkocGFyZW50LCBtdCwgdmFsICogKG10IC0gMykpXG4gICAgICAgICAgICAgIGRlcHRoKytcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBNVC5UQUc6XG4gICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcsIG10LCB2YWwsIHBhcmVudF9tYWpvciwgcGFyZW50X2xlbmd0aClcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRBcnJheShwYXJlbnQsIG10LCAxKVxuICAgICAgICAgIHBhcmVudC5wdXNoKHZhbClcbiAgICAgICAgICBkZXB0aCsrXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgY2FzZSBNVC5TSU1QTEVfRkxPQVQ6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoKGFpID09PSBOVU1CWVRFUy5PTkUpICYmICh2YWwgPCAzMikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHR3by1ieXRlIGVuY29kaW5nIG9mIHNpbXBsZSB2YWx1ZSAke3ZhbH1gXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhc1BhcmVudCA9IChwYXJlbnQgIT0gbnVsbClcbiAgICAgICAgICAgIHZhbCA9IFNpbXBsZS5kZWNvZGUoXG4gICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgaGFzUGFyZW50LFxuICAgICAgICAgICAgICBoYXNQYXJlbnQgJiYgKHBhcmVudFtDT1VOVF0gPCAwKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSB1dGlscy5wYXJzZUNCT1JmbG9hdCh2YWwpXG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCd2YWx1ZScsIHZhbCwgcGFyZW50X21ham9yLCBwYXJlbnRfbGVuZ3RoLCBhaSlcbiAgICAgIGxldCBhZ2FpbiA9IGZhbHNlXG4gICAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gU1lNUy5CUkVBSykge1xuICAgICAgICAgIHBhcmVudFtDT1VOVF0gPSAxXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICAgICAgcGFyZW50LnB1c2godmFsKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFzc2VydDogcGFyZW50IGluc3RhbmNlb2YgTm9GaWx0ZXJcbiAgICAgICAgICBjb25zdCBwbSA9IHBhcmVudFtNQUpPUl1cblxuICAgICAgICAgIGlmICgocG0gIT0gbnVsbCkgJiYgKHBtICE9PSBtdCkpIHtcbiAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFqb3IgdHlwZSBpbiBpbmRlZmluaXRlIGVuY29kaW5nJylcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50LndyaXRlKHZhbClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoLS1wYXJlbnRbQ09VTlRdKSAhPT0gMCkge1xuICAgICAgICAgIGFnYWluID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgLS1kZXB0aFxuICAgICAgICBkZWxldGUgcGFyZW50W0NPVU5UXVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgICAgICBzd2l0Y2ggKHBhcmVudFtNQUpPUl0pIHtcbiAgICAgICAgICAgIGNhc2UgTVQuQVJSQVk6XG4gICAgICAgICAgICAgIHZhbCA9IHBhcmVudFxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBNVC5NQVA6IHtcbiAgICAgICAgICAgICAgbGV0IGFsbHN0cmluZ3MgPSB0cnVlXG5cbiAgICAgICAgICAgICAgaWYgKChwYXJlbnQubGVuZ3RoICUgMikgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWFwIGxlbmd0aDogJHtwYXJlbnQubGVuZ3RofWApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcmVudC5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIHBhcmVudFtpXSAhPT0gJ3N0cmluZycpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwYXJlbnRbaV0gPT09ICdfX3Byb3RvX18nKSkge1xuICAgICAgICAgICAgICAgICAgYWxsc3RyaW5ncyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYWxsc3RyaW5ncykge1xuICAgICAgICAgICAgICAgIHZhbCA9IHt9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcmVudC5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldmVudER1cGxpY2F0ZUtleXMgJiZcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbCwgcGFyZW50W2ldKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0R1cGxpY2F0ZSBrZXlzIGluIGEgbWFwJylcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhbFtwYXJlbnRbaV1dID0gcGFyZW50W2kgKyAxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBuZXcgTWFwKClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFyZW50Lmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2ZW50RHVwbGljYXRlS2V5cyAmJiB2YWwuaGFzKHBhcmVudFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUga2V5cyBpbiBhIG1hcCcpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YWwuc2V0KHBhcmVudFtpXSwgcGFyZW50W2kgKyAxXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTVQuVEFHOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHQgPSBuZXcgVGFnZ2VkKHBhcmVudFswXSwgcGFyZW50WzFdKVxuXG4gICAgICAgICAgICAgIHZhbCA9IHQuY29udmVydCh0aGlzLnRhZ3MpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi8gaWYgKHBhcmVudCBpbnN0YW5jZW9mIE5vRmlsdGVyKSB7XG4gICAgICAgICAgLy8gT25seSBwYXJlbnQgdHlwZXMgYXJlIEFycmF5IGFuZCBOb0ZpbHRlciBmb3IgKEFycmF5L01hcCkgYW5kXG4gICAgICAgICAgLy8gKGJ5dGVzL3N0cmluZykgcmVzcGVjdGl2ZWx5LlxuICAgICAgICAgIHN3aXRjaCAocGFyZW50W01BSk9SXSkge1xuICAgICAgICAgICAgY2FzZSBNVC5CWVRFX1NUUklORzpcbiAgICAgICAgICAgICAgdmFsID0gcGFyZW50LnNsaWNlKClcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJlZmVyV2ViKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgICAvKiogQHR5cGUge0J1ZmZlcn0gKi8gKHZhbCkuYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHtCdWZmZXJ9ICovICh2YWwpLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAvKiogQHR5cGUge0J1ZmZlcn0gKi8gKHZhbCkubGVuZ3RoXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIE1ULlVURjhfU1RSSU5HOlxuICAgICAgICAgICAgICB2YWwgPSBwYXJlbnQudG9TdHJpbmcoJ3V0Zi04JylcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdzdG9wJywgcGFyZW50W01BSk9SXSlcblxuICAgICAgICBjb25zdCBvbGQgPSBwYXJlbnRcbiAgICAgICAgcGFyZW50ID0gcGFyZW50W1NZTVMuUEFSRU5UXVxuICAgICAgICBkZWxldGUgb2xkW1NZTVMuUEFSRU5UXVxuICAgICAgICBkZWxldGUgb2xkW01BSk9SXVxuICAgICAgfVxuICAgICAgaWYgKCFhZ2Fpbikge1xuICAgICAgICBpZiAodGhpcy5leHRlbmRlZFJlc3VsdHMpIHtcbiAgICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMudmFsdWVCeXRlcy5zbGljZSgpXG4gICAgICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICAgICAgdmFsdWU6IERlY29kZXIubnVsbGNoZWNrKHZhbCksXG4gICAgICAgICAgICBieXRlcyxcbiAgICAgICAgICAgIGxlbmd0aDogYnl0ZXMubGVuZ3RoLFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudmFsdWVCeXRlcyA9IG5ldyBOb0ZpbHRlcigpXG4gICAgICAgICAgcmV0dXJuIHJldFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuRGVjb2Rlci5OT1RfRk9VTkQgPSBOT1RfRk9VTkRcbm1vZHVsZS5leHBvcnRzID0gRGVjb2RlclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/lib/diagnose.js":
/*!*******************************************!*\
  !*** ./node_modules/cbor/lib/diagnose.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst stream = __webpack_require__(/*! stream */ \"stream\")\nconst Decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/./node_modules/cbor/lib/decoder.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/cbor/lib/utils.js\")\nconst NoFilter = __webpack_require__(/*! nofilter */ \"(ssr)/./node_modules/nofilter/lib/index.js\")\nconst {MT, SYMS} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/cbor/lib/constants.js\")\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n\n/**\n * @typedef DiagnoseOptions\n * @property {string} [separator='\\n'] Output between detected objects.\n * @property {boolean} [stream_errors=false] Put error info into the\n *   output stream.\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of input, ignored if\n *   input is not string.\n */\n/**\n * @callback diagnoseCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [value] The diagnostic value.\n * @returns {void}\n */\n/**\n * @param {DiagnoseOptions|diagnoseCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {diagnoseCallback} [cb] Called on completion.\n * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}} Normalized.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {diagnoseCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends stream.Transform\n */\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {DiagnoseOptions} [options={}] Options for creation.\n   */\n  constructor(options = {}) {\n    const {\n      separator = '\\n',\n      stream_errors = false,\n      // Decoder options\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    })\n\n    this.float_bytes = -1\n    this.separator = separator\n    this.stream_errors = stream_errors\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    })\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('data', this._on_data.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb)\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er)\n        }\n        return cb()\n      }\n      return cb(er)\n    })\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {BufferLike} input The CBOR bytes to format.\n   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]\n   *   Options, the callback, or the input encoding.\n   * @param {diagnoseCallback} [cb] Callback.\n   * @returns {Promise} If callback not specified.\n   * @throws {TypeError} Input not provided.\n   */\n  static diagnose(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', ...opts} = options\n\n    const bs = new NoFilter()\n    const d = new Diagnose(opts)\n    let p = null\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')))\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')))\n        d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    utils.guessEncoding(input, encoding).pipe(d)\n    return p\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    if (this.stream_errors) {\n      this.push(er.toString())\n    } else {\n      this.emit('error', er)\n    }\n  }\n\n  /** @private */\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3,\n      }[len]\n    }\n  }\n\n  /** @private */\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          this.push(', ')\n        }\n        break\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            this.push(': ')\n          } else {\n            this.push(', ')\n          }\n        }\n    }\n  }\n\n  /** @private */\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return\n    }\n    this._fore(parent_mt, pos)\n    const fb = this.float_bytes\n    this.float_bytes = -1\n    this.push(utils.cborValueToString(val, fb))\n  }\n\n  /** @private */\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos)\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`)\n        break\n      case MT.ARRAY:\n        this.push('[')\n        break\n      case MT.MAP:\n        this.push('{')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(')\n        break\n    }\n    if (tag === SYMS.STREAM) {\n      this.push('_ ')\n    }\n  }\n\n  /** @private */\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        this.push(')')\n        break\n      case MT.ARRAY:\n        this.push(']')\n        break\n      case MT.MAP:\n        this.push('}')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push(')')\n        break\n    }\n  }\n\n  /** @private */\n  _on_data() {\n    this.push(this.separator)\n  }\n}\n\nmodule.exports = Diagnose\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvZGlhZ25vc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFXO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyx1REFBUztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyw0REFBVTtBQUNuQyxPQUFPLFVBQVUsRUFBRSxtQkFBTyxDQUFDLCtEQUFhOztBQUV4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVyx5Q0FBeUM7QUFDcEQ7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixjQUFjLGlEQUFpRDtBQUMvRCxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxpQkFBaUIsa0JBQWtCO0FBQzVEO0FBQ0EsY0FBYyxVQUFVLHFCQUFxQixnQkFBZ0IsVUFBVTtBQUN2RTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCLFdBQVc7QUFDekM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSwwQ0FBMEMsV0FBVztBQUNsRTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGVBQWUsU0FBUztBQUN4QixjQUFjLFdBQVc7QUFDekI7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsTUFBTSxhQUFhO0FBQ25CLFdBQVcsMkJBQTJCOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0LWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yL2xpYi9kaWFnbm9zZS5qcz8yMWQ3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3QgRGVjb2RlciA9IHJlcXVpcmUoJy4vZGVjb2RlcicpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgTm9GaWx0ZXIgPSByZXF1aXJlKCdub2ZpbHRlcicpXG5jb25zdCB7TVQsIFNZTVN9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG4vKipcbiAqIFRoaW5ncyB0aGF0IGNhbiBhY3QgYXMgaW5wdXRzLCBmcm9tIHdoaWNoIGEgTm9GaWx0ZXIgY2FuIGJlIGNyZWF0ZWQuXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ3xCdWZmZXJ8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxVaW50OENsYW1wZWRBcnJheVxuICogICB8RGF0YVZpZXd8c3RyZWFtLlJlYWRhYmxlfSBCdWZmZXJMaWtlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBEaWFnbm9zZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2VwYXJhdG9yPSdcXG4nXSBPdXRwdXQgYmV0d2VlbiBkZXRlY3RlZCBvYmplY3RzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc3RyZWFtX2Vycm9ycz1mYWxzZV0gUHV0IGVycm9yIGluZm8gaW50byB0aGVcbiAqICAgb3V0cHV0IHN0cmVhbS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4X2RlcHRoPS0xXSBUaGUgbWF4aW11bSBkZXB0aCB0byBwYXJzZS5cbiAqICAgVXNlIC0xIGZvciBcInVudGlsIHlvdSBydW4gb3V0IG9mIG1lbW9yeVwiLiAgU2V0IHRoaXMgdG8gYSBmaW5pdGVcbiAqICAgcG9zaXRpdmUgbnVtYmVyIGZvciB1bi10cnVzdGVkIGlucHV0cy4gIE1vc3Qgc3RhbmRhcmQgaW5wdXRzIHdvbid0IG5lc3RcbiAqICAgbW9yZSB0aGFuIDEwMCBvciBzbyBsZXZlbHM7IEkndmUgdGVzdGVkIGludG8gdGhlIG1pbGxpb25zIGJlZm9yZVxuICogICBydW5uaW5nIG91dCBvZiBtZW1vcnkuXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3RhZ3NdIE1hcHBpbmcgZnJvbSB0YWcgbnVtYmVyIHRvIGZ1bmN0aW9uKHYpLFxuICogICB3aGVyZSB2IGlzIHRoZSBkZWNvZGVkIHZhbHVlIHRoYXQgY29tZXMgYWZ0ZXIgdGhlIHRhZywgYW5kIHdoZXJlIHRoZVxuICogICBmdW5jdGlvbiByZXR1cm5zIHRoZSBjb3JyZWN0bHktY3JlYXRlZCB2YWx1ZSBmb3IgdGhhdCB0YWcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwcmVmZXJXZWI9ZmFsc2VdIElmIHRydWUsIHByZWZlciBVaW50OEFycmF5cyB0b1xuICogICBiZSBnZW5lcmF0ZWQgaW5zdGVhZCBvZiBub2RlIEJ1ZmZlcnMuICBUaGlzIG1pZ2h0IHR1cm4gb24gc29tZSBtb3JlXG4gKiAgIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZSwgc28gZm9yd2FyZC1jb21wYXRpYmlsaXR5IGlzIG5vdCBndWFyYW50ZWVkIHlldC5cbiAqIEBwcm9wZXJ0eSB7QnVmZmVyRW5jb2Rpbmd9IFtlbmNvZGluZz0naGV4J10gVGhlIGVuY29kaW5nIG9mIGlucHV0LCBpZ25vcmVkIGlmXG4gKiAgIGlucHV0IGlzIG5vdCBzdHJpbmcuXG4gKi9cbi8qKlxuICogQGNhbGxiYWNrIGRpYWdub3NlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IFtlcnJvcl0gSWYgb25lIHdhcyBnZW5lcmF0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSBUaGUgZGlhZ25vc3RpYyB2YWx1ZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG4vKipcbiAqIEBwYXJhbSB7RGlhZ25vc2VPcHRpb25zfGRpYWdub3NlQ2FsbGJhY2t8c3RyaW5nfSBvcHRzIE9wdGlvbnMsXG4gKiAgIHRoZSBjYWxsYmFjaywgb3IgaW5wdXQgaW5jb2RpbmcuXG4gKiBAcGFyYW0ge2RpYWdub3NlQ2FsbGJhY2t9IFtjYl0gQ2FsbGVkIG9uIGNvbXBsZXRpb24uXG4gKiBAcmV0dXJucyB7e29wdGlvbnM6IERpYWdub3NlT3B0aW9ucywgY2I6IGRpYWdub3NlQ2FsbGJhY2t9fSBOb3JtYWxpemVkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBVbmtub3duIG9wdGlvbiB0eXBlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhvcHRzLCBjYikge1xuICBzd2l0Y2ggKHR5cGVvZiBvcHRzKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIHtvcHRpb25zOiB7fSwgY2I6IC8qKiBAdHlwZSB7ZGlhZ25vc2VDYWxsYmFja30gKi8gKG9wdHMpfVxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4ge29wdGlvbnM6IHtlbmNvZGluZzogLyoqIEB0eXBlIHtCdWZmZXJFbmNvZGluZ30gKi8gKG9wdHMpfSwgY2J9XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiB7b3B0aW9uczogb3B0cyB8fCB7fSwgY2J9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gb3B0aW9uIHR5cGUnKVxuICB9XG59XG5cbi8qKlxuICogT3V0cHV0IHRoZSBkaWFnbm9zdGljIGZvcm1hdCBmcm9tIGEgc3RyZWFtIG9mIENCT1IgYnl0ZXMuXG4gKlxuICogQGV4dGVuZHMgc3RyZWFtLlRyYW5zZm9ybVxuICovXG5jbGFzcyBEaWFnbm9zZSBleHRlbmRzIHN0cmVhbS5UcmFuc2Zvcm0ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBEaWFnbm9zZS5cbiAgICpcbiAgICogQHBhcmFtIHtEaWFnbm9zZU9wdGlvbnN9IFtvcHRpb25zPXt9XSBPcHRpb25zIGZvciBjcmVhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlcGFyYXRvciA9ICdcXG4nLFxuICAgICAgc3RyZWFtX2Vycm9ycyA9IGZhbHNlLFxuICAgICAgLy8gRGVjb2RlciBvcHRpb25zXG4gICAgICB0YWdzLFxuICAgICAgbWF4X2RlcHRoLFxuICAgICAgcHJlZmVyV2ViLFxuICAgICAgZW5jb2RpbmcsXG4gICAgICAvLyBTdHJlYW0uVHJhbnNmb3JtIG9wdGlvbnNcbiAgICAgIC4uLnN1cGVyT3B0c1xuICAgIH0gPSBvcHRpb25zXG4gICAgc3VwZXIoe1xuICAgICAgLi4uc3VwZXJPcHRzLFxuICAgICAgcmVhZGFibGVPYmplY3RNb2RlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlT2JqZWN0TW9kZTogZmFsc2UsXG4gICAgfSlcblxuICAgIHRoaXMuZmxvYXRfYnl0ZXMgPSAtMVxuICAgIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yXG4gICAgdGhpcy5zdHJlYW1fZXJyb3JzID0gc3RyZWFtX2Vycm9yc1xuICAgIHRoaXMucGFyc2VyID0gbmV3IERlY29kZXIoe1xuICAgICAgdGFncyxcbiAgICAgIG1heF9kZXB0aCxcbiAgICAgIHByZWZlcldlYixcbiAgICAgIGVuY29kaW5nLFxuICAgIH0pXG4gICAgdGhpcy5wYXJzZXIub24oJ21vcmUtYnl0ZXMnLCB0aGlzLl9vbl9tb3JlLmJpbmQodGhpcykpXG4gICAgdGhpcy5wYXJzZXIub24oJ3ZhbHVlJywgdGhpcy5fb25fdmFsdWUuYmluZCh0aGlzKSlcbiAgICB0aGlzLnBhcnNlci5vbignc3RhcnQnLCB0aGlzLl9vbl9zdGFydC5iaW5kKHRoaXMpKVxuICAgIHRoaXMucGFyc2VyLm9uKCdzdG9wJywgdGhpcy5fb25fc3RvcC5iaW5kKHRoaXMpKVxuICAgIHRoaXMucGFyc2VyLm9uKCdkYXRhJywgdGhpcy5fb25fZGF0YS5iaW5kKHRoaXMpKVxuICAgIHRoaXMucGFyc2VyLm9uKCdlcnJvcicsIHRoaXMuX29uX2Vycm9yLmJpbmQodGhpcykpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gZnJlc2ggQnVmZmVyIHRvIHRyYW5zY29kZS5cbiAgICogQHBhcmFtIHtCdWZmZXJFbmNvZGluZ30gZW5jb2RpbmcgTmFtZSBvZiBlbmNvZGluZy5cbiAgICogQHBhcmFtIHtzdHJlYW0uVHJhbnNmb3JtQ2FsbGJhY2t9IGNiIENhbGxiYWNrIHdoZW4gZG9uZS5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX3RyYW5zZm9ybShmcmVzaCwgZW5jb2RpbmcsIGNiKSB7XG4gICAgdGhpcy5wYXJzZXIud3JpdGUoZnJlc2gsIGVuY29kaW5nLCBjYilcbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJlYW0uVHJhbnNmb3JtQ2FsbGJhY2t9IGNiIENhbGxiYWNrIHdoZW4gZG9uZS5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX2ZsdXNoKGNiKSB7XG4gICAgdGhpcy5wYXJzZXIuX2ZsdXNoKGVyID0+IHtcbiAgICAgIGlmICh0aGlzLnN0cmVhbV9lcnJvcnMpIHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgdGhpcy5fb25fZXJyb3IoZXIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNiKClcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYihlcilcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHJldHVybiBhIHN0cmluZyBpbiBkaWFnbm9zdGljIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJMaWtlfSBpbnB1dCBUaGUgQ0JPUiBieXRlcyB0byBmb3JtYXQuXG4gICAqIEBwYXJhbSB7RGlhZ25vc2VPcHRpb25zIHxkaWFnbm9zZUNhbGxiYWNrfHN0cmluZ30gW29wdGlvbnM9e31dXG4gICAqICAgT3B0aW9ucywgdGhlIGNhbGxiYWNrLCBvciB0aGUgaW5wdXQgZW5jb2RpbmcuXG4gICAqIEBwYXJhbSB7ZGlhZ25vc2VDYWxsYmFja30gW2NiXSBDYWxsYmFjay5cbiAgICogQHJldHVybnMge1Byb21pc2V9IElmIGNhbGxiYWNrIG5vdCBzcGVjaWZpZWQuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW5wdXQgbm90IHByb3ZpZGVkLlxuICAgKi9cbiAgc3RhdGljIGRpYWdub3NlKGlucHV0LCBvcHRpb25zID0ge30sIGNiID0gbnVsbCkge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCByZXF1aXJlZCcpXG4gICAgfVxuICAgICh7b3B0aW9ucywgY2J9ID0gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zLCBjYikpXG4gICAgY29uc3Qge2VuY29kaW5nID0gJ2hleCcsIC4uLm9wdHN9ID0gb3B0aW9uc1xuXG4gICAgY29uc3QgYnMgPSBuZXcgTm9GaWx0ZXIoKVxuICAgIGNvbnN0IGQgPSBuZXcgRGlhZ25vc2Uob3B0cylcbiAgICBsZXQgcCA9IG51bGxcbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkLm9uKCdlbmQnLCAoKSA9PiBjYihudWxsLCBicy50b1N0cmluZygndXRmOCcpKSlcbiAgICAgIGQub24oJ2Vycm9yJywgY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIHAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGQub24oJ2VuZCcsICgpID0+IHJlc29sdmUoYnMudG9TdHJpbmcoJ3V0ZjgnKSkpXG4gICAgICAgIGQub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgfSlcbiAgICB9XG4gICAgZC5waXBlKGJzKVxuICAgIHV0aWxzLmd1ZXNzRW5jb2RpbmcoaW5wdXQsIGVuY29kaW5nKS5waXBlKGQpXG4gICAgcmV0dXJuIHBcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfb25fZXJyb3IoZXIpIHtcbiAgICBpZiAodGhpcy5zdHJlYW1fZXJyb3JzKSB7XG4gICAgICB0aGlzLnB1c2goZXIudG9TdHJpbmcoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfb25fbW9yZShtdCwgbGVuLCBwYXJlbnRfbXQsIHBvcykge1xuICAgIGlmIChtdCA9PT0gTVQuU0lNUExFX0ZMT0FUKSB7XG4gICAgICB0aGlzLmZsb2F0X2J5dGVzID0ge1xuICAgICAgICAyOiAxLFxuICAgICAgICA0OiAyLFxuICAgICAgICA4OiAzLFxuICAgICAgfVtsZW5dXG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9mb3JlKHBhcmVudF9tdCwgcG9zKSB7XG4gICAgc3dpdGNoIChwYXJlbnRfbXQpIHtcbiAgICAgIGNhc2UgTVQuQllURV9TVFJJTkc6XG4gICAgICBjYXNlIE1ULlVURjhfU1RSSU5HOlxuICAgICAgY2FzZSBNVC5BUlJBWTpcbiAgICAgICAgaWYgKHBvcyA+IDApIHtcbiAgICAgICAgICB0aGlzLnB1c2goJywgJylcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBNVC5NQVA6XG4gICAgICAgIGlmIChwb3MgPiAwKSB7XG4gICAgICAgICAgaWYgKHBvcyAlIDIpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCgnOiAnKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1c2goJywgJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX29uX3ZhbHVlKHZhbCwgcGFyZW50X210LCBwb3MpIHtcbiAgICBpZiAodmFsID09PSBTWU1TLkJSRUFLKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fZm9yZShwYXJlbnRfbXQsIHBvcylcbiAgICBjb25zdCBmYiA9IHRoaXMuZmxvYXRfYnl0ZXNcbiAgICB0aGlzLmZsb2F0X2J5dGVzID0gLTFcbiAgICB0aGlzLnB1c2godXRpbHMuY2JvclZhbHVlVG9TdHJpbmcodmFsLCBmYikpXG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX29uX3N0YXJ0KG10LCB0YWcsIHBhcmVudF9tdCwgcG9zKSB7XG4gICAgdGhpcy5fZm9yZShwYXJlbnRfbXQsIHBvcylcbiAgICBzd2l0Y2ggKG10KSB7XG4gICAgICBjYXNlIE1ULlRBRzpcbiAgICAgICAgdGhpcy5wdXNoKGAke3RhZ30oYClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgTVQuQVJSQVk6XG4gICAgICAgIHRoaXMucHVzaCgnWycpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIE1ULk1BUDpcbiAgICAgICAgdGhpcy5wdXNoKCd7JylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgTVQuQllURV9TVFJJTkc6XG4gICAgICBjYXNlIE1ULlVURjhfU1RSSU5HOlxuICAgICAgICB0aGlzLnB1c2goJygnKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAodGFnID09PSBTWU1TLlNUUkVBTSkge1xuICAgICAgdGhpcy5wdXNoKCdfICcpXG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9vbl9zdG9wKG10KSB7XG4gICAgc3dpdGNoIChtdCkge1xuICAgICAgY2FzZSBNVC5UQUc6XG4gICAgICAgIHRoaXMucHVzaCgnKScpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIE1ULkFSUkFZOlxuICAgICAgICB0aGlzLnB1c2goJ10nKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBNVC5NQVA6XG4gICAgICAgIHRoaXMucHVzaCgnfScpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIE1ULkJZVEVfU1RSSU5HOlxuICAgICAgY2FzZSBNVC5VVEY4X1NUUklORzpcbiAgICAgICAgdGhpcy5wdXNoKCcpJylcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX29uX2RhdGEoKSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuc2VwYXJhdG9yKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlhZ25vc2VcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/diagnose.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/lib/encoder.js":
/*!******************************************!*\
  !*** ./node_modules/cbor/lib/encoder.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst stream = __webpack_require__(/*! stream */ \"stream\")\nconst NoFilter = __webpack_require__(/*! nofilter */ \"(ssr)/./node_modules/nofilter/lib/index.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/cbor/lib/utils.js\")\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/cbor/lib/constants.js\")\nconst {\n  MT, NUMBYTES, SHIFT32, SIMPLE, SYMS, TAG, BI,\n} = constants\nconst {Buffer} = __webpack_require__(/*! buffer */ \"buffer\")\n\nconst HALF = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.TWO\nconst FLOAT = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.FOUR\nconst DOUBLE = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.EIGHT\nconst TRUE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.TRUE\nconst FALSE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.FALSE\nconst UNDEFINED = (MT.SIMPLE_FLOAT << 5) | SIMPLE.UNDEFINED\nconst NULL = (MT.SIMPLE_FLOAT << 5) | SIMPLE.NULL\n\nconst BREAK = Buffer.from([0xff])\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex')\n\n/**\n * Generate the CBOR for a value.  If you are using this, you'll either need\n * to call {@link Encoder.write} with a Buffer, or look into the internals of\n * Encoder to reuse existing non-documented behavior.\n *\n * @callback EncodeFunction\n * @param {Encoder} enc The encoder to use.\n * @param {any} val The value to encode.\n * @returns {boolean} True on success.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, EncodeFunction>} SemanticMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {SemanticMap}\n * @private\n */\nconst SEMANTIC_TYPES = {}\n\n/**\n * @type {SemanticMap}\n * @private\n */\nlet current_SEMANTIC_TYPES = {}\n\n/**\n * @param {string} str String to normalize.\n * @returns {\"number\"|\"float\"|\"int\"|\"string\"} Normalized.\n * @throws {TypeError} Invalid input.\n * @private\n */\nfunction parseDateType(str) {\n  if (!str) {\n    return 'number'\n  }\n  switch (str.toLowerCase()) {\n    case 'number':\n      return 'number'\n    case 'float':\n      return 'float'\n    case 'int':\n    case 'integer':\n      return 'int'\n    case 'string':\n      return 'string'\n  }\n  throw new TypeError(`dateType invalid, got \"${str}\"`)\n}\n\n/**\n * @typedef ObjectOptions\n * @property {boolean} [indefinite = false] Force indefinite encoding for this\n *   object.\n * @property {boolean} [skipTypes = false] Do not use available type mappings\n *   for this object, but encode it as a \"normal\" JS object would be.\n */\n\n/**\n * @typedef EncodingOptions\n * @property {any[]|object} [genTypes=[]] Array of pairs of\n *   `type`, `function(Encoder)` for semantic types to be encoded.  Not\n *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.\n *   If an object, the keys are the constructor names for the types.\n * @property {boolean} [canonical=false] Should the output be\n *   canonicalized.\n * @property {boolean|WeakSet} [detectLoops=false] Should object loops\n *   be detected?  This will currently add memory to track every part of the\n *   object being encoded in a WeakSet.  Do not encode\n *   the same object twice on the same encoder, without calling\n *   `removeLoopDetectors` in between, which will clear the WeakSet.\n *   You may pass in your own WeakSet to be used; this is useful in some\n *   recursive scenarios.\n * @property {(\"number\"|\"float\"|\"int\"|\"string\")} [dateType=\"number\"] -\n *   how should dates be encoded?  \"number\" means float or int, if no\n *   fractional seconds.\n * @property {any} [encodeUndefined=undefined] How should an\n *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n *   undefined.  If this is a buffer, use those bytes without re-encoding\n *   them.  If this is a function, the function will be called (which is a\n *   good time to throw an exception, if that's what you want), and the\n *   return value will be used according to these rules.  Anything else will\n *   be encoded as CBOR.\n * @property {boolean} [disallowUndefinedKeys=false] Should\n *   \"undefined\" be disallowed as a key in a Map that is serialized?  If\n *   this is true, encode(new Map([[undefined, 1]])) will throw an\n *   exception.  Note that it is impossible to get a key of undefined in a\n *   normal JS object.\n * @property {boolean} [collapseBigIntegers=false] Should integers\n *   that come in as ECMAscript bigint's be encoded\n *   as normal CBOR integers if they fit, discarding type information?\n * @property {number} [chunkSize=4096] Number of characters or bytes\n *   for each chunk, if obj is a string or Buffer, when indefinite encoding.\n * @property {boolean} [omitUndefinedProperties=false] When encoding\n *   objects or Maps, do not include a key if its corresponding value is\n *   `undefined`.\n */\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends stream.Transform\n */\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {EncodingOptions} [options={}] Options for the encoder.\n   */\n  constructor(options = {}) {\n    const {\n      canonical = false,\n      encodeUndefined,\n      disallowUndefinedKeys = false,\n      dateType = 'number',\n      collapseBigIntegers = false,\n      detectLoops = false,\n      omitUndefinedProperties = false,\n      genTypes = [],\n      ...superOpts\n    } = options\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: true,\n    })\n\n    this.canonical = canonical\n    this.encodeUndefined = encodeUndefined\n    this.disallowUndefinedKeys = disallowUndefinedKeys\n    this.dateType = parseDateType(dateType)\n    this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers\n\n    /** @type {WeakSet?} */\n    this.detectLoops = undefined\n    if (typeof detectLoops === 'boolean') {\n      if (detectLoops) {\n        this.detectLoops = new WeakSet()\n      }\n    } else if (detectLoops instanceof WeakSet) {\n      this.detectLoops = detectLoops\n    } else {\n      throw new TypeError('detectLoops must be boolean or WeakSet')\n    }\n    this.omitUndefinedProperties = omitUndefinedProperties\n\n    this.semanticTypes = {...Encoder.SEMANTIC_TYPES}\n\n    if (Array.isArray(genTypes)) {\n      for (let i = 0, len = genTypes.length; i < len; i += 2) {\n        this.addSemanticType(genTypes[i], genTypes[i + 1])\n      }\n    } else {\n      for (const [k, v] of Object.entries(genTypes)) {\n        this.addSemanticType(k, v)\n      }\n    }\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh)\n    // Old transformers might not return bool.  undefined !== false\n    cb((ret === false) ? new Error('Push Error') : undefined)\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  // eslint-disable-next-line class-methods-use-this\n  _flush(cb) {\n    cb()\n  }\n\n  /**\n   * @param {number} val Number(0-255) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1)\n    b.writeUInt8(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number(0-65535) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2)\n    b.writeUInt16BE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number(0..2**32-1) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeUInt32BE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number to encode as 4-byte float.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeFloatBE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number to encode as 8-byte double.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8)\n    b.writeDoubleBE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNaN() {\n    return this.push(BUF_NAN)\n  }\n\n  /**\n   * @param {number} obj Positive or negative infinity.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInfinity(obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  /**\n   * Choose the best float representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be not-integer, but not\n   *   how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2)\n      if (utils.writeHalf(b2, obj)) {\n        // I have convinced myself that there are no cases where writeHalf\n        // will return true but `utils.parseHalf(b2) !== obj)`\n        return this._pushUInt8(HALF) && this.push(b2)\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  /**\n   * Choose the best integer representation for a postive number and encode\n   * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I\n   * don't remember why).\n   *\n   * @param {number} obj A positive number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @param {number} mt The Major Type number to combine with the integer.\n   *   Not yet shifted.\n   * @param {number} [orig] The number before it was transformed to positive.\n   *   If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,\n   *   then we'll encode this as a float rather than making the number\n   *   negative again and losing precision.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5\n\n    if (obj < 24) {\n      return this._pushUInt8(m | obj)\n    }\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n    }\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n    }\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n    }\n    let max = Number.MAX_SAFE_INTEGER\n    if (mt === MT.NEG_INT) {\n      // Special case for Number.MIN_SAFE_INTEGER - 1\n      max--\n    }\n    if (obj <= max) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n        this._pushUInt32BE(obj % SHIFT32)\n    }\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig)\n    }\n    return this._pushFloat(obj)\n  }\n\n  /**\n   * Choose the best integer representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO)\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    }\n    return this._pushInt(obj, MT.POS_INT)\n  }\n\n  /**\n   * @param {number} obj Plain JS number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNumber(obj) {\n    if (isNaN(obj)) {\n      return this._pushNaN()\n    }\n    if (!isFinite(obj)) {\n      return this._pushInfinity(obj)\n    }\n    if (Math.round(obj) === obj) {\n      return this._pushIntNum(obj)\n    }\n    return this._pushFloat(obj)\n  }\n\n  /**\n   * @param {string} obj String to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8')\n  }\n\n  /**\n   * @param {boolean} obj Bool to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  /**\n   * @param {undefined} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED)\n      case 'function':\n        return this.pushAny(this.encodeUndefined(obj))\n      case 'object': {\n        const buf = utils.bufferishToBuffer(this.encodeUndefined)\n        if (buf) {\n          return this.push(buf)\n        }\n      }\n    }\n    return this.pushAny(this.encodeUndefined)\n  }\n\n  /**\n   * @param {null} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNull(obj) {\n    return this._pushUInt8(NULL)\n  }\n\n  /**\n   * @param {number} tag Tag number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  /**\n   * @param {bigint} obj BigInt to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT\n    let tag = TAG.POS_BIGINT\n    // BigInt doesn't have -0\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE\n      m = MT.NEG_INT\n      tag = TAG.NEG_BIGINT\n    }\n\n    if (this.collapseBigIntegers &&\n        (obj <= BI.MAXINT64)) {\n      // Special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m)\n      }\n      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&\n        this._pushUInt32BE(Number(obj % BI.SHIFT32))\n    }\n\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = `0${str}`\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && Encoder._pushBuffer(this, buf)\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {ObjectOptions} [opts] Options for encoding this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (!obj) {\n      return this._pushNull(obj)\n    }\n    opts = {\n      indefinite: false,\n      skipTypes: false,\n      ...opts,\n    }\n    if (!opts.indefinite) {\n      // This will only happen the first time through for indefinite encoding\n      if (this.detectLoops) {\n        if (this.detectLoops.has(obj)) {\n          throw new Error(`\\\nLoop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.`)\n        } else {\n          this.detectLoops.add(obj)\n        }\n      }\n    }\n    if (!opts.skipTypes) {\n      const f = obj.encodeCBOR\n      if (typeof f === 'function') {\n        return f.call(obj, this)\n      }\n      const converter = this.semanticTypes[obj.constructor.name]\n      if (converter) {\n        return converter.call(obj, this, obj)\n      }\n    }\n    const keys = Object.keys(obj).filter(k => {\n      const tv = typeof obj[k]\n      return (tv !== 'function') &&\n        (!this.omitUndefinedProperties || (tv !== 'undefined'))\n    })\n    const cbor_keys = {}\n    if (this.canonical) {\n      // Note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a))\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b))\n\n        return a_cbor.compare(b_cbor)\n      })\n    }\n    if (opts.indefinite) {\n      if (!this._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!this._pushInt(keys.length, MT.MAP)) {\n      return false\n    }\n    let ck = null\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j]\n      if (this.canonical && ((ck = cbor_keys[k]))) {\n        if (!this.push(ck)) { // Already a Buffer\n          return false\n        }\n      } else if (!this._pushString(k)) {\n        return false\n      }\n      if (!this.pushAny(obj[k])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!this.push(BREAK)) {\n        return false\n      }\n    } else if (this.detectLoops) {\n      this.detectLoops.delete(obj)\n    }\n    return true\n  }\n\n  /**\n   * @param {any[]} objs Array of supported things.\n   * @returns {Buffer} Concatenation of encodings for the supported things.\n   * @ignore\n   */\n  _encodeAll(objs) {\n    const bs = new NoFilter({highWaterMark: this.readableHighWaterMark})\n    this.pipe(bs)\n    for (const o of objs) {\n      this.pushAny(o)\n    }\n    this.end()\n    return bs.read()\n  }\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This\n   * is useful for objects for which you can't add an encodeCBOR method.\n   *\n   * @param {string|Function} type The type to encode.\n   * @param {EncodeFunction} fun The encoder to use.\n   * @returns {EncodeFunction?} The previous encoder or undefined if there\n   *   wasn't one.\n   * @throws {TypeError} Invalid function.\n   */\n  addSemanticType(type, fun) {\n    const typeName = (typeof type === 'string') ? type : type.name\n    const old = this.semanticTypes[typeName]\n\n    if (fun) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('fun must be of type function')\n      }\n      this.semanticTypes[typeName] = fun\n    } else if (old) {\n      delete this.semanticTypes[typeName]\n    }\n    return old\n  }\n\n  /**\n   * Push any supported type onto the encoded stream.\n   *\n   * @param {any} obj The thing to encode.\n   * @returns {boolean} True on success.\n   * @throws {TypeError} Unknown type for obj.\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj)\n      case 'bigint':\n        return this._pushJSBigint(obj)\n      case 'string':\n        return this._pushString(obj)\n      case 'boolean':\n        return this._pushBoolean(obj)\n      case 'undefined':\n        return this._pushUndefined(obj)\n      case 'object':\n        return this._pushObject(obj)\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new TypeError(`Unknown symbol: ${obj.toString()}`)\n        }\n      default:\n        throw new TypeError(\n          `Unknown type: ${typeof obj}, ${(typeof obj.toString === 'function') ? obj.toString() : ''}`\n        )\n    }\n  }\n\n  /**\n   * Encode an array and all of its elements.\n   *\n   * @param {Encoder} gen Encoder to use.\n   * @param {any[]} obj Array to encode.\n   * @param {object} [opts] Options.\n   * @param {boolean} [opts.indefinite=false] Use indefinite encoding?\n   * @returns {boolean} True on success.\n   */\n  static pushArray(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    }\n    const len = obj.length\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.ARRAY << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * Remove the loop detector WeakSet for this Encoder.\n   *\n   * @returns {boolean} True when the Encoder was reset, else false.\n   */\n  removeLoopDetectors() {\n    if (!this.detectLoops) {\n      return false\n    }\n    this.detectLoops = new WeakSet()\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Date} obj Date to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) &&\n          gen._pushString(obj.toISOString())\n      case 'int':\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushIntNum(Math.round(obj.getTime() / 1000))\n      case 'float':\n        // Force float\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushFloat(obj.getTime() / 1000)\n      case 'number':\n      default:\n        // If we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen.pushAny(obj.getTime() / 1000)\n    }\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Buffer} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NoFilter} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushNoFilter(gen, obj) {\n    return Encoder._pushBuffer(gen, /** @type {Buffer} */ (obj.slice()))\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {RegExp} obj RegExp to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Set} obj Set to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushSet(gen, obj) {\n    if (!gen._pushTag(TAG.SET)) {\n      return false\n    }\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {URL} obj URL to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString())\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {object} obj Boxed String, Number, or Boolean object to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBoxed(gen, obj) {\n    return gen.pushAny(obj.valueOf())\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Map} obj Map to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Map key that is undefined.\n   * @ignore\n   */\n  static _pushMap(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    }\n    let entries = [...obj.entries()]\n    if (gen.omitUndefinedProperties) {\n      entries = entries.filter(([k, v]) => v !== undefined)\n    }\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(entries.length, MT.MAP)) {\n      return false\n    }\n    // Memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // Keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const enc = new Encoder({\n        genTypes: gen.semanticTypes,\n        canonical: gen.canonical,\n        detectLoops: Boolean(gen.detectLoops), // Give enc its own loop detector\n        dateType: gen.dateType,\n        disallowUndefinedKeys: gen.disallowUndefinedKeys,\n        collapseBigIntegers: gen.collapseBigIntegers,\n      })\n      const bs = new NoFilter({highWaterMark: gen.readableHighWaterMark})\n      enc.pipe(bs)\n      entries.sort(([a], [b]) => {\n        // Both a and b are the keys\n        enc.pushAny(a)\n        const a_cbor = bs.read()\n        enc.pushAny(b)\n        const b_cbor = bs.read()\n        return a_cbor.compare(b_cbor)\n      })\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    } else {\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NodeJS.TypedArray} obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushTypedArray(gen, obj) {\n    // See https://tools.ietf.org/html/rfc8746\n\n    let typ = 0b01000000\n    let sz = obj.BYTES_PER_ELEMENT\n    const {name} = obj.constructor\n\n    if (name.startsWith('Float')) {\n      typ |= 0b00010000\n      sz /= 2\n    } else if (!name.includes('U')) {\n      typ |= 0b00001000\n    }\n    if (name.includes('Clamped') || ((sz !== 1) && !utils.isBigEndian())) {\n      typ |= 0b00000100\n    }\n    typ |= {\n      1: 0b00,\n      2: 0b01,\n      4: 0b10,\n      8: 0b11,\n    }[sz]\n    if (!gen._pushTag(typ)) {\n      return false\n    }\n    return Encoder._pushBuffer(\n      gen,\n      Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)\n    )\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param { ArrayBuffer } obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushArrayBuffer(gen, obj) {\n    return Encoder._pushBuffer(gen, Buffer.from(obj))\n  }\n\n  /**\n   * Encode the given object with indefinite length.  There are apparently\n   * some (IMO) broken implementations of poorly-specified protocols that\n   * REQUIRE indefinite-encoding.  See the example for how to add this as an\n   * `encodeCBOR` function to an object or class to get indefinite encoding.\n   *\n   * @param {Encoder} gen The encoder to use.\n   * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If\n   *   null, use \"this\" instead.\n   * @param {EncodingOptions} [options={}] Options for encoding.\n   * @returns {boolean} True on success.\n   * @throws {Error} No object to encode or invalid indefinite encoding.\n   * @example <caption>Force indefinite encoding:</caption>\n   * const o = {\n   *   a: true,\n   *   encodeCBOR: cbor.Encoder.encodeIndefinite,\n   * }\n   * const m = []\n   * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n   * cbor.encodeOne([o, m])\n   */\n  static encodeIndefinite(gen, obj, options = {}) {\n    if (obj == null) {\n      if (this == null) {\n        throw new Error('No object to encode')\n      }\n      obj = this\n    }\n\n    // TODO: consider other options\n    const {chunkSize = 4096} = options\n\n    let ret = true\n    const objType = typeof obj\n    let buf = null\n    if (objType === 'string') {\n      // TODO: make sure not to split surrogate pairs at the edges of chunks,\n      // since such half-surrogates cannot be legally encoded as UTF-8.\n      ret = ret && gen._pushUInt8((MT.UTF8_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < obj.length) {\n        const endIndex = offset + chunkSize\n        ret = ret && gen._pushString(obj.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if ((buf = utils.bufferishToBuffer(obj))) {\n      ret = ret && gen._pushUInt8((MT.BYTE_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < buf.length) {\n        const endIndex = offset + chunkSize\n        ret = ret && Encoder._pushBuffer(gen, buf.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if (Array.isArray(obj)) {\n      ret = ret && Encoder.pushArray(gen, obj, {\n        indefinite: true,\n      })\n    } else if (obj instanceof Map) {\n      ret = ret && Encoder._pushMap(gen, obj, {\n        indefinite: true,\n      })\n    } else {\n      if (objType !== 'object') {\n        throw new Error('Invalid indefinite encoding')\n      }\n      ret = ret && gen._pushObject(obj, {\n        indefinite: true,\n        skipTypes: true,\n      })\n    }\n    return ret\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs)\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({\n      canonical: true,\n    })._encodeAll(objs)\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   * @static\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj])\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = []\n      const enc = new Encoder(options)\n      enc.on('data', buf => bufs.push(buf))\n      enc.on('error', reject)\n      enc.on('finish', () => resolve(Buffer.concat(bufs)))\n      enc.pushAny(obj)\n      enc.end()\n    })\n  }\n\n  /**\n   * The currently supported set of semantic types.  May be modified by plugins.\n   *\n   * @type {SemanticMap}\n   */\n  static get SEMANTIC_TYPES() {\n    return current_SEMANTIC_TYPES\n  }\n\n  static set SEMANTIC_TYPES(val) {\n    current_SEMANTIC_TYPES = val\n  }\n\n  /**\n   * Reset the supported semantic types to the original set, before any\n   * plugins modified the list.\n   */\n  static reset() {\n    Encoder.SEMANTIC_TYPES = {...SEMANTIC_TYPES}\n  }\n}\n\nObject.assign(SEMANTIC_TYPES, {\n  Array: Encoder.pushArray,\n  Date: Encoder._pushDate,\n  Buffer: Encoder._pushBuffer,\n  [Buffer.name]: Encoder._pushBuffer, // Might be mangled\n  Map: Encoder._pushMap,\n  NoFilter: Encoder._pushNoFilter,\n  [NoFilter.name]: Encoder._pushNoFilter, // Might be mangled\n  RegExp: Encoder._pushRegexp,\n  Set: Encoder._pushSet,\n  ArrayBuffer: Encoder._pushArrayBuffer,\n  Uint8ClampedArray: Encoder._pushTypedArray,\n  Uint8Array: Encoder._pushTypedArray,\n  Uint16Array: Encoder._pushTypedArray,\n  Uint32Array: Encoder._pushTypedArray,\n  Int8Array: Encoder._pushTypedArray,\n  Int16Array: Encoder._pushTypedArray,\n  Int32Array: Encoder._pushTypedArray,\n  Float32Array: Encoder._pushTypedArray,\n  Float64Array: Encoder._pushTypedArray,\n  URL: Encoder._pushURL,\n  Boolean: Encoder._pushBoxed,\n  Number: Encoder._pushBoxed,\n  String: Encoder._pushBoxed,\n})\n\n// Safari needs to get better.\nif (typeof BigUint64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray\n}\nif (typeof BigInt64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray\n}\n\nEncoder.reset()\nmodule.exports = Encoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvZW5jb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsNERBQVU7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLHVEQUFTO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLCtEQUFhO0FBQ3ZDO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsT0FBTyxRQUFRLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsS0FBSztBQUNoQixhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlDQUFpQztBQUM5QztBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxpQ0FBaUM7QUFDOUMsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pEO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUIsV0FBVztBQUN6QztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsV0FBVztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGVBQWUsU0FBUztBQUN4QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBDQUEwQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsZ0JBQWdCO0FBQzdCLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGVBQWUsU0FBUztBQUN4QixjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxlQUFlO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXLElBQUksMkRBQTJEO0FBQ3JHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxNQUFNO0FBQ25CLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxLQUFLO0FBQ2xCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLEtBQUs7QUFDbEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsS0FBSztBQUNsQixlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLCtCQUErQix5Q0FBeUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsbUJBQW1CO0FBQ2hDLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QixjQUFjLGNBQWM7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0EsYUFBYSxpQkFBaUIsV0FBVztBQUN6QyxlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGtCQUFrQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxpQkFBaUIsV0FBVztBQUN6QyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLGlCQUFpQixXQUFXO0FBQ3pDLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC1jbGllbnQvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvZW5jb2Rlci5qcz8wYmU5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3QgTm9GaWx0ZXIgPSByZXF1aXJlKCdub2ZpbHRlcicpXG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qge1xuICBNVCwgTlVNQllURVMsIFNISUZUMzIsIFNJTVBMRSwgU1lNUywgVEFHLCBCSSxcbn0gPSBjb25zdGFudHNcbmNvbnN0IHtCdWZmZXJ9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuY29uc3QgSEFMRiA9IChNVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBOVU1CWVRFUy5UV09cbmNvbnN0IEZMT0FUID0gKE1ULlNJTVBMRV9GTE9BVCA8PCA1KSB8IE5VTUJZVEVTLkZPVVJcbmNvbnN0IERPVUJMRSA9IChNVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBOVU1CWVRFUy5FSUdIVFxuY29uc3QgVFJVRSA9IChNVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBTSU1QTEUuVFJVRVxuY29uc3QgRkFMU0UgPSAoTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgU0lNUExFLkZBTFNFXG5jb25zdCBVTkRFRklORUQgPSAoTVQuU0lNUExFX0ZMT0FUIDw8IDUpIHwgU0lNUExFLlVOREVGSU5FRFxuY29uc3QgTlVMTCA9IChNVC5TSU1QTEVfRkxPQVQgPDwgNSkgfCBTSU1QTEUuTlVMTFxuXG5jb25zdCBCUkVBSyA9IEJ1ZmZlci5mcm9tKFsweGZmXSlcbmNvbnN0IEJVRl9OQU4gPSBCdWZmZXIuZnJvbSgnZjk3ZTAwJywgJ2hleCcpXG5jb25zdCBCVUZfSU5GX05FRyA9IEJ1ZmZlci5mcm9tKCdmOWZjMDAnLCAnaGV4JylcbmNvbnN0IEJVRl9JTkZfUE9TID0gQnVmZmVyLmZyb20oJ2Y5N2MwMCcsICdoZXgnKVxuY29uc3QgQlVGX05FR19aRVJPID0gQnVmZmVyLmZyb20oJ2Y5ODAwMCcsICdoZXgnKVxuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBDQk9SIGZvciBhIHZhbHVlLiAgSWYgeW91IGFyZSB1c2luZyB0aGlzLCB5b3UnbGwgZWl0aGVyIG5lZWRcbiAqIHRvIGNhbGwge0BsaW5rIEVuY29kZXIud3JpdGV9IHdpdGggYSBCdWZmZXIsIG9yIGxvb2sgaW50byB0aGUgaW50ZXJuYWxzIG9mXG4gKiBFbmNvZGVyIHRvIHJldXNlIGV4aXN0aW5nIG5vbi1kb2N1bWVudGVkIGJlaGF2aW9yLlxuICpcbiAqIEBjYWxsYmFjayBFbmNvZGVGdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmMgVGhlIGVuY29kZXIgdG8gdXNlLlxuICogQHBhcmFtIHthbnl9IHZhbCBUaGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBqc2RvYy9jaGVjay10eXBlcyAqL1xuLyoqXG4gKiBBIG1hcHBpbmcgZnJvbSB0YWcgbnVtYmVyIHRvIGEgdGFnIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3QuPHN0cmluZywgRW5jb2RlRnVuY3Rpb24+fSBTZW1hbnRpY01hcFxuICovXG4vKiBlc2xpbnQtZW5hYmxlIGpzZG9jL2NoZWNrLXR5cGVzICovXG5cbi8qKlxuICogQHR5cGUge1NlbWFudGljTWFwfVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgU0VNQU5USUNfVFlQRVMgPSB7fVxuXG4vKipcbiAqIEB0eXBlIHtTZW1hbnRpY01hcH1cbiAqIEBwcml2YXRlXG4gKi9cbmxldCBjdXJyZW50X1NFTUFOVElDX1RZUEVTID0ge31cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyB7XCJudW1iZXJcInxcImZsb2F0XCJ8XCJpbnRcInxcInN0cmluZ1wifSBOb3JtYWxpemVkLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJbnZhbGlkIGlucHV0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VEYXRlVHlwZShzdHIpIHtcbiAgaWYgKCFzdHIpIHtcbiAgICByZXR1cm4gJ251bWJlcidcbiAgfVxuICBzd2l0Y2ggKHN0ci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiAnbnVtYmVyJ1xuICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIHJldHVybiAnZmxvYXQnXG4gICAgY2FzZSAnaW50JzpcbiAgICBjYXNlICdpbnRlZ2VyJzpcbiAgICAgIHJldHVybiAnaW50J1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gJ3N0cmluZydcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkYXRlVHlwZSBpbnZhbGlkLCBnb3QgXCIke3N0cn1cImApXG59XG5cbi8qKlxuICogQHR5cGVkZWYgT2JqZWN0T3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbaW5kZWZpbml0ZSA9IGZhbHNlXSBGb3JjZSBpbmRlZmluaXRlIGVuY29kaW5nIGZvciB0aGlzXG4gKiAgIG9iamVjdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NraXBUeXBlcyA9IGZhbHNlXSBEbyBub3QgdXNlIGF2YWlsYWJsZSB0eXBlIG1hcHBpbmdzXG4gKiAgIGZvciB0aGlzIG9iamVjdCwgYnV0IGVuY29kZSBpdCBhcyBhIFwibm9ybWFsXCIgSlMgb2JqZWN0IHdvdWxkIGJlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgRW5jb2RpbmdPcHRpb25zXG4gKiBAcHJvcGVydHkge2FueVtdfG9iamVjdH0gW2dlblR5cGVzPVtdXSBBcnJheSBvZiBwYWlycyBvZlxuICogICBgdHlwZWAsIGBmdW5jdGlvbihFbmNvZGVyKWAgZm9yIHNlbWFudGljIHR5cGVzIHRvIGJlIGVuY29kZWQuICBOb3RcbiAqICAgbmVlZGVkIGZvciBBcnJheSwgRGF0ZSwgQnVmZmVyLCBNYXAsIFJlZ0V4cCwgU2V0LCBvciBVUkwuXG4gKiAgIElmIGFuIG9iamVjdCwgdGhlIGtleXMgYXJlIHRoZSBjb25zdHJ1Y3RvciBuYW1lcyBmb3IgdGhlIHR5cGVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY2Fub25pY2FsPWZhbHNlXSBTaG91bGQgdGhlIG91dHB1dCBiZVxuICogICBjYW5vbmljYWxpemVkLlxuICogQHByb3BlcnR5IHtib29sZWFufFdlYWtTZXR9IFtkZXRlY3RMb29wcz1mYWxzZV0gU2hvdWxkIG9iamVjdCBsb29wc1xuICogICBiZSBkZXRlY3RlZD8gIFRoaXMgd2lsbCBjdXJyZW50bHkgYWRkIG1lbW9yeSB0byB0cmFjayBldmVyeSBwYXJ0IG9mIHRoZVxuICogICBvYmplY3QgYmVpbmcgZW5jb2RlZCBpbiBhIFdlYWtTZXQuICBEbyBub3QgZW5jb2RlXG4gKiAgIHRoZSBzYW1lIG9iamVjdCB0d2ljZSBvbiB0aGUgc2FtZSBlbmNvZGVyLCB3aXRob3V0IGNhbGxpbmdcbiAqICAgYHJlbW92ZUxvb3BEZXRlY3RvcnNgIGluIGJldHdlZW4sIHdoaWNoIHdpbGwgY2xlYXIgdGhlIFdlYWtTZXQuXG4gKiAgIFlvdSBtYXkgcGFzcyBpbiB5b3VyIG93biBXZWFrU2V0IHRvIGJlIHVzZWQ7IHRoaXMgaXMgdXNlZnVsIGluIHNvbWVcbiAqICAgcmVjdXJzaXZlIHNjZW5hcmlvcy5cbiAqIEBwcm9wZXJ0eSB7KFwibnVtYmVyXCJ8XCJmbG9hdFwifFwiaW50XCJ8XCJzdHJpbmdcIil9IFtkYXRlVHlwZT1cIm51bWJlclwiXSAtXG4gKiAgIGhvdyBzaG91bGQgZGF0ZXMgYmUgZW5jb2RlZD8gIFwibnVtYmVyXCIgbWVhbnMgZmxvYXQgb3IgaW50LCBpZiBub1xuICogICBmcmFjdGlvbmFsIHNlY29uZHMuXG4gKiBAcHJvcGVydHkge2FueX0gW2VuY29kZVVuZGVmaW5lZD11bmRlZmluZWRdIEhvdyBzaG91bGQgYW5cbiAqICAgXCJ1bmRlZmluZWRcIiBpbiB0aGUgaW5wdXQgYmUgZW5jb2RlZC4gIEJ5IGRlZmF1bHQsIGp1c3QgZW5jb2RlIGEgQ0JPUlxuICogICB1bmRlZmluZWQuICBJZiB0aGlzIGlzIGEgYnVmZmVyLCB1c2UgdGhvc2UgYnl0ZXMgd2l0aG91dCByZS1lbmNvZGluZ1xuICogICB0aGVtLiAgSWYgdGhpcyBpcyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgKHdoaWNoIGlzIGFcbiAqICAgZ29vZCB0aW1lIHRvIHRocm93IGFuIGV4Y2VwdGlvbiwgaWYgdGhhdCdzIHdoYXQgeW91IHdhbnQpLCBhbmQgdGhlXG4gKiAgIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYWNjb3JkaW5nIHRvIHRoZXNlIHJ1bGVzLiAgQW55dGhpbmcgZWxzZSB3aWxsXG4gKiAgIGJlIGVuY29kZWQgYXMgQ0JPUi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Rpc2FsbG93VW5kZWZpbmVkS2V5cz1mYWxzZV0gU2hvdWxkXG4gKiAgIFwidW5kZWZpbmVkXCIgYmUgZGlzYWxsb3dlZCBhcyBhIGtleSBpbiBhIE1hcCB0aGF0IGlzIHNlcmlhbGl6ZWQ/ICBJZlxuICogICB0aGlzIGlzIHRydWUsIGVuY29kZShuZXcgTWFwKFtbdW5kZWZpbmVkLCAxXV0pKSB3aWxsIHRocm93IGFuXG4gKiAgIGV4Y2VwdGlvbi4gIE5vdGUgdGhhdCBpdCBpcyBpbXBvc3NpYmxlIHRvIGdldCBhIGtleSBvZiB1bmRlZmluZWQgaW4gYVxuICogICBub3JtYWwgSlMgb2JqZWN0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbY29sbGFwc2VCaWdJbnRlZ2Vycz1mYWxzZV0gU2hvdWxkIGludGVnZXJzXG4gKiAgIHRoYXQgY29tZSBpbiBhcyBFQ01Bc2NyaXB0IGJpZ2ludCdzIGJlIGVuY29kZWRcbiAqICAgYXMgbm9ybWFsIENCT1IgaW50ZWdlcnMgaWYgdGhleSBmaXQsIGRpc2NhcmRpbmcgdHlwZSBpbmZvcm1hdGlvbj9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2h1bmtTaXplPTQwOTZdIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9yIGJ5dGVzXG4gKiAgIGZvciBlYWNoIGNodW5rLCBpZiBvYmogaXMgYSBzdHJpbmcgb3IgQnVmZmVyLCB3aGVuIGluZGVmaW5pdGUgZW5jb2RpbmcuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvbWl0VW5kZWZpbmVkUHJvcGVydGllcz1mYWxzZV0gV2hlbiBlbmNvZGluZ1xuICogICBvYmplY3RzIG9yIE1hcHMsIGRvIG5vdCBpbmNsdWRlIGEga2V5IGlmIGl0cyBjb3JyZXNwb25kaW5nIHZhbHVlIGlzXG4gKiAgIGB1bmRlZmluZWRgLlxuICovXG5cbi8qKlxuICogVHJhbnNmb3JtIEphdmFTY3JpcHQgdmFsdWVzIGludG8gQ0JPUiBieXRlcy4gIFRoZSBgV3JpdGFibGVgIHNpZGUgb2ZcbiAqIHRoZSBzdHJlYW0gaXMgaW4gb2JqZWN0IG1vZGUuXG4gKlxuICogQGV4dGVuZHMgc3RyZWFtLlRyYW5zZm9ybVxuICovXG5jbGFzcyBFbmNvZGVyIGV4dGVuZHMgc3RyZWFtLlRyYW5zZm9ybSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7RW5jb2RpbmdPcHRpb25zfSBbb3B0aW9ucz17fV0gT3B0aW9ucyBmb3IgdGhlIGVuY29kZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBjYW5vbmljYWwgPSBmYWxzZSxcbiAgICAgIGVuY29kZVVuZGVmaW5lZCxcbiAgICAgIGRpc2FsbG93VW5kZWZpbmVkS2V5cyA9IGZhbHNlLFxuICAgICAgZGF0ZVR5cGUgPSAnbnVtYmVyJyxcbiAgICAgIGNvbGxhcHNlQmlnSW50ZWdlcnMgPSBmYWxzZSxcbiAgICAgIGRldGVjdExvb3BzID0gZmFsc2UsXG4gICAgICBvbWl0VW5kZWZpbmVkUHJvcGVydGllcyA9IGZhbHNlLFxuICAgICAgZ2VuVHlwZXMgPSBbXSxcbiAgICAgIC4uLnN1cGVyT3B0c1xuICAgIH0gPSBvcHRpb25zXG5cbiAgICBzdXBlcih7XG4gICAgICAuLi5zdXBlck9wdHMsXG4gICAgICByZWFkYWJsZU9iamVjdE1vZGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGVPYmplY3RNb2RlOiB0cnVlLFxuICAgIH0pXG5cbiAgICB0aGlzLmNhbm9uaWNhbCA9IGNhbm9uaWNhbFxuICAgIHRoaXMuZW5jb2RlVW5kZWZpbmVkID0gZW5jb2RlVW5kZWZpbmVkXG4gICAgdGhpcy5kaXNhbGxvd1VuZGVmaW5lZEtleXMgPSBkaXNhbGxvd1VuZGVmaW5lZEtleXNcbiAgICB0aGlzLmRhdGVUeXBlID0gcGFyc2VEYXRlVHlwZShkYXRlVHlwZSlcbiAgICB0aGlzLmNvbGxhcHNlQmlnSW50ZWdlcnMgPSB0aGlzLmNhbm9uaWNhbCA/IHRydWUgOiBjb2xsYXBzZUJpZ0ludGVnZXJzXG5cbiAgICAvKiogQHR5cGUge1dlYWtTZXQ/fSAqL1xuICAgIHRoaXMuZGV0ZWN0TG9vcHMgPSB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mIGRldGVjdExvb3BzID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGlmIChkZXRlY3RMb29wcykge1xuICAgICAgICB0aGlzLmRldGVjdExvb3BzID0gbmV3IFdlYWtTZXQoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGV0ZWN0TG9vcHMgaW5zdGFuY2VvZiBXZWFrU2V0KSB7XG4gICAgICB0aGlzLmRldGVjdExvb3BzID0gZGV0ZWN0TG9vcHNcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGV0ZWN0TG9vcHMgbXVzdCBiZSBib29sZWFuIG9yIFdlYWtTZXQnKVxuICAgIH1cbiAgICB0aGlzLm9taXRVbmRlZmluZWRQcm9wZXJ0aWVzID0gb21pdFVuZGVmaW5lZFByb3BlcnRpZXNcblxuICAgIHRoaXMuc2VtYW50aWNUeXBlcyA9IHsuLi5FbmNvZGVyLlNFTUFOVElDX1RZUEVTfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2VuVHlwZXMpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZ2VuVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgdGhpcy5hZGRTZW1hbnRpY1R5cGUoZ2VuVHlwZXNbaV0sIGdlblR5cGVzW2kgKyAxXSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoZ2VuVHlwZXMpKSB7XG4gICAgICAgIHRoaXMuYWRkU2VtYW50aWNUeXBlKGssIHYpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybWluZy5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGZyZXNoIEJ1ZmZlciB0byB0cmFuc2NvZGUuXG4gICAqIEBwYXJhbSB7QnVmZmVyRW5jb2Rpbmd9IGVuY29kaW5nIE5hbWUgb2YgZW5jb2RpbmcuXG4gICAqIEBwYXJhbSB7c3RyZWFtLlRyYW5zZm9ybUNhbGxiYWNrfSBjYiBDYWxsYmFjayB3aGVuIGRvbmUuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF90cmFuc2Zvcm0oZnJlc2gsIGVuY29kaW5nLCBjYikge1xuICAgIGNvbnN0IHJldCA9IHRoaXMucHVzaEFueShmcmVzaClcbiAgICAvLyBPbGQgdHJhbnNmb3JtZXJzIG1pZ2h0IG5vdCByZXR1cm4gYm9vbC4gIHVuZGVmaW5lZCAhPT0gZmFsc2VcbiAgICBjYigocmV0ID09PSBmYWxzZSkgPyBuZXcgRXJyb3IoJ1B1c2ggRXJyb3InKSA6IHVuZGVmaW5lZClcbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJlYW0uVHJhbnNmb3JtQ2FsbGJhY2t9IGNiIENhbGxiYWNrIHdoZW4gZG9uZS5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgX2ZsdXNoKGNiKSB7XG4gICAgY2IoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgTnVtYmVyKDAtMjU1KSB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF9wdXNoVUludDgodmFsKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxKVxuICAgIGIud3JpdGVVSW50OCh2YWwsIDApXG4gICAgcmV0dXJuIHRoaXMucHVzaChiKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgTnVtYmVyKDAtNjU1MzUpIHRvIGVuY29kZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX3B1c2hVSW50MTZCRSh2YWwpIHtcbiAgICBjb25zdCBiID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gICAgYi53cml0ZVVJbnQxNkJFKHZhbCwgMClcbiAgICByZXR1cm4gdGhpcy5wdXNoKGIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCBOdW1iZXIoMC4uMioqMzItMSkgdG8gZW5jb2RlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfcHVzaFVJbnQzMkJFKHZhbCkge1xuICAgIGNvbnN0IGIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNClcbiAgICBiLndyaXRlVUludDMyQkUodmFsLCAwKVxuICAgIHJldHVybiB0aGlzLnB1c2goYilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsIE51bWJlciB0byBlbmNvZGUgYXMgNC1ieXRlIGZsb2F0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfcHVzaEZsb2F0QkUodmFsKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KVxuICAgIGIud3JpdGVGbG9hdEJFKHZhbCwgMClcbiAgICByZXR1cm4gdGhpcy5wdXNoKGIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCBOdW1iZXIgdG8gZW5jb2RlIGFzIDgtYnl0ZSBkb3VibGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF9wdXNoRG91YmxlQkUodmFsKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg4KVxuICAgIGIud3JpdGVEb3VibGVCRSh2YWwsIDApXG4gICAgcmV0dXJuIHRoaXMucHVzaChiKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF9wdXNoTmFOKCkge1xuICAgIHJldHVybiB0aGlzLnB1c2goQlVGX05BTilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqIFBvc2l0aXZlIG9yIG5lZ2F0aXZlIGluZmluaXR5LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfcHVzaEluZmluaXR5KG9iaikge1xuICAgIGNvbnN0IGhhbGYgPSAob2JqIDwgMCkgPyBCVUZfSU5GX05FRyA6IEJVRl9JTkZfUE9TXG4gICAgcmV0dXJuIHRoaXMucHVzaChoYWxmKVxuICB9XG5cbiAgLyoqXG4gICAqIENob29zZSB0aGUgYmVzdCBmbG9hdCByZXByZXNlbnRhdGlvbiBmb3IgYSBudW1iZXIgYW5kIGVuY29kZSBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iaiBBIG51bWJlciB0aGF0IGlzIGtub3duIHRvIGJlIG5vdC1pbnRlZ2VyLCBidXQgbm90XG4gICAqICAgaG93IG1hbnkgYnl0ZXMgb2YgcHJlY2lzaW9uIGl0IG5lZWRzLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfcHVzaEZsb2F0KG9iaikge1xuICAgIGlmICh0aGlzLmNhbm9uaWNhbCkge1xuICAgICAgLy8gVE9ETzogaXMgdGhpcyBlbm91Z2ggc2xvd2VyIHRvIGhpZGUgYmVoaW5kIGNhbm9uaWNhbD9cbiAgICAgIC8vIEl0J3MgY2VydGFpbmx5IGVub3VnaCBvZiBhIGhhY2sgKHNlZSB1dGlscy5wYXJzZUhhbGYpXG5cbiAgICAgIC8vIEZyb20gc2VjdGlvbiAzLjk6XG4gICAgICAvLyBJZiBhIHByb3RvY29sIGFsbG93cyBmb3IgSUVFRSBmbG9hdHMsIHRoZW4gYWRkaXRpb25hbCBjYW5vbmljYWxpemF0aW9uXG4gICAgICAvLyBydWxlcyBtaWdodCBuZWVkIHRvIGJlIGFkZGVkLiAgT25lIGV4YW1wbGUgcnVsZSBtaWdodCBiZSB0byBoYXZlIGFsbFxuICAgICAgLy8gZmxvYXRzIHN0YXJ0IGFzIGEgNjQtYml0IGZsb2F0LCB0aGVuIGRvIGEgdGVzdCBjb252ZXJzaW9uIHRvIGEgMzItYml0XG4gICAgICAvLyBmbG9hdDsgaWYgdGhlIHJlc3VsdCBpcyB0aGUgc2FtZSBudW1lcmljIHZhbHVlLCB1c2UgdGhlIHNob3J0ZXIgdmFsdWVcbiAgICAgIC8vIGFuZCByZXBlYXQgdGhlIHByb2Nlc3Mgd2l0aCBhIHRlc3QgY29udmVyc2lvbiB0byBhIDE2LWJpdCBmbG9hdC4gIChUaGlzXG4gICAgICAvLyBydWxlIHNlbGVjdHMgMTYtYml0IGZsb2F0IGZvciBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgSW5maW5pdHkgYXMgd2VsbC4pXG5cbiAgICAgIC8vIHdoaWNoIHNlZW1zIHByZXR0eSBtdWNoIGJhY2t3YXJkcyB0byBtZS5cbiAgICAgIGNvbnN0IGIyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gICAgICBpZiAodXRpbHMud3JpdGVIYWxmKGIyLCBvYmopKSB7XG4gICAgICAgIC8vIEkgaGF2ZSBjb252aW5jZWQgbXlzZWxmIHRoYXQgdGhlcmUgYXJlIG5vIGNhc2VzIHdoZXJlIHdyaXRlSGFsZlxuICAgICAgICAvLyB3aWxsIHJldHVybiB0cnVlIGJ1dCBgdXRpbHMucGFyc2VIYWxmKGIyKSAhPT0gb2JqKWBcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChIQUxGKSAmJiB0aGlzLnB1c2goYjIpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChNYXRoLmZyb3VuZChvYmopID09PSBvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoRkxPQVQpICYmIHRoaXMuX3B1c2hGbG9hdEJFKG9iailcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KERPVUJMRSkgJiYgdGhpcy5fcHVzaERvdWJsZUJFKG9iailcbiAgfVxuXG4gIC8qKlxuICAgKiBDaG9vc2UgdGhlIGJlc3QgaW50ZWdlciByZXByZXNlbnRhdGlvbiBmb3IgYSBwb3N0aXZlIG51bWJlciBhbmQgZW5jb2RlXG4gICAqIGl0LiAgSWYgdGhlIG51bWJlciBpcyBvdmVyIE1BWF9TQUZFX0lOVEVHRVIsIGZhbGwgYmFjayBvbiBmbG9hdCAoYnV0IElcbiAgICogZG9uJ3QgcmVtZW1iZXIgd2h5KS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iaiBBIHBvc2l0aXZlIG51bWJlciB0aGF0IGlzIGtub3duIHRvIGJlIGFuIGludGVnZXIsXG4gICAqICAgYnV0IG5vdCBob3cgbWFueSBieXRlcyBvZiBwcmVjaXNpb24gaXQgbmVlZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtdCBUaGUgTWFqb3IgVHlwZSBudW1iZXIgdG8gY29tYmluZSB3aXRoIHRoZSBpbnRlZ2VyLlxuICAgKiAgIE5vdCB5ZXQgc2hpZnRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcmlnXSBUaGUgbnVtYmVyIGJlZm9yZSBpdCB3YXMgdHJhbnNmb3JtZWQgdG8gcG9zaXRpdmUuXG4gICAqICAgSWYgdGhlIG10IGlzIE5FR19JTlQsIGFuZCB0aGUgcG9zaXRpdmUgbnVtYmVyIGlzIG92ZXIgTUFYX1NBRkVfSU5ULFxuICAgKiAgIHRoZW4gd2UnbGwgZW5jb2RlIHRoaXMgYXMgYSBmbG9hdCByYXRoZXIgdGhhbiBtYWtpbmcgdGhlIG51bWJlclxuICAgKiAgIG5lZ2F0aXZlIGFnYWluIGFuZCBsb3NpbmcgcHJlY2lzaW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfcHVzaEludChvYmosIG10LCBvcmlnKSB7XG4gICAgY29uc3QgbSA9IG10IDw8IDVcblxuICAgIGlmIChvYmogPCAyNCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChtIHwgb2JqKVxuICAgIH1cbiAgICBpZiAob2JqIDw9IDB4ZmYpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgobSB8IE5VTUJZVEVTLk9ORSkgJiYgdGhpcy5fcHVzaFVJbnQ4KG9iailcbiAgICB9XG4gICAgaWYgKG9iaiA8PSAweGZmZmYpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgobSB8IE5VTUJZVEVTLlRXTykgJiYgdGhpcy5fcHVzaFVJbnQxNkJFKG9iailcbiAgICB9XG4gICAgaWYgKG9iaiA8PSAweGZmZmZmZmZmKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFVJbnQ4KG0gfCBOVU1CWVRFUy5GT1VSKSAmJiB0aGlzLl9wdXNoVUludDMyQkUob2JqKVxuICAgIH1cbiAgICBsZXQgbWF4ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICBpZiAobXQgPT09IE1ULk5FR19JTlQpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgLSAxXG4gICAgICBtYXgtLVxuICAgIH1cbiAgICBpZiAob2JqIDw9IG1heCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChtIHwgTlVNQllURVMuRUlHSFQpICYmXG4gICAgICAgIHRoaXMuX3B1c2hVSW50MzJCRShNYXRoLmZsb29yKG9iaiAvIFNISUZUMzIpKSAmJlxuICAgICAgICB0aGlzLl9wdXNoVUludDMyQkUob2JqICUgU0hJRlQzMilcbiAgICB9XG4gICAgaWYgKG10ID09PSBNVC5ORUdfSU5UKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaEZsb2F0KG9yaWcpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdXNoRmxvYXQob2JqKVxuICB9XG5cbiAgLyoqXG4gICAqIENob29zZSB0aGUgYmVzdCBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uIGZvciBhIG51bWJlciBhbmQgZW5jb2RlIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqIEEgbnVtYmVyIHRoYXQgaXMga25vd24gdG8gYmUgYW4gaW50ZWdlcixcbiAgICogICBidXQgbm90IGhvdyBtYW55IGJ5dGVzIG9mIHByZWNpc2lvbiBpdCBuZWVkcy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX3B1c2hJbnROdW0ob2JqKSB7XG4gICAgaWYgKE9iamVjdC5pcyhvYmosIC0wKSkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaChCVUZfTkVHX1pFUk8pXG4gICAgfVxuXG4gICAgaWYgKG9iaiA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoSW50KC1vYmogLSAxLCBNVC5ORUdfSU5ULCBvYmopXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdXNoSW50KG9iaiwgTVQuUE9TX0lOVClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqIFBsYWluIEpTIG51bWJlciB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF9wdXNoTnVtYmVyKG9iaikge1xuICAgIGlmIChpc05hTihvYmopKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaE5hTigpXG4gICAgfVxuICAgIGlmICghaXNGaW5pdGUob2JqKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hJbmZpbml0eShvYmopXG4gICAgfVxuICAgIGlmIChNYXRoLnJvdW5kKG9iaikgPT09IG9iaikge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hJbnROdW0ob2JqKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHVzaEZsb2F0KG9iailcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqIFN0cmluZyB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF9wdXNoU3RyaW5nKG9iaikge1xuICAgIGNvbnN0IGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG9iaiwgJ3V0ZjgnKVxuICAgIHJldHVybiB0aGlzLl9wdXNoSW50KGxlbiwgTVQuVVRGOF9TVFJJTkcpICYmIHRoaXMucHVzaChvYmosICd1dGY4JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9iaiBCb29sIHRvIGVuY29kZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX3B1c2hCb29sZWFuKG9iaikge1xuICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgob2JqID8gVFJVRSA6IEZBTFNFKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7dW5kZWZpbmVkfSBvYmogSWdub3JlZC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX3B1c2hVbmRlZmluZWQob2JqKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdGhpcy5lbmNvZGVVbmRlZmluZWQpIHtcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoVU5ERUZJTkVEKVxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoQW55KHRoaXMuZW5jb2RlVW5kZWZpbmVkKG9iaikpXG4gICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHV0aWxzLmJ1ZmZlcmlzaFRvQnVmZmVyKHRoaXMuZW5jb2RlVW5kZWZpbmVkKVxuICAgICAgICBpZiAoYnVmKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucHVzaChidWYpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHVzaEFueSh0aGlzLmVuY29kZVVuZGVmaW5lZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bGx9IG9iaiBJZ25vcmVkLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfcHVzaE51bGwob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2hVSW50OChOVUxMKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0YWcgVGFnIG51bWJlciB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF9wdXNoVGFnKHRhZykge1xuICAgIHJldHVybiB0aGlzLl9wdXNoSW50KHRhZywgTVQuVEFHKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YmlnaW50fSBvYmogQmlnSW50IHRvIGVuY29kZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX3B1c2hKU0JpZ2ludChvYmopIHtcbiAgICBsZXQgbSA9IE1ULlBPU19JTlRcbiAgICBsZXQgdGFnID0gVEFHLlBPU19CSUdJTlRcbiAgICAvLyBCaWdJbnQgZG9lc24ndCBoYXZlIC0wXG4gICAgaWYgKG9iaiA8IDApIHtcbiAgICAgIG9iaiA9IC1vYmogKyBCSS5NSU5VU19PTkVcbiAgICAgIG0gPSBNVC5ORUdfSU5UXG4gICAgICB0YWcgPSBUQUcuTkVHX0JJR0lOVFxuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbGxhcHNlQmlnSW50ZWdlcnMgJiZcbiAgICAgICAgKG9iaiA8PSBCSS5NQVhJTlQ2NCkpIHtcbiAgICAgIC8vIFNwZWNpYWwgaGFuZGlsaW5nIGZvciA2NGJpdHNcbiAgICAgIGlmIChvYmogPD0gMHhmZmZmZmZmZikge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEludChOdW1iZXIob2JqKSwgbSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9wdXNoVUludDgoKG0gPDwgNSkgfCBOVU1CWVRFUy5FSUdIVCkgJiZcbiAgICAgICAgdGhpcy5fcHVzaFVJbnQzMkJFKE51bWJlcihvYmogLyBCSS5TSElGVDMyKSkgJiZcbiAgICAgICAgdGhpcy5fcHVzaFVJbnQzMkJFKE51bWJlcihvYmogJSBCSS5TSElGVDMyKSlcbiAgICB9XG5cbiAgICBsZXQgc3RyID0gb2JqLnRvU3RyaW5nKDE2KVxuICAgIGlmIChzdHIubGVuZ3RoICUgMikge1xuICAgICAgc3RyID0gYDAke3N0cn1gXG4gICAgfVxuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHN0ciwgJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hUYWcodGFnKSAmJiBFbmNvZGVyLl9wdXNoQnVmZmVyKHRoaXMsIGJ1ZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIE9iamVjdCB0byBlbmNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0T3B0aW9uc30gW29wdHNdIE9wdGlvbnMgZm9yIGVuY29kaW5nIHRoaXMgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gTG9vcCBkZXRlY3RlZC5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX3B1c2hPYmplY3Qob2JqLCBvcHRzKSB7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoTnVsbChvYmopXG4gICAgfVxuICAgIG9wdHMgPSB7XG4gICAgICBpbmRlZmluaXRlOiBmYWxzZSxcbiAgICAgIHNraXBUeXBlczogZmFsc2UsXG4gICAgICAuLi5vcHRzLFxuICAgIH1cbiAgICBpZiAoIW9wdHMuaW5kZWZpbml0ZSkge1xuICAgICAgLy8gVGhpcyB3aWxsIG9ubHkgaGFwcGVuIHRoZSBmaXJzdCB0aW1lIHRocm91Z2ggZm9yIGluZGVmaW5pdGUgZW5jb2RpbmdcbiAgICAgIGlmICh0aGlzLmRldGVjdExvb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLmRldGVjdExvb3BzLmhhcyhvYmopKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXFxuTG9vcCBkZXRlY3RlZCB3aGlsZSBDQk9SIGVuY29kaW5nLlxuQ2FsbCByZW1vdmVMb29wRGV0ZWN0b3JzIGJlZm9yZSByZXN1bWluZy5gKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGV0ZWN0TG9vcHMuYWRkKG9iailcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW9wdHMuc2tpcFR5cGVzKSB7XG4gICAgICBjb25zdCBmID0gb2JqLmVuY29kZUNCT1JcbiAgICAgIGlmICh0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZi5jYWxsKG9iaiwgdGhpcylcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnZlcnRlciA9IHRoaXMuc2VtYW50aWNUeXBlc1tvYmouY29uc3RydWN0b3IubmFtZV1cbiAgICAgIGlmIChjb252ZXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRlci5jYWxsKG9iaiwgdGhpcywgb2JqKVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKS5maWx0ZXIoayA9PiB7XG4gICAgICBjb25zdCB0diA9IHR5cGVvZiBvYmpba11cbiAgICAgIHJldHVybiAodHYgIT09ICdmdW5jdGlvbicpICYmXG4gICAgICAgICghdGhpcy5vbWl0VW5kZWZpbmVkUHJvcGVydGllcyB8fCAodHYgIT09ICd1bmRlZmluZWQnKSlcbiAgICB9KVxuICAgIGNvbnN0IGNib3Jfa2V5cyA9IHt9XG4gICAgaWYgKHRoaXMuY2Fub25pY2FsKSB7XG4gICAgICAvLyBOb3RlOiB0aGlzIGNhbid0IGJlIGEgbm9ybWFsIHNvcnQsIGJlY2F1c2UgJ2InIG5lZWRzIHRvIHNvcnQgYmVmb3JlXG4gICAgICAvLyAnYWEnXG4gICAgICBrZXlzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgLy8gQWx3YXlzIHN0cmluZ3MsIHNvIGRvbid0IGJvdGhlciB0byBwYXNzIG9wdGlvbnMuXG4gICAgICAgIC8vIGhvbGQgb24gdG8gdGhlIGNib3IgdmVyc2lvbnMsIHNpbmNlIHRoZXJlJ3Mgbm8gbmVlZFxuICAgICAgICAvLyB0byBlbmNvZGUgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgY29uc3QgYV9jYm9yID0gY2Jvcl9rZXlzW2FdIHx8IChjYm9yX2tleXNbYV0gPSBFbmNvZGVyLmVuY29kZShhKSlcbiAgICAgICAgY29uc3QgYl9jYm9yID0gY2Jvcl9rZXlzW2JdIHx8IChjYm9yX2tleXNbYl0gPSBFbmNvZGVyLmVuY29kZShiKSlcblxuICAgICAgICByZXR1cm4gYV9jYm9yLmNvbXBhcmUoYl9jYm9yKVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKG9wdHMuaW5kZWZpbml0ZSkge1xuICAgICAgaWYgKCF0aGlzLl9wdXNoVUludDgoKE1ULk1BUCA8PCA1KSB8IE5VTUJZVEVTLklOREVGSU5JVEUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuX3B1c2hJbnQoa2V5cy5sZW5ndGgsIE1ULk1BUCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBsZXQgY2sgPSBudWxsXG4gICAgZm9yIChsZXQgaiA9IDAsIGxlbjIgPSBrZXlzLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgY29uc3QgayA9IGtleXNbal1cbiAgICAgIGlmICh0aGlzLmNhbm9uaWNhbCAmJiAoKGNrID0gY2Jvcl9rZXlzW2tdKSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1c2goY2spKSB7IC8vIEFscmVhZHkgYSBCdWZmZXJcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5fcHVzaFN0cmluZyhrKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5wdXNoQW55KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRzLmluZGVmaW5pdGUpIHtcbiAgICAgIGlmICghdGhpcy5wdXNoKEJSRUFLKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuZGV0ZWN0TG9vcHMpIHtcbiAgICAgIHRoaXMuZGV0ZWN0TG9vcHMuZGVsZXRlKG9iailcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueVtdfSBvYmpzIEFycmF5IG9mIHN1cHBvcnRlZCB0aGluZ3MuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9IENvbmNhdGVuYXRpb24gb2YgZW5jb2RpbmdzIGZvciB0aGUgc3VwcG9ydGVkIHRoaW5ncy5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX2VuY29kZUFsbChvYmpzKSB7XG4gICAgY29uc3QgYnMgPSBuZXcgTm9GaWx0ZXIoe2hpZ2hXYXRlck1hcms6IHRoaXMucmVhZGFibGVIaWdoV2F0ZXJNYXJrfSlcbiAgICB0aGlzLnBpcGUoYnMpXG4gICAgZm9yIChjb25zdCBvIG9mIG9ianMpIHtcbiAgICAgIHRoaXMucHVzaEFueShvKVxuICAgIH1cbiAgICB0aGlzLmVuZCgpXG4gICAgcmV0dXJuIGJzLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBlbmNvZGluZyBmdW5jdGlvbiB0byB0aGUgbGlzdCBvZiBzdXBwb3J0ZWQgc2VtYW50aWMgdHlwZXMuICBUaGlzXG4gICAqIGlzIHVzZWZ1bCBmb3Igb2JqZWN0cyBmb3Igd2hpY2ggeW91IGNhbid0IGFkZCBhbiBlbmNvZGVDQk9SIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IHR5cGUgVGhlIHR5cGUgdG8gZW5jb2RlLlxuICAgKiBAcGFyYW0ge0VuY29kZUZ1bmN0aW9ufSBmdW4gVGhlIGVuY29kZXIgdG8gdXNlLlxuICAgKiBAcmV0dXJucyB7RW5jb2RlRnVuY3Rpb24/fSBUaGUgcHJldmlvdXMgZW5jb2RlciBvciB1bmRlZmluZWQgaWYgdGhlcmVcbiAgICogICB3YXNuJ3Qgb25lLlxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IEludmFsaWQgZnVuY3Rpb24uXG4gICAqL1xuICBhZGRTZW1hbnRpY1R5cGUodHlwZSwgZnVuKSB7XG4gICAgY29uc3QgdHlwZU5hbWUgPSAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSA/IHR5cGUgOiB0eXBlLm5hbWVcbiAgICBjb25zdCBvbGQgPSB0aGlzLnNlbWFudGljVHlwZXNbdHlwZU5hbWVdXG5cbiAgICBpZiAoZnVuKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1biAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmdW4gbXVzdCBiZSBvZiB0eXBlIGZ1bmN0aW9uJylcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VtYW50aWNUeXBlc1t0eXBlTmFtZV0gPSBmdW5cbiAgICB9IGVsc2UgaWYgKG9sZCkge1xuICAgICAgZGVsZXRlIHRoaXMuc2VtYW50aWNUeXBlc1t0eXBlTmFtZV1cbiAgICB9XG4gICAgcmV0dXJuIG9sZFxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggYW55IHN1cHBvcnRlZCB0eXBlIG9udG8gdGhlIGVuY29kZWQgc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gb2JqIFRoZSB0aGluZyB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gVW5rbm93biB0eXBlIGZvciBvYmouXG4gICAqL1xuICBwdXNoQW55KG9iaikge1xuICAgIHN3aXRjaCAodHlwZW9mIG9iaikge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hOdW1iZXIob2JqKVxuICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hKU0JpZ2ludChvYmopXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaFN0cmluZyhvYmopXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hCb29sZWFuKG9iailcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoVW5kZWZpbmVkKG9iailcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoT2JqZWN0KG9iailcbiAgICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAgIHN3aXRjaCAob2JqKSB7XG4gICAgICAgICAgY2FzZSBTWU1TLk5VTEw6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHVzaE51bGwobnVsbClcbiAgICAgICAgICBjYXNlIFNZTVMuVU5ERUZJTkVEOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hVbmRlZmluZWQodW5kZWZpbmVkKVxuICAgICAgICAgIC8vIFRPRE86IEFkZCBwbHVnZ2FibGUgc3VwcG9ydCBmb3Igb3RoZXIgc3ltYm9sc1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIHN5bWJvbDogJHtvYmoudG9TdHJpbmcoKX1gKVxuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBVbmtub3duIHR5cGU6ICR7dHlwZW9mIG9ian0sICR7KHR5cGVvZiBvYmoudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpID8gb2JqLnRvU3RyaW5nKCkgOiAnJ31gXG4gICAgICAgIClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIGFuIGFycmF5IGFuZCBhbGwgb2YgaXRzIGVsZW1lbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0VuY29kZXJ9IGdlbiBFbmNvZGVyIHRvIHVzZS5cbiAgICogQHBhcmFtIHthbnlbXX0gb2JqIEFycmF5IHRvIGVuY29kZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRzXSBPcHRpb25zLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluZGVmaW5pdGU9ZmFsc2VdIFVzZSBpbmRlZmluaXRlIGVuY29kaW5nP1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKi9cbiAgc3RhdGljIHB1c2hBcnJheShnZW4sIG9iaiwgb3B0cykge1xuICAgIG9wdHMgPSB7XG4gICAgICBpbmRlZmluaXRlOiBmYWxzZSxcbiAgICAgIC4uLm9wdHMsXG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IG9iai5sZW5ndGhcbiAgICBpZiAob3B0cy5pbmRlZmluaXRlKSB7XG4gICAgICBpZiAoIWdlbi5fcHVzaFVJbnQ4KChNVC5BUlJBWSA8PCA1KSB8IE5VTUJZVEVTLklOREVGSU5JVEUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdlbi5fcHVzaEludChsZW4sIE1ULkFSUkFZKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIGlmICghZ2VuLnB1c2hBbnkob2JqW2pdKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdHMuaW5kZWZpbml0ZSkge1xuICAgICAgaWYgKCFnZW4ucHVzaChCUkVBSykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBsb29wIGRldGVjdG9yIFdlYWtTZXQgZm9yIHRoaXMgRW5jb2Rlci5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgd2hlbiB0aGUgRW5jb2RlciB3YXMgcmVzZXQsIGVsc2UgZmFsc2UuXG4gICAqL1xuICByZW1vdmVMb29wRGV0ZWN0b3JzKCkge1xuICAgIGlmICghdGhpcy5kZXRlY3RMb29wcykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRoaXMuZGV0ZWN0TG9vcHMgPSBuZXcgV2Vha1NldCgpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VuY29kZXJ9IGdlbiBFbmNvZGVyLlxuICAgKiBAcGFyYW0ge0RhdGV9IG9iaiBEYXRlIHRvIGVuY29kZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIF9wdXNoRGF0ZShnZW4sIG9iaikge1xuICAgIHN3aXRjaCAoZ2VuLmRhdGVUeXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gZ2VuLl9wdXNoVGFnKFRBRy5EQVRFX1NUUklORykgJiZcbiAgICAgICAgICBnZW4uX3B1c2hTdHJpbmcob2JqLnRvSVNPU3RyaW5nKCkpXG4gICAgICBjYXNlICdpbnQnOlxuICAgICAgICByZXR1cm4gZ2VuLl9wdXNoVGFnKFRBRy5EQVRFX0VQT0NIKSAmJlxuICAgICAgICAgIGdlbi5fcHVzaEludE51bShNYXRoLnJvdW5kKG9iai5nZXRUaW1lKCkgLyAxMDAwKSlcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgICAgLy8gRm9yY2UgZmxvYXRcbiAgICAgICAgcmV0dXJuIGdlbi5fcHVzaFRhZyhUQUcuREFURV9FUE9DSCkgJiZcbiAgICAgICAgICBnZW4uX3B1c2hGbG9hdChvYmouZ2V0VGltZSgpIC8gMTAwMClcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBJZiB3ZSBoYXBwZW4gdG8gaGF2ZSBhbiBpbnRlZ3JhbCBudW1iZXIgb2Ygc2Vjb25kcyxcbiAgICAgICAgLy8gdXNlIGludGVnZXIuICBPdGhlcndpc2UsIHVzZSBmbG9hdC5cbiAgICAgICAgcmV0dXJuIGdlbi5fcHVzaFRhZyhUQUcuREFURV9FUE9DSCkgJiZcbiAgICAgICAgICBnZW4ucHVzaEFueShvYmouZ2V0VGltZSgpIC8gMTAwMClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbmNvZGVyfSBnZW4gRW5jb2Rlci5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IG9iaiBCdWZmZXIgdG8gZW5jb2RlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgX3B1c2hCdWZmZXIoZ2VuLCBvYmopIHtcbiAgICByZXR1cm4gZ2VuLl9wdXNoSW50KG9iai5sZW5ndGgsIE1ULkJZVEVfU1RSSU5HKSAmJiBnZW4ucHVzaChvYmopXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbmNvZGVyfSBnZW4gRW5jb2Rlci5cbiAgICogQHBhcmFtIHtOb0ZpbHRlcn0gb2JqIEJ1ZmZlciB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBfcHVzaE5vRmlsdGVyKGdlbiwgb2JqKSB7XG4gICAgcmV0dXJuIEVuY29kZXIuX3B1c2hCdWZmZXIoZ2VuLCAvKiogQHR5cGUge0J1ZmZlcn0gKi8gKG9iai5zbGljZSgpKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VuY29kZXJ9IGdlbiBFbmNvZGVyLlxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gb2JqIFJlZ0V4cCB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBfcHVzaFJlZ2V4cChnZW4sIG9iaikge1xuICAgIHJldHVybiBnZW4uX3B1c2hUYWcoVEFHLlJFR0VYUCkgJiYgZ2VuLnB1c2hBbnkob2JqLnNvdXJjZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VuY29kZXJ9IGdlbiBFbmNvZGVyLlxuICAgKiBAcGFyYW0ge1NldH0gb2JqIFNldCB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIHN0YXRpYyBfcHVzaFNldChnZW4sIG9iaikge1xuICAgIGlmICghZ2VuLl9wdXNoVGFnKFRBRy5TRVQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKCFnZW4uX3B1c2hJbnQob2JqLnNpemUsIE1ULkFSUkFZKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGZvciAoY29uc3QgeCBvZiBvYmopIHtcbiAgICAgIGlmICghZ2VuLnB1c2hBbnkoeCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbmNvZGVyfSBnZW4gRW5jb2Rlci5cbiAgICogQHBhcmFtIHtVUkx9IG9iaiBVUkwgdG8gZW5jb2RlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgX3B1c2hVUkwoZ2VuLCBvYmopIHtcbiAgICByZXR1cm4gZ2VuLl9wdXNoVGFnKFRBRy5VUkkpICYmIGdlbi5wdXNoQW55KG9iai50b1N0cmluZygpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RW5jb2Rlcn0gZ2VuIEVuY29kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogQm94ZWQgU3RyaW5nLCBOdW1iZXIsIG9yIEJvb2xlYW4gb2JqZWN0IHRvIGVuY29kZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgc3RhdGljIF9wdXNoQm94ZWQoZ2VuLCBvYmopIHtcbiAgICByZXR1cm4gZ2VuLnB1c2hBbnkob2JqLnZhbHVlT2YoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VuY29kZXJ9IGdlbiBFbmNvZGVyLlxuICAgKiBAcGFyYW0ge01hcH0gb2JqIE1hcCB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBNYXAga2V5IHRoYXQgaXMgdW5kZWZpbmVkLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgX3B1c2hNYXAoZ2VuLCBvYmosIG9wdHMpIHtcbiAgICBvcHRzID0ge1xuICAgICAgaW5kZWZpbml0ZTogZmFsc2UsXG4gICAgICAuLi5vcHRzLFxuICAgIH1cbiAgICBsZXQgZW50cmllcyA9IFsuLi5vYmouZW50cmllcygpXVxuICAgIGlmIChnZW4ub21pdFVuZGVmaW5lZFByb3BlcnRpZXMpIHtcbiAgICAgIGVudHJpZXMgPSBlbnRyaWVzLmZpbHRlcigoW2ssIHZdKSA9PiB2ICE9PSB1bmRlZmluZWQpXG4gICAgfVxuICAgIGlmIChvcHRzLmluZGVmaW5pdGUpIHtcbiAgICAgIGlmICghZ2VuLl9wdXNoVUludDgoKE1ULk1BUCA8PCA1KSB8IE5VTUJZVEVTLklOREVGSU5JVEUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdlbi5fcHVzaEludChlbnRyaWVzLmxlbmd0aCwgTVQuTUFQKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8vIE1lbW9pemluZyB0aGUgY2JvciBvbmx5IGhlbHBzIGluIGNlcnRhaW4gY2FzZXMsIGFuZCBodXJ0cyBpbiBtb3N0XG4gICAgLy8gb3RoZXJzLiAgSnVzdCBhdm9pZCBpdC5cbiAgICBpZiAoZ2VuLmNhbm9uaWNhbCkge1xuICAgICAgLy8gS2VlcCB0aGUga2V5L3ZhbHVlIHBhaXJzIHRvZ2V0aGVyLCBzbyB3ZSBkb24ndCBoYXZlIHRvIGRvIG9kZFxuICAgICAgLy8gZ2V0cyB3aXRoIG9iamVjdCBrZXlzIGxhdGVyXG4gICAgICBjb25zdCBlbmMgPSBuZXcgRW5jb2Rlcih7XG4gICAgICAgIGdlblR5cGVzOiBnZW4uc2VtYW50aWNUeXBlcyxcbiAgICAgICAgY2Fub25pY2FsOiBnZW4uY2Fub25pY2FsLFxuICAgICAgICBkZXRlY3RMb29wczogQm9vbGVhbihnZW4uZGV0ZWN0TG9vcHMpLCAvLyBHaXZlIGVuYyBpdHMgb3duIGxvb3AgZGV0ZWN0b3JcbiAgICAgICAgZGF0ZVR5cGU6IGdlbi5kYXRlVHlwZSxcbiAgICAgICAgZGlzYWxsb3dVbmRlZmluZWRLZXlzOiBnZW4uZGlzYWxsb3dVbmRlZmluZWRLZXlzLFxuICAgICAgICBjb2xsYXBzZUJpZ0ludGVnZXJzOiBnZW4uY29sbGFwc2VCaWdJbnRlZ2VycyxcbiAgICAgIH0pXG4gICAgICBjb25zdCBicyA9IG5ldyBOb0ZpbHRlcih7aGlnaFdhdGVyTWFyazogZ2VuLnJlYWRhYmxlSGlnaFdhdGVyTWFya30pXG4gICAgICBlbmMucGlwZShicylcbiAgICAgIGVudHJpZXMuc29ydCgoW2FdLCBbYl0pID0+IHtcbiAgICAgICAgLy8gQm90aCBhIGFuZCBiIGFyZSB0aGUga2V5c1xuICAgICAgICBlbmMucHVzaEFueShhKVxuICAgICAgICBjb25zdCBhX2Nib3IgPSBicy5yZWFkKClcbiAgICAgICAgZW5jLnB1c2hBbnkoYilcbiAgICAgICAgY29uc3QgYl9jYm9yID0gYnMucmVhZCgpXG4gICAgICAgIHJldHVybiBhX2Nib3IuY29tcGFyZShiX2Nib3IpXG4gICAgICB9KVxuICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgZW50cmllcykge1xuICAgICAgICBpZiAoZ2VuLmRpc2FsbG93VW5kZWZpbmVkS2V5cyAmJiAodHlwZW9mIGsgPT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBNYXAga2V5OiB1bmRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICAgIGlmICghKGdlbi5wdXNoQW55KGspICYmIGdlbi5wdXNoQW55KHYpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgaWYgKGdlbi5kaXNhbGxvd1VuZGVmaW5lZEtleXMgJiYgKHR5cGVvZiBrID09PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgTWFwIGtleTogdW5kZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShnZW4ucHVzaEFueShrKSAmJiBnZW4ucHVzaEFueSh2KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0cy5pbmRlZmluaXRlKSB7XG4gICAgICBpZiAoIWdlbi5wdXNoKEJSRUFLKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VuY29kZXJ9IGdlbiBFbmNvZGVyLlxuICAgKiBAcGFyYW0ge05vZGVKUy5UeXBlZEFycmF5fSBvYmogQXJyYXkgdG8gZW5jb2RlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgX3B1c2hUeXBlZEFycmF5KGdlbiwgb2JqKSB7XG4gICAgLy8gU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM4NzQ2XG5cbiAgICBsZXQgdHlwID0gMGIwMTAwMDAwMFxuICAgIGxldCBzeiA9IG9iai5CWVRFU19QRVJfRUxFTUVOVFxuICAgIGNvbnN0IHtuYW1lfSA9IG9iai5jb25zdHJ1Y3RvclxuXG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnRmxvYXQnKSkge1xuICAgICAgdHlwIHw9IDBiMDAwMTAwMDBcbiAgICAgIHN6IC89IDJcbiAgICB9IGVsc2UgaWYgKCFuYW1lLmluY2x1ZGVzKCdVJykpIHtcbiAgICAgIHR5cCB8PSAwYjAwMDAxMDAwXG4gICAgfVxuICAgIGlmIChuYW1lLmluY2x1ZGVzKCdDbGFtcGVkJykgfHwgKChzeiAhPT0gMSkgJiYgIXV0aWxzLmlzQmlnRW5kaWFuKCkpKSB7XG4gICAgICB0eXAgfD0gMGIwMDAwMDEwMFxuICAgIH1cbiAgICB0eXAgfD0ge1xuICAgICAgMTogMGIwMCxcbiAgICAgIDI6IDBiMDEsXG4gICAgICA0OiAwYjEwLFxuICAgICAgODogMGIxMSxcbiAgICB9W3N6XVxuICAgIGlmICghZ2VuLl9wdXNoVGFnKHR5cCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gRW5jb2Rlci5fcHVzaEJ1ZmZlcihcbiAgICAgIGdlbixcbiAgICAgIEJ1ZmZlci5mcm9tKG9iai5idWZmZXIsIG9iai5ieXRlT2Zmc2V0LCBvYmouYnl0ZUxlbmd0aClcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbmNvZGVyfSBnZW4gRW5jb2Rlci5cbiAgICogQHBhcmFtIHsgQXJyYXlCdWZmZXIgfSBvYmogQXJyYXkgdG8gZW5jb2RlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgX3B1c2hBcnJheUJ1ZmZlcihnZW4sIG9iaikge1xuICAgIHJldHVybiBFbmNvZGVyLl9wdXNoQnVmZmVyKGdlbiwgQnVmZmVyLmZyb20ob2JqKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgdGhlIGdpdmVuIG9iamVjdCB3aXRoIGluZGVmaW5pdGUgbGVuZ3RoLiAgVGhlcmUgYXJlIGFwcGFyZW50bHlcbiAgICogc29tZSAoSU1PKSBicm9rZW4gaW1wbGVtZW50YXRpb25zIG9mIHBvb3JseS1zcGVjaWZpZWQgcHJvdG9jb2xzIHRoYXRcbiAgICogUkVRVUlSRSBpbmRlZmluaXRlLWVuY29kaW5nLiAgU2VlIHRoZSBleGFtcGxlIGZvciBob3cgdG8gYWRkIHRoaXMgYXMgYW5cbiAgICogYGVuY29kZUNCT1JgIGZ1bmN0aW9uIHRvIGFuIG9iamVjdCBvciBjbGFzcyB0byBnZXQgaW5kZWZpbml0ZSBlbmNvZGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtFbmNvZGVyfSBnZW4gVGhlIGVuY29kZXIgdG8gdXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8QXJyYXl8TWFwfG9iamVjdH0gW29ial0gVGhlIG9iamVjdCB0byBlbmNvZGUuICBJZlxuICAgKiAgIG51bGwsIHVzZSBcInRoaXNcIiBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge0VuY29kaW5nT3B0aW9uc30gW29wdGlvbnM9e31dIE9wdGlvbnMgZm9yIGVuY29kaW5nLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gTm8gb2JqZWN0IHRvIGVuY29kZSBvciBpbnZhbGlkIGluZGVmaW5pdGUgZW5jb2RpbmcuXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkZvcmNlIGluZGVmaW5pdGUgZW5jb2Rpbmc6PC9jYXB0aW9uPlxuICAgKiBjb25zdCBvID0ge1xuICAgKiAgIGE6IHRydWUsXG4gICAqICAgZW5jb2RlQ0JPUjogY2Jvci5FbmNvZGVyLmVuY29kZUluZGVmaW5pdGUsXG4gICAqIH1cbiAgICogY29uc3QgbSA9IFtdXG4gICAqIG0uZW5jb2RlQ0JPUiA9IGNib3IuRW5jb2Rlci5lbmNvZGVJbmRlZmluaXRlXG4gICAqIGNib3IuZW5jb2RlT25lKFtvLCBtXSlcbiAgICovXG4gIHN0YXRpYyBlbmNvZGVJbmRlZmluaXRlKGdlbiwgb2JqLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBvYmplY3QgdG8gZW5jb2RlJylcbiAgICAgIH1cbiAgICAgIG9iaiA9IHRoaXNcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBjb25zaWRlciBvdGhlciBvcHRpb25zXG4gICAgY29uc3Qge2NodW5rU2l6ZSA9IDQwOTZ9ID0gb3B0aW9uc1xuXG4gICAgbGV0IHJldCA9IHRydWVcbiAgICBjb25zdCBvYmpUeXBlID0gdHlwZW9mIG9ialxuICAgIGxldCBidWYgPSBudWxsXG4gICAgaWYgKG9ialR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUT0RPOiBtYWtlIHN1cmUgbm90IHRvIHNwbGl0IHN1cnJvZ2F0ZSBwYWlycyBhdCB0aGUgZWRnZXMgb2YgY2h1bmtzLFxuICAgICAgLy8gc2luY2Ugc3VjaCBoYWxmLXN1cnJvZ2F0ZXMgY2Fubm90IGJlIGxlZ2FsbHkgZW5jb2RlZCBhcyBVVEYtOC5cbiAgICAgIHJldCA9IHJldCAmJiBnZW4uX3B1c2hVSW50OCgoTVQuVVRGOF9TVFJJTkcgPDwgNSkgfCBOVU1CWVRFUy5JTkRFRklOSVRFKVxuICAgICAgbGV0IG9mZnNldCA9IDBcbiAgICAgIHdoaWxlIChvZmZzZXQgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gb2Zmc2V0ICsgY2h1bmtTaXplXG4gICAgICAgIHJldCA9IHJldCAmJiBnZW4uX3B1c2hTdHJpbmcob2JqLnNsaWNlKG9mZnNldCwgZW5kSW5kZXgpKVxuICAgICAgICBvZmZzZXQgPSBlbmRJbmRleFxuICAgICAgfVxuICAgICAgcmV0ID0gcmV0ICYmIGdlbi5wdXNoKEJSRUFLKVxuICAgIH0gZWxzZSBpZiAoKGJ1ZiA9IHV0aWxzLmJ1ZmZlcmlzaFRvQnVmZmVyKG9iaikpKSB7XG4gICAgICByZXQgPSByZXQgJiYgZ2VuLl9wdXNoVUludDgoKE1ULkJZVEVfU1RSSU5HIDw8IDUpIHwgTlVNQllURVMuSU5ERUZJTklURSlcbiAgICAgIGxldCBvZmZzZXQgPSAwXG4gICAgICB3aGlsZSAob2Zmc2V0IDwgYnVmLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IG9mZnNldCArIGNodW5rU2l6ZVxuICAgICAgICByZXQgPSByZXQgJiYgRW5jb2Rlci5fcHVzaEJ1ZmZlcihnZW4sIGJ1Zi5zbGljZShvZmZzZXQsIGVuZEluZGV4KSlcbiAgICAgICAgb2Zmc2V0ID0gZW5kSW5kZXhcbiAgICAgIH1cbiAgICAgIHJldCA9IHJldCAmJiBnZW4ucHVzaChCUkVBSylcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0ID0gcmV0ICYmIEVuY29kZXIucHVzaEFycmF5KGdlbiwgb2JqLCB7XG4gICAgICAgIGluZGVmaW5pdGU6IHRydWUsXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICByZXQgPSByZXQgJiYgRW5jb2Rlci5fcHVzaE1hcChnZW4sIG9iaiwge1xuICAgICAgICBpbmRlZmluaXRlOiB0cnVlLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9ialR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmRlZmluaXRlIGVuY29kaW5nJylcbiAgICAgIH1cbiAgICAgIHJldCA9IHJldCAmJiBnZW4uX3B1c2hPYmplY3Qob2JqLCB7XG4gICAgICAgIGluZGVmaW5pdGU6IHRydWUsXG4gICAgICAgIHNraXBUeXBlczogdHJ1ZSxcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgb25lIG9yIG1vcmUgSmF2YVNjcmlwdCBvYmplY3RzLCBhbmQgcmV0dXJuIGEgQnVmZmVyIGNvbnRhaW5pbmcgdGhlXG4gICAqIENCT1IgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBvYmpzIFRoZSBvYmplY3RzIHRvIGVuY29kZS5cbiAgICogQHJldHVybnMge0J1ZmZlcn0gVGhlIGVuY29kZWQgb2JqZWN0cy5cbiAgICovXG4gIHN0YXRpYyBlbmNvZGUoLi4ub2Jqcykge1xuICAgIHJldHVybiBuZXcgRW5jb2RlcigpLl9lbmNvZGVBbGwob2JqcylcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgb25lIG9yIG1vcmUgSmF2YVNjcmlwdCBvYmplY3RzIGNhbm9uaWNhbGx5IChzbG93ZXIhKSwgYW5kIHJldHVyblxuICAgKiBhIEJ1ZmZlciBjb250YWluaW5nIHRoZSBDQk9SIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLmFueX0gb2JqcyBUaGUgb2JqZWN0cyB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9IFRoZSBlbmNvZGVkIG9iamVjdHMuXG4gICAqL1xuICBzdGF0aWMgZW5jb2RlQ2Fub25pY2FsKC4uLm9ianMpIHtcbiAgICByZXR1cm4gbmV3IEVuY29kZXIoe1xuICAgICAgY2Fub25pY2FsOiB0cnVlLFxuICAgIH0pLl9lbmNvZGVBbGwob2JqcylcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgb25lIEphdmFTY3JpcHQgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3QgdG8gZW5jb2RlLlxuICAgKiBAcGFyYW0ge0VuY29kaW5nT3B0aW9uc30gW29wdGlvbnM9e31dIFBhc3NlZCB0byB0aGUgRW5jb2RlciBjb25zdHJ1Y3Rvci5cbiAgICogQHJldHVybnMge0J1ZmZlcn0gVGhlIGVuY29kZWQgb2JqZWN0cy5cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIGVuY29kZU9uZShvYmosIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEVuY29kZXIob3B0aW9ucykuX2VuY29kZUFsbChbb2JqXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgb25lIEphdmFTY3JpcHQgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBvcHRpb25zIGluIGEgd2F5IHRoYXRcbiAgICogaXMgbW9yZSByZXNpbGllbnQgdG8gb2JqZWN0cyBiZWluZyBsYXJnZXIgdGhhbiB0aGUgaGlnaFdhdGVyTWFya1xuICAgKiBudW1iZXIgb2YgYnl0ZXMuICBBcyB3aXRoIHRoZSBvdGhlciBzdGF0aWMgZW5jb2RlIGZ1bmN0aW9ucywgdGhpc1xuICAgKiB3aWxsIHN0aWxsIHVzZSBhIGxhcmdlIGFtb3VudCBvZiBtZW1vcnkuICBVc2UgYSBzdHJlYW0tYmFzZWQgYXBwcm9hY2hcbiAgICogZGlyZWN0bHkgaWYgeW91IG5lZWQgdG8gcHJvY2VzcyBsYXJnZSBhbmQgY29tcGxpY2F0ZWQgaW5wdXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3QgdG8gZW5jb2RlLlxuICAgKiBAcGFyYW0ge0VuY29kaW5nT3B0aW9uc30gW29wdGlvbnM9e31dIFBhc3NlZCB0byB0aGUgRW5jb2RlciBjb25zdHJ1Y3Rvci5cbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyPn0gQSBwcm9taXNlIGZvciB0aGUgZW5jb2RlZCBidWZmZXIuXG4gICAqL1xuICBzdGF0aWMgZW5jb2RlQXN5bmMob2JqLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGJ1ZnMgPSBbXVxuICAgICAgY29uc3QgZW5jID0gbmV3IEVuY29kZXIob3B0aW9ucylcbiAgICAgIGVuYy5vbignZGF0YScsIGJ1ZiA9PiBidWZzLnB1c2goYnVmKSlcbiAgICAgIGVuYy5vbignZXJyb3InLCByZWplY3QpXG4gICAgICBlbmMub24oJ2ZpbmlzaCcsICgpID0+IHJlc29sdmUoQnVmZmVyLmNvbmNhdChidWZzKSkpXG4gICAgICBlbmMucHVzaEFueShvYmopXG4gICAgICBlbmMuZW5kKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50bHkgc3VwcG9ydGVkIHNldCBvZiBzZW1hbnRpYyB0eXBlcy4gIE1heSBiZSBtb2RpZmllZCBieSBwbHVnaW5zLlxuICAgKlxuICAgKiBAdHlwZSB7U2VtYW50aWNNYXB9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFNFTUFOVElDX1RZUEVTKCkge1xuICAgIHJldHVybiBjdXJyZW50X1NFTUFOVElDX1RZUEVTXG4gIH1cblxuICBzdGF0aWMgc2V0IFNFTUFOVElDX1RZUEVTKHZhbCkge1xuICAgIGN1cnJlbnRfU0VNQU5USUNfVFlQRVMgPSB2YWxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgc3VwcG9ydGVkIHNlbWFudGljIHR5cGVzIHRvIHRoZSBvcmlnaW5hbCBzZXQsIGJlZm9yZSBhbnlcbiAgICogcGx1Z2lucyBtb2RpZmllZCB0aGUgbGlzdC5cbiAgICovXG4gIHN0YXRpYyByZXNldCgpIHtcbiAgICBFbmNvZGVyLlNFTUFOVElDX1RZUEVTID0gey4uLlNFTUFOVElDX1RZUEVTfVxuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oU0VNQU5USUNfVFlQRVMsIHtcbiAgQXJyYXk6IEVuY29kZXIucHVzaEFycmF5LFxuICBEYXRlOiBFbmNvZGVyLl9wdXNoRGF0ZSxcbiAgQnVmZmVyOiBFbmNvZGVyLl9wdXNoQnVmZmVyLFxuICBbQnVmZmVyLm5hbWVdOiBFbmNvZGVyLl9wdXNoQnVmZmVyLCAvLyBNaWdodCBiZSBtYW5nbGVkXG4gIE1hcDogRW5jb2Rlci5fcHVzaE1hcCxcbiAgTm9GaWx0ZXI6IEVuY29kZXIuX3B1c2hOb0ZpbHRlcixcbiAgW05vRmlsdGVyLm5hbWVdOiBFbmNvZGVyLl9wdXNoTm9GaWx0ZXIsIC8vIE3Dn2lnaHQgYmUgbWFuZ2xlZFxuICBSZWdFeHA6IEVuY29kZXIuX3B1c2hSZWdleHAsXG4gIFNldDogRW5jb2Rlci5fcHVzaFNldCxcbiAgQXJyYXlCdWZmZXI6IEVuY29kZXIuX3B1c2hBcnJheUJ1ZmZlcixcbiAgVWludDhDbGFtcGVkQXJyYXk6IEVuY29kZXIuX3B1c2hUeXBlZEFycmF5LFxuICBVaW50OEFycmF5OiBFbmNvZGVyLl9wdXNoVHlwZWRBcnJheSxcbiAgVWludDE2QXJyYXk6IEVuY29kZXIuX3B1c2hUeXBlZEFycmF5LFxuICBVaW50MzJBcnJheTogRW5jb2Rlci5fcHVzaFR5cGVkQXJyYXksXG4gIEludDhBcnJheTogRW5jb2Rlci5fcHVzaFR5cGVkQXJyYXksXG4gIEludDE2QXJyYXk6IEVuY29kZXIuX3B1c2hUeXBlZEFycmF5LFxuICBJbnQzMkFycmF5OiBFbmNvZGVyLl9wdXNoVHlwZWRBcnJheSxcbiAgRmxvYXQzMkFycmF5OiBFbmNvZGVyLl9wdXNoVHlwZWRBcnJheSxcbiAgRmxvYXQ2NEFycmF5OiBFbmNvZGVyLl9wdXNoVHlwZWRBcnJheSxcbiAgVVJMOiBFbmNvZGVyLl9wdXNoVVJMLFxuICBCb29sZWFuOiBFbmNvZGVyLl9wdXNoQm94ZWQsXG4gIE51bWJlcjogRW5jb2Rlci5fcHVzaEJveGVkLFxuICBTdHJpbmc6IEVuY29kZXIuX3B1c2hCb3hlZCxcbn0pXG5cbi8vIFNhZmFyaSBuZWVkcyB0byBnZXQgYmV0dGVyLlxuaWYgKHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgU0VNQU5USUNfVFlQRVNbQmlnVWludDY0QXJyYXkubmFtZV0gPSBFbmNvZGVyLl9wdXNoVHlwZWRBcnJheVxufVxuaWYgKHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICBTRU1BTlRJQ19UWVBFU1tCaWdJbnQ2NEFycmF5Lm5hbWVdID0gRW5jb2Rlci5fcHVzaFR5cGVkQXJyYXlcbn1cblxuRW5jb2Rlci5yZXNldCgpXG5tb2R1bGUuZXhwb3J0cyA9IEVuY29kZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/encoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/lib/map.js":
/*!**************************************!*\
  !*** ./node_modules/cbor/lib/map.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {Buffer} = __webpack_require__(/*! buffer */ \"buffer\")\nconst encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/./node_modules/cbor/lib/encoder.js\")\nconst decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/./node_modules/cbor/lib/decoder.js\")\nconst {MT} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/cbor/lib/constants.js\")\n\n/**\n * Wrapper around a JavaScript Map object that allows the keys to be\n * any complex type.  The base Map object allows this, but will only\n * compare the keys by identity, not by value.  CborMap translates keys\n * to CBOR first (and base64's them to ensure by-value comparison).\n *\n * This is not a subclass of Object, because it would be tough to get\n * the semantics to be an exact match.\n *\n * @extends Map\n */\nclass CborMap extends Map {\n  /**\n   * Creates an instance of CborMap.\n   *\n   * @param {Iterable<any>} [iterable] An Array or other iterable\n   *   object whose elements are key-value pairs (arrays with two elements, e.g.\n   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added\n   *   to the new CborMap; null values are treated as undefined.\n   */\n  constructor(iterable) {\n    super(iterable)\n  }\n\n  /**\n   * @ignore\n   */\n  static _encode(key) {\n    return encoder.encodeCanonical(key).toString('base64')\n  }\n\n  /**\n   * @ignore\n   */\n  static _decode(key) {\n    return decoder.decodeFirstSync(key, 'base64')\n  }\n\n  /**\n   * Retrieve a specified element.\n   *\n   * @param {any} key The key identifying the element to retrieve.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {any} The element if it exists, or <code>undefined</code>.\n   */\n  get(key) {\n    return super.get(CborMap._encode(key))\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {any} key The key identifying the element to store.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @param {any} val The element to store.\n   * @returns {this} This object.\n   */\n  set(key, val) {\n    return super.set(CborMap._encode(key), val)\n  }\n\n  /**\n   * Removes the specified element.\n   *\n   * @param {any} key The key identifying the element to delete. Can be any\n   *   type, which will be serialized into CBOR and compared by value.\n   * @returns {boolean} True if an element in the Map object existed and has\n   *   been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    return super.delete(CborMap._encode(key))\n  }\n\n  /**\n   * Does an element with the specified key exist?\n   *\n   * @param {any} key The key identifying the element to check.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean} True if an element with the specified key exists in\n   *   the Map object; otherwise false.\n   */\n  has(key) {\n    return super.has(CborMap._encode(key))\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element\n   * in the Map object in insertion order.  The keys are decoded into their\n   * original format.\n   *\n   * @yields {any} The keys of the map.\n   */\n  *keys() {\n    for (const k of super.keys()) {\n      yield CborMap._decode(k)\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator<any>} Key value pairs.\n   * @yields {any[]} Key value pairs.\n   */\n  *entries() {\n    for (const kv of super.entries()) {\n      yield [CborMap._decode(kv[0]), kv[1]]\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator} Key value pairs.\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map\n   * object, in insertion order.\n   *\n   * @param {function(any, any, Map): undefined} fun Function to execute for\n   *   each element, which takes a value, a key, and the Map being traversed.\n   * @param {any} thisArg Value to use as this when executing callback.\n   * @throws {TypeError} Invalid function.\n   */\n  forEach(fun, thisArg) {\n    if (typeof fun !== 'function') {\n      throw new TypeError('Must be function')\n    }\n    for (const kv of super.entries()) {\n      fun.call(this, kv[1], CborMap._decode(kv[0]), this)\n    }\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    if (!gen._pushInt(this.size, MT.MAP)) {\n      return false\n    }\n    if (gen.canonical) {\n      const entries = Array.from(super.entries())\n        .map(kv => [Buffer.from(kv[0], 'base64'), kv[1]])\n      entries.sort((a, b) => a[0].compare(b[0]))\n      for (const kv of entries) {\n        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    } else {\n      for (const kv of super.entries()) {\n        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n}\n\nmodule.exports = CborMap\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvbWFwLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLE9BQU8sUUFBUSxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVc7QUFDbkMsT0FBTyxJQUFJLEVBQUUsbUJBQU8sQ0FBQywrREFBYTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQ0FBb0M7QUFDakQ7QUFDQSxhQUFhLEtBQUs7QUFDbEIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0LWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yL2xpYi9tYXAuanM/YWQxMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge0J1ZmZlcn0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgZW5jb2RlciA9IHJlcXVpcmUoJy4vZW5jb2RlcicpXG5jb25zdCBkZWNvZGVyID0gcmVxdWlyZSgnLi9kZWNvZGVyJylcbmNvbnN0IHtNVH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgYSBKYXZhU2NyaXB0IE1hcCBvYmplY3QgdGhhdCBhbGxvd3MgdGhlIGtleXMgdG8gYmVcbiAqIGFueSBjb21wbGV4IHR5cGUuICBUaGUgYmFzZSBNYXAgb2JqZWN0IGFsbG93cyB0aGlzLCBidXQgd2lsbCBvbmx5XG4gKiBjb21wYXJlIHRoZSBrZXlzIGJ5IGlkZW50aXR5LCBub3QgYnkgdmFsdWUuICBDYm9yTWFwIHRyYW5zbGF0ZXMga2V5c1xuICogdG8gQ0JPUiBmaXJzdCAoYW5kIGJhc2U2NCdzIHRoZW0gdG8gZW5zdXJlIGJ5LXZhbHVlIGNvbXBhcmlzb24pLlxuICpcbiAqIFRoaXMgaXMgbm90IGEgc3ViY2xhc3Mgb2YgT2JqZWN0LCBiZWNhdXNlIGl0IHdvdWxkIGJlIHRvdWdoIHRvIGdldFxuICogdGhlIHNlbWFudGljcyB0byBiZSBhbiBleGFjdCBtYXRjaC5cbiAqXG4gKiBAZXh0ZW5kcyBNYXBcbiAqL1xuY2xhc3MgQ2Jvck1hcCBleHRlbmRzIE1hcCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENib3JNYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGU8YW55Pn0gW2l0ZXJhYmxlXSBBbiBBcnJheSBvciBvdGhlciBpdGVyYWJsZVxuICAgKiAgIG9iamVjdCB3aG9zZSBlbGVtZW50cyBhcmUga2V5LXZhbHVlIHBhaXJzIChhcnJheXMgd2l0aCB0d28gZWxlbWVudHMsIGUuZy5cbiAgICogICA8Y29kZT5bWyAxLCAnb25lJyBdLFsgMiwgJ3R3bycgXV08L2NvZGU+KS4gRWFjaCBrZXktdmFsdWUgcGFpciBpcyBhZGRlZFxuICAgKiAgIHRvIHRoZSBuZXcgQ2Jvck1hcDsgbnVsbCB2YWx1ZXMgYXJlIHRyZWF0ZWQgYXMgdW5kZWZpbmVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoaXRlcmFibGUpIHtcbiAgICBzdXBlcihpdGVyYWJsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgX2VuY29kZShrZXkpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGVDYW5vbmljYWwoa2V5KS50b1N0cmluZygnYmFzZTY0JylcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBzdGF0aWMgX2RlY29kZShrZXkpIHtcbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGVGaXJzdFN5bmMoa2V5LCAnYmFzZTY0JylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIHNwZWNpZmllZCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0ga2V5IFRoZSBrZXkgaWRlbnRpZnlpbmcgdGhlIGVsZW1lbnQgdG8gcmV0cmlldmUuXG4gICAqICAgQ2FuIGJlIGFueSB0eXBlLCB3aGljaCB3aWxsIGJlIHNlcmlhbGl6ZWQgaW50byBDQk9SIGFuZCBjb21wYXJlZCBieVxuICAgKiAgIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7YW55fSBUaGUgZWxlbWVudCBpZiBpdCBleGlzdHMsIG9yIDxjb2RlPnVuZGVmaW5lZDwvY29kZT4uXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldChDYm9yTWFwLl9lbmNvZGUoa2V5KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBrZXkgVGhlIGtleSBpZGVudGlmeWluZyB0aGUgZWxlbWVudCB0byBzdG9yZS5cbiAgICogICBDYW4gYmUgYW55IHR5cGUsIHdoaWNoIHdpbGwgYmUgc2VyaWFsaXplZCBpbnRvIENCT1IgYW5kIGNvbXBhcmVkIGJ5XG4gICAqICAgdmFsdWUuXG4gICAqIEBwYXJhbSB7YW55fSB2YWwgVGhlIGVsZW1lbnQgdG8gc3RvcmUuXG4gICAqIEByZXR1cm5zIHt0aGlzfSBUaGlzIG9iamVjdC5cbiAgICovXG4gIHNldChrZXksIHZhbCkge1xuICAgIHJldHVybiBzdXBlci5zZXQoQ2Jvck1hcC5fZW5jb2RlKGtleSksIHZhbClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGtleSBUaGUga2V5IGlkZW50aWZ5aW5nIHRoZSBlbGVtZW50IHRvIGRlbGV0ZS4gQ2FuIGJlIGFueVxuICAgKiAgIHR5cGUsIHdoaWNoIHdpbGwgYmUgc2VyaWFsaXplZCBpbnRvIENCT1IgYW5kIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IGluIHRoZSBNYXAgb2JqZWN0IGV4aXN0ZWQgYW5kIGhhc1xuICAgKiAgIGJlZW4gcmVtb3ZlZCwgb3IgZmFsc2UgaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBkZWxldGUoa2V5KSB7XG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0ZShDYm9yTWFwLl9lbmNvZGUoa2V5KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBEb2VzIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBleGlzdD9cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGtleSBUaGUga2V5IGlkZW50aWZ5aW5nIHRoZSBlbGVtZW50IHRvIGNoZWNrLlxuICAgKiAgIENhbiBiZSBhbnkgdHlwZSwgd2hpY2ggd2lsbCBiZSBzZXJpYWxpemVkIGludG8gQ0JPUiBhbmQgY29tcGFyZWQgYnlcbiAgICogICB2YWx1ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBpblxuICAgKiAgIHRoZSBNYXAgb2JqZWN0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHN1cGVyLmhhcyhDYm9yTWFwLl9lbmNvZGUoa2V5KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBrZXlzIGZvciBlYWNoIGVsZW1lbnRcbiAgICogaW4gdGhlIE1hcCBvYmplY3QgaW4gaW5zZXJ0aW9uIG9yZGVyLiAgVGhlIGtleXMgYXJlIGRlY29kZWQgaW50byB0aGVpclxuICAgKiBvcmlnaW5hbCBmb3JtYXQuXG4gICAqXG4gICAqIEB5aWVsZHMge2FueX0gVGhlIGtleXMgb2YgdGhlIG1hcC5cbiAgICovXG4gICprZXlzKCkge1xuICAgIGZvciAoY29uc3QgayBvZiBzdXBlci5rZXlzKCkpIHtcbiAgICAgIHlpZWxkIENib3JNYXAuX2RlY29kZShrKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IEl0ZXJhdG9yIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBba2V5LCB2YWx1ZV0gcGFpcnMgZm9yXG4gICAqIGVhY2ggZWxlbWVudCBpbiB0aGUgTWFwIG9iamVjdCBpbiBpbnNlcnRpb24gb3JkZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59IEtleSB2YWx1ZSBwYWlycy5cbiAgICogQHlpZWxkcyB7YW55W119IEtleSB2YWx1ZSBwYWlycy5cbiAgICovXG4gICplbnRyaWVzKCkge1xuICAgIGZvciAoY29uc3Qga3Ygb2Ygc3VwZXIuZW50cmllcygpKSB7XG4gICAgICB5aWVsZCBbQ2Jvck1hcC5fZGVjb2RlKGt2WzBdKSwga3ZbMV1dXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSXRlcmF0b3Igb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIFtrZXksIHZhbHVlXSBwYWlycyBmb3JcbiAgICogZWFjaCBlbGVtZW50IGluIHRoZSBNYXAgb2JqZWN0IGluIGluc2VydGlvbiBvcmRlci5cbiAgICpcbiAgICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3J9IEtleSB2YWx1ZSBwYWlycy5cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBwZXIgZWFjaCBrZXkvdmFsdWUgcGFpciBpbiB0aGUgTWFwXG4gICAqIG9iamVjdCwgaW4gaW5zZXJ0aW9uIG9yZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSwgYW55LCBNYXApOiB1bmRlZmluZWR9IGZ1biBGdW5jdGlvbiB0byBleGVjdXRlIGZvclxuICAgKiAgIGVhY2ggZWxlbWVudCwgd2hpY2ggdGFrZXMgYSB2YWx1ZSwgYSBrZXksIGFuZCB0aGUgTWFwIGJlaW5nIHRyYXZlcnNlZC5cbiAgICogQHBhcmFtIHthbnl9IHRoaXNBcmcgVmFsdWUgdG8gdXNlIGFzIHRoaXMgd2hlbiBleGVjdXRpbmcgY2FsbGJhY2suXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBmdW5jdGlvbi5cbiAgICovXG4gIGZvckVhY2goZnVuLCB0aGlzQXJnKSB7XG4gICAgaWYgKHR5cGVvZiBmdW4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgYmUgZnVuY3Rpb24nKVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGt2IG9mIHN1cGVyLmVudHJpZXMoKSkge1xuICAgICAgZnVuLmNhbGwodGhpcywga3ZbMV0sIENib3JNYXAuX2RlY29kZShrdlswXSksIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggdGhlIHNpbXBsZSB2YWx1ZSBvbnRvIHRoZSBDQk9SIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGdlbiBUaGUgZ2VuZXJhdG9yIHRvIHB1c2ggb250by5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICovXG4gIGVuY29kZUNCT1IoZ2VuKSB7XG4gICAgaWYgKCFnZW4uX3B1c2hJbnQodGhpcy5zaXplLCBNVC5NQVApKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKGdlbi5jYW5vbmljYWwpIHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBBcnJheS5mcm9tKHN1cGVyLmVudHJpZXMoKSlcbiAgICAgICAgLm1hcChrdiA9PiBbQnVmZmVyLmZyb20oa3ZbMF0sICdiYXNlNjQnKSwga3ZbMV1dKVxuICAgICAgZW50cmllcy5zb3J0KChhLCBiKSA9PiBhWzBdLmNvbXBhcmUoYlswXSkpXG4gICAgICBmb3IgKGNvbnN0IGt2IG9mIGVudHJpZXMpIHtcbiAgICAgICAgaWYgKCEoZ2VuLnB1c2goa3ZbMF0pICYmIGdlbi5wdXNoQW55KGt2WzFdKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGt2IG9mIHN1cGVyLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoIShnZW4ucHVzaChCdWZmZXIuZnJvbShrdlswXSwgJ2Jhc2U2NCcpKSAmJiBnZW4ucHVzaEFueShrdlsxXSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENib3JNYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/lib/objectRecorder.js":
/*!*************************************************!*\
  !*** ./node_modules/cbor/lib/objectRecorder.js ***!
  \*************************************************/
/***/ ((module) => {

eval("\n\n/**\n * Record objects that pass by in a stream.  If the same object is used more\n * than once, it can be value-shared using shared values.\n *\n * @see {@link http://cbor.schmorp.de/value-sharing}\n */\nclass ObjectRecorder {\n  constructor() {\n    this.clear()\n  }\n\n  /**\n   * Clear all of the objects that have been seen.  Revert to recording mode.\n   */\n  clear() {\n    this.map = new WeakMap()\n    this.count = 0\n    this.recording = true\n  }\n\n  /**\n   * Stop recording.\n   */\n  stop() {\n    this.recording = false\n  }\n\n  /**\n   * Determine if wrapping a tag 28 or 29 around an object that has been\n   * reused is appropriate.  This method stores state for which objects have\n   * been seen.\n   *\n   * @param {object} obj Any object about to be serialized.\n   * @returns {number} If recording: -1 for first use, index for second use.\n   *   If not recording, -1 for never-duplicated, -2 for first use, index for\n   *   subsequent uses.\n   * @throws {Error} Recording does not match playback.\n   */\n  check(obj) {\n    const val = this.map.get(obj)\n    if (val) {\n      if (val.length > 1) {\n        if (val[0] || this.recording) {\n          return val[1]\n        }\n\n        val[0] = true\n        return ObjectRecorder.FIRST\n      }\n      if (!this.recording) {\n        return ObjectRecorder.NEVER\n      }\n      val.push(this.count++)\n      // Second use while recording\n      return val[1]\n    }\n    if (!this.recording) {\n      throw new Error('New object detected when not recording')\n    }\n    this.map.set(obj, [false])\n    // First use while recording\n    return ObjectRecorder.NEVER\n  }\n}\n\nObjectRecorder.NEVER = -1\nObjectRecorder.FIRST = -2\n\nmodule.exports = ObjectRecorder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvb2JqZWN0UmVjb3JkZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL2Nib3IvbGliL29iamVjdFJlY29yZGVyLmpzPzcyNmMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmVjb3JkIG9iamVjdHMgdGhhdCBwYXNzIGJ5IGluIGEgc3RyZWFtLiAgSWYgdGhlIHNhbWUgb2JqZWN0IGlzIHVzZWQgbW9yZVxuICogdGhhbiBvbmNlLCBpdCBjYW4gYmUgdmFsdWUtc2hhcmVkIHVzaW5nIHNoYXJlZCB2YWx1ZXMuXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cDovL2Nib3Iuc2NobW9ycC5kZS92YWx1ZS1zaGFyaW5nfVxuICovXG5jbGFzcyBPYmplY3RSZWNvcmRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xlYXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBvZiB0aGUgb2JqZWN0cyB0aGF0IGhhdmUgYmVlbiBzZWVuLiAgUmV2ZXJ0IHRvIHJlY29yZGluZyBtb2RlLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5tYXAgPSBuZXcgV2Vha01hcCgpXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgICB0aGlzLnJlY29yZGluZyA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHJlY29yZGluZy5cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5yZWNvcmRpbmcgPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBpZiB3cmFwcGluZyBhIHRhZyAyOCBvciAyOSBhcm91bmQgYW4gb2JqZWN0IHRoYXQgaGFzIGJlZW5cbiAgICogcmV1c2VkIGlzIGFwcHJvcHJpYXRlLiAgVGhpcyBtZXRob2Qgc3RvcmVzIHN0YXRlIGZvciB3aGljaCBvYmplY3RzIGhhdmVcbiAgICogYmVlbiBzZWVuLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIEFueSBvYmplY3QgYWJvdXQgdG8gYmUgc2VyaWFsaXplZC5cbiAgICogQHJldHVybnMge251bWJlcn0gSWYgcmVjb3JkaW5nOiAtMSBmb3IgZmlyc3QgdXNlLCBpbmRleCBmb3Igc2Vjb25kIHVzZS5cbiAgICogICBJZiBub3QgcmVjb3JkaW5nLCAtMSBmb3IgbmV2ZXItZHVwbGljYXRlZCwgLTIgZm9yIGZpcnN0IHVzZSwgaW5kZXggZm9yXG4gICAqICAgc3Vic2VxdWVudCB1c2VzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gUmVjb3JkaW5nIGRvZXMgbm90IG1hdGNoIHBsYXliYWNrLlxuICAgKi9cbiAgY2hlY2sob2JqKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5tYXAuZ2V0KG9iailcbiAgICBpZiAodmFsKSB7XG4gICAgICBpZiAodmFsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKHZhbFswXSB8fCB0aGlzLnJlY29yZGluZykge1xuICAgICAgICAgIHJldHVybiB2YWxbMV1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhbFswXSA9IHRydWVcbiAgICAgICAgcmV0dXJuIE9iamVjdFJlY29yZGVyLkZJUlNUXG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVjb3JkaW5nKSB7XG4gICAgICAgIHJldHVybiBPYmplY3RSZWNvcmRlci5ORVZFUlxuICAgICAgfVxuICAgICAgdmFsLnB1c2godGhpcy5jb3VudCsrKVxuICAgICAgLy8gU2Vjb25kIHVzZSB3aGlsZSByZWNvcmRpbmdcbiAgICAgIHJldHVybiB2YWxbMV1cbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlY29yZGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXcgb2JqZWN0IGRldGVjdGVkIHdoZW4gbm90IHJlY29yZGluZycpXG4gICAgfVxuICAgIHRoaXMubWFwLnNldChvYmosIFtmYWxzZV0pXG4gICAgLy8gRmlyc3QgdXNlIHdoaWxlIHJlY29yZGluZ1xuICAgIHJldHVybiBPYmplY3RSZWNvcmRlci5ORVZFUlxuICB9XG59XG5cbk9iamVjdFJlY29yZGVyLk5FVkVSID0gLTFcbk9iamVjdFJlY29yZGVyLkZJUlNUID0gLTJcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RSZWNvcmRlclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/objectRecorder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/lib/sharedValueEncoder.js":
/*!*****************************************************!*\
  !*** ./node_modules/cbor/lib/sharedValueEncoder.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst Encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/./node_modules/cbor/lib/encoder.js\")\nconst ObjectRecorder = __webpack_require__(/*! ./objectRecorder */ \"(ssr)/./node_modules/cbor/lib/objectRecorder.js\")\nconst {Buffer} = __webpack_require__(/*! buffer */ \"buffer\")\n\n/**\n * Implement value sharing.\n *\n * @see {@link cbor.schmorp.de/value-sharing}\n */\nclass SharedValueEncoder extends Encoder {\n  constructor(opts) {\n    super(opts)\n    this.valueSharing = new ObjectRecorder()\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {import('./encoder').ObjectOptions} [opts] Options for encoding\n   *   this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (obj !== null) {\n      const shared = this.valueSharing.check(obj)\n      switch (shared) {\n        case ObjectRecorder.FIRST:\n          // Prefix with tag 28\n          this._pushTag(28)\n          break\n        case ObjectRecorder.NEVER:\n          // Do nothing\n          break\n        default:\n          return this._pushTag(29) && this._pushIntNum(shared)\n      }\n    }\n    return super._pushObject(obj, opts)\n  }\n\n  /**\n   * Between encoding runs, stop recording, and start outputing correct tags.\n   */\n  stopRecording() {\n    this.valueSharing.stop()\n  }\n\n  /**\n   * Remove the existing recording and start over.  Do this between encoding\n   * pairs.\n   */\n  clearRecording() {\n    this.valueSharing.clear()\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    const enc = new SharedValueEncoder()\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}) // Sink all writes\n\n    for (const o of objs) {\n      enc.pushAny(o)\n    }\n    enc.stopRecording()\n    enc.removeAllListeners('data')\n    return enc._encodeAll(objs)\n  }\n\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} Never.\n   * @throws {Error} Always.  This combination doesn't work at the moment.\n   */\n  static encodeCanonical(...objs) {\n    throw new Error('Cannot encode canonically in a SharedValueEncoder, which serializes objects multiple times.')\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   * @static\n   */\n  static encodeOne(obj, options) {\n    const enc = new SharedValueEncoder(options)\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}) // Sink all writes\n    enc.pushAny(obj)\n    enc.stopRecording()\n    enc.removeAllListeners('data')\n    return enc._encodeAll([obj])\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      /** @type {Buffer[]} */\n      const bufs = []\n      const enc = new SharedValueEncoder(options)\n      // eslint-disable-next-line no-empty-function\n      enc.on('data', () => {})\n      enc.on('error', reject)\n      enc.on('finish', () => resolve(Buffer.concat(bufs)))\n      enc.pushAny(obj)\n      enc.stopRecording()\n      enc.removeAllListeners('data')\n      enc.on('data', buf => bufs.push(buf))\n      enc.pushAny(obj)\n      enc.end()\n    })\n  }\n}\n\nmodule.exports = SharedValueEncoder\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvc2hhcmVkVmFsdWVFbmNvZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFXO0FBQ25DLHVCQUF1QixtQkFBTyxDQUFDLHlFQUFrQjtBQUNqRCxPQUFPLFFBQVEsRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUVqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEscUNBQXFDLFdBQVc7QUFDN0Q7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGFBQWEscUNBQXFDLFdBQVc7QUFDN0Q7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0LWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yL2xpYi9zaGFyZWRWYWx1ZUVuY29kZXIuanM/ZGZjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgRW5jb2RlciA9IHJlcXVpcmUoJy4vZW5jb2RlcicpXG5jb25zdCBPYmplY3RSZWNvcmRlciA9IHJlcXVpcmUoJy4vb2JqZWN0UmVjb3JkZXInKVxuY29uc3Qge0J1ZmZlcn0gPSByZXF1aXJlKCdidWZmZXInKVxuXG4vKipcbiAqIEltcGxlbWVudCB2YWx1ZSBzaGFyaW5nLlxuICpcbiAqIEBzZWUge0BsaW5rIGNib3Iuc2NobW9ycC5kZS92YWx1ZS1zaGFyaW5nfVxuICovXG5jbGFzcyBTaGFyZWRWYWx1ZUVuY29kZXIgZXh0ZW5kcyBFbmNvZGVyIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpcy52YWx1ZVNoYXJpbmcgPSBuZXcgT2JqZWN0UmVjb3JkZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogT2JqZWN0IHRvIGVuY29kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vZW5jb2RlcicpLk9iamVjdE9wdGlvbnN9IFtvcHRzXSBPcHRpb25zIGZvciBlbmNvZGluZ1xuICAgKiAgIHRoaXMgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gTG9vcCBkZXRlY3RlZC5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX3B1c2hPYmplY3Qob2JqLCBvcHRzKSB7XG4gICAgaWYgKG9iaiAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2hhcmVkID0gdGhpcy52YWx1ZVNoYXJpbmcuY2hlY2sob2JqKVxuICAgICAgc3dpdGNoIChzaGFyZWQpIHtcbiAgICAgICAgY2FzZSBPYmplY3RSZWNvcmRlci5GSVJTVDpcbiAgICAgICAgICAvLyBQcmVmaXggd2l0aCB0YWcgMjhcbiAgICAgICAgICB0aGlzLl9wdXNoVGFnKDI4KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgT2JqZWN0UmVjb3JkZXIuTkVWRVI6XG4gICAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2hUYWcoMjkpICYmIHRoaXMuX3B1c2hJbnROdW0oc2hhcmVkKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuX3B1c2hPYmplY3Qob2JqLCBvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIEJldHdlZW4gZW5jb2RpbmcgcnVucywgc3RvcCByZWNvcmRpbmcsIGFuZCBzdGFydCBvdXRwdXRpbmcgY29ycmVjdCB0YWdzLlxuICAgKi9cbiAgc3RvcFJlY29yZGluZygpIHtcbiAgICB0aGlzLnZhbHVlU2hhcmluZy5zdG9wKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGV4aXN0aW5nIHJlY29yZGluZyBhbmQgc3RhcnQgb3Zlci4gIERvIHRoaXMgYmV0d2VlbiBlbmNvZGluZ1xuICAgKiBwYWlycy5cbiAgICovXG4gIGNsZWFyUmVjb3JkaW5nKCkge1xuICAgIHRoaXMudmFsdWVTaGFyaW5nLmNsZWFyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgb25lIG9yIG1vcmUgSmF2YVNjcmlwdCBvYmplY3RzLCBhbmQgcmV0dXJuIGEgQnVmZmVyIGNvbnRhaW5pbmcgdGhlXG4gICAqIENCT1IgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBvYmpzIFRoZSBvYmplY3RzIHRvIGVuY29kZS5cbiAgICogQHJldHVybnMge0J1ZmZlcn0gVGhlIGVuY29kZWQgb2JqZWN0cy5cbiAgICovXG4gIHN0YXRpYyBlbmNvZGUoLi4ub2Jqcykge1xuICAgIGNvbnN0IGVuYyA9IG5ldyBTaGFyZWRWYWx1ZUVuY29kZXIoKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eS1mdW5jdGlvblxuICAgIGVuYy5vbignZGF0YScsICgpID0+IHt9KSAvLyBTaW5rIGFsbCB3cml0ZXNcblxuICAgIGZvciAoY29uc3QgbyBvZiBvYmpzKSB7XG4gICAgICBlbmMucHVzaEFueShvKVxuICAgIH1cbiAgICBlbmMuc3RvcFJlY29yZGluZygpXG4gICAgZW5jLnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpXG4gICAgcmV0dXJuIGVuYy5fZW5jb2RlQWxsKG9ianMpXG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganNkb2MvcmVxdWlyZS1yZXR1cm5zLWNoZWNrXG4gIC8qKlxuICAgKiBFbmNvZGUgb25lIG9yIG1vcmUgSmF2YVNjcmlwdCBvYmplY3RzIGNhbm9uaWNhbGx5IChzbG93ZXIhKSwgYW5kIHJldHVyblxuICAgKiBhIEJ1ZmZlciBjb250YWluaW5nIHRoZSBDQk9SIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gey4uLmFueX0gb2JqcyBUaGUgb2JqZWN0cyB0byBlbmNvZGUuXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9IE5ldmVyLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gQWx3YXlzLiAgVGhpcyBjb21iaW5hdGlvbiBkb2Vzbid0IHdvcmsgYXQgdGhlIG1vbWVudC5cbiAgICovXG4gIHN0YXRpYyBlbmNvZGVDYW5vbmljYWwoLi4ub2Jqcykge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY29kZSBjYW5vbmljYWxseSBpbiBhIFNoYXJlZFZhbHVlRW5jb2Rlciwgd2hpY2ggc2VyaWFsaXplcyBvYmplY3RzIG11bHRpcGxlIHRpbWVzLicpXG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIG9uZSBKYXZhU2NyaXB0IG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG9iaiBUaGUgb2JqZWN0IHRvIGVuY29kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vZW5jb2RlcicpLkVuY29kaW5nT3B0aW9uc30gW29wdGlvbnM9e31dXG4gICAqICAgUGFzc2VkIHRvIHRoZSBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSBUaGUgZW5jb2RlZCBvYmplY3RzLlxuICAgKiBAc3RhdGljXG4gICAqL1xuICBzdGF0aWMgZW5jb2RlT25lKG9iaiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVuYyA9IG5ldyBTaGFyZWRWYWx1ZUVuY29kZXIob3B0aW9ucylcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cbiAgICBlbmMub24oJ2RhdGEnLCAoKSA9PiB7fSkgLy8gU2luayBhbGwgd3JpdGVzXG4gICAgZW5jLnB1c2hBbnkob2JqKVxuICAgIGVuYy5zdG9wUmVjb3JkaW5nKClcbiAgICBlbmMucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJylcbiAgICByZXR1cm4gZW5jLl9lbmNvZGVBbGwoW29ial0pXG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlIG9uZSBKYXZhU2NyaXB0IG9iamVjdCB1c2luZyB0aGUgZ2l2ZW4gb3B0aW9ucyBpbiBhIHdheSB0aGF0XG4gICAqIGlzIG1vcmUgcmVzaWxpZW50IHRvIG9iamVjdHMgYmVpbmcgbGFyZ2VyIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmtcbiAgICogbnVtYmVyIG9mIGJ5dGVzLiAgQXMgd2l0aCB0aGUgb3RoZXIgc3RhdGljIGVuY29kZSBmdW5jdGlvbnMsIHRoaXNcbiAgICogd2lsbCBzdGlsbCB1c2UgYSBsYXJnZSBhbW91bnQgb2YgbWVtb3J5LiAgVXNlIGEgc3RyZWFtLWJhc2VkIGFwcHJvYWNoXG4gICAqIGRpcmVjdGx5IGlmIHlvdSBuZWVkIHRvIHByb2Nlc3MgbGFyZ2UgYW5kIGNvbXBsaWNhdGVkIGlucHV0cy5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IG9iaiBUaGUgb2JqZWN0IHRvIGVuY29kZS5cbiAgICogQHBhcmFtIHtpbXBvcnQoJy4vZW5jb2RlcicpLkVuY29kaW5nT3B0aW9uc30gW29wdGlvbnM9e31dXG4gICAqICAgUGFzc2VkIHRvIHRoZSBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSBBIHByb21pc2UgZm9yIHRoZSBlbmNvZGVkIGJ1ZmZlci5cbiAgICovXG4gIHN0YXRpYyBlbmNvZGVBc3luYyhvYmosIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLyoqIEB0eXBlIHtCdWZmZXJbXX0gKi9cbiAgICAgIGNvbnN0IGJ1ZnMgPSBbXVxuICAgICAgY29uc3QgZW5jID0gbmV3IFNoYXJlZFZhbHVlRW5jb2RlcihvcHRpb25zKVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG4gICAgICBlbmMub24oJ2RhdGEnLCAoKSA9PiB7fSlcbiAgICAgIGVuYy5vbignZXJyb3InLCByZWplY3QpXG4gICAgICBlbmMub24oJ2ZpbmlzaCcsICgpID0+IHJlc29sdmUoQnVmZmVyLmNvbmNhdChidWZzKSkpXG4gICAgICBlbmMucHVzaEFueShvYmopXG4gICAgICBlbmMuc3RvcFJlY29yZGluZygpXG4gICAgICBlbmMucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJylcbiAgICAgIGVuYy5vbignZGF0YScsIGJ1ZiA9PiBidWZzLnB1c2goYnVmKSlcbiAgICAgIGVuYy5wdXNoQW55KG9iailcbiAgICAgIGVuYy5lbmQoKVxuICAgIH0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFyZWRWYWx1ZUVuY29kZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/sharedValueEncoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/lib/simple.js":
/*!*****************************************!*\
  !*** ./node_modules/cbor/lib/simple.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst {MT, SIMPLE, SYMS} = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/cbor/lib/constants.js\")\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {number} value The simple value's integer value.\n   */\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new Error(`Invalid Simple type: ${typeof value}`)\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error(`value must be a small positive integer: ${value}`)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @returns {string} Formated string of `simple(value)`.\n   */\n  toString() {\n    return `simple(${this.value})`\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @param {number} depth How deep are we?\n   * @param {object} opts Options.\n   * @returns {string} Formatted string of `simple(value)`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, opts) {\n    return `simple(${this.value})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj Object to test.\n   * @returns {boolean} Is it Simple?\n   */\n  static isSimple(obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {number} val The CBOR additional info to convert.\n   * @param {boolean} [has_parent=true] Does the CBOR item have a parent?\n   * @param {boolean} [parent_indefinite=false] Is the parent element\n   *   indefinitely encoded?\n   * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.\n   * @throws {Error} Invalid BREAK.\n   */\n  static decode(val, has_parent = true, parent_indefinite = false) {\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (has_parent) {\n          return null\n        }\n        return SYMS.NULL\n      case SIMPLE.UNDEFINED:\n        if (has_parent) {\n          return undefined\n        }\n        return SYMS.UNDEFINED\n      case -1:\n        if (!has_parent || !parent_indefinite) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvc2ltcGxlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLE9BQU8sa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQywrREFBYTs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGFBQWE7QUFDM0Q7QUFDQTtBQUNBLGlFQUFpRSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLHdDQUF3QztBQUN2RCxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0LWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yL2xpYi9zaW1wbGUuanM/YzRiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge01ULCBTSU1QTEUsIFNZTVN9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG4vKipcbiAqIEEgQ0JPUiBTaW1wbGUgVmFsdWUgdGhhdCBkb2VzIG5vdCBtYXAgb250byBhIGtub3duIGNvbnN0YW50LlxuICovXG5jbGFzcyBTaW1wbGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBTaW1wbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgc2ltcGxlIHZhbHVlJ3MgaW50ZWdlciB2YWx1ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBTaW1wbGUgdHlwZTogJHt0eXBlb2YgdmFsdWV9YClcbiAgICB9XG4gICAgaWYgKCh2YWx1ZSA8IDApIHx8ICh2YWx1ZSA+IDI1NSkgfHwgKCh2YWx1ZSB8IDApICE9PSB2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsdWUgbXVzdCBiZSBhIHNtYWxsIHBvc2l0aXZlIGludGVnZXI6ICR7dmFsdWV9YClcbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogRGVidWcgc3RyaW5nIGZvciBzaW1wbGUgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdGVkIHN0cmluZyBvZiBgc2ltcGxlKHZhbHVlKWAuXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYHNpbXBsZSgke3RoaXMudmFsdWV9KWBcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWJ1ZyBzdHJpbmcgZm9yIHNpbXBsZSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIEhvdyBkZWVwIGFyZSB3ZT9cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgT3B0aW9ucy5cbiAgICogQHJldHVybnMge3N0cmluZ30gRm9ybWF0dGVkIHN0cmluZyBvZiBgc2ltcGxlKHZhbHVlKWAuXG4gICAqL1xuICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oZGVwdGgsIG9wdHMpIHtcbiAgICByZXR1cm4gYHNpbXBsZSgke3RoaXMudmFsdWV9KWBcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIHRoZSBzaW1wbGUgdmFsdWUgb250byB0aGUgQ0JPUiBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBnZW4gVGhlIGdlbmVyYXRvciB0byBwdXNoIG9udG8uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqL1xuICBlbmNvZGVDQk9SKGdlbikge1xuICAgIHJldHVybiBnZW4uX3B1c2hJbnQodGhpcy52YWx1ZSwgTVQuU0lNUExFX0ZMT0FUKVxuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSBnaXZlbiBvYmplY3QgYSBTaW1wbGU/XG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBvYmogT2JqZWN0IHRvIHRlc3QuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBJcyBpdCBTaW1wbGU/XG4gICAqL1xuICBzdGF0aWMgaXNTaW1wbGUob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFNpbXBsZVxuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBmcm9tIHRoZSBDQk9SIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gaW50byBhIEphdmFTY3JpcHQgdmFsdWUuXG4gICAqIElmIHRoZSBDQk9SIGl0ZW0gaGFzIG5vIHBhcmVudCwgcmV0dXJuIGEgXCJzYWZlXCIgc3ltYm9sIGluc3RlYWQgb2ZcbiAgICogYG51bGxgIG9yIGB1bmRlZmluZWRgLCBzbyB0aGF0IHRoZSB2YWx1ZSBjYW4gYmUgcGFzc2VkIHRocm91Z2ggYVxuICAgKiBzdHJlYW0gaW4gb2JqZWN0IG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVGhlIENCT1IgYWRkaXRpb25hbCBpbmZvIHRvIGNvbnZlcnQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hhc19wYXJlbnQ9dHJ1ZV0gRG9lcyB0aGUgQ0JPUiBpdGVtIGhhdmUgYSBwYXJlbnQ/XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmVudF9pbmRlZmluaXRlPWZhbHNlXSBJcyB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICogICBpbmRlZmluaXRlbHkgZW5jb2RlZD9cbiAgICogQHJldHVybnMgeyhudWxsfHVuZGVmaW5lZHxib29sZWFufHN5bWJvbHxTaW1wbGUpfSBUaGUgZGVjb2RlZCB2YWx1ZS5cbiAgICogQHRocm93cyB7RXJyb3J9IEludmFsaWQgQlJFQUsuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlKHZhbCwgaGFzX3BhcmVudCA9IHRydWUsIHBhcmVudF9pbmRlZmluaXRlID0gZmFsc2UpIHtcbiAgICBzd2l0Y2ggKHZhbCkge1xuICAgICAgY2FzZSBTSU1QTEUuRkFMU0U6XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgY2FzZSBTSU1QTEUuVFJVRTpcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIGNhc2UgU0lNUExFLk5VTEw6XG4gICAgICAgIGlmIChoYXNfcGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1lNUy5OVUxMXG4gICAgICBjYXNlIFNJTVBMRS5VTkRFRklORUQ6XG4gICAgICAgIGlmIChoYXNfcGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTWU1TLlVOREVGSU5FRFxuICAgICAgY2FzZSAtMTpcbiAgICAgICAgaWYgKCFoYXNfcGFyZW50IHx8ICFwYXJlbnRfaW5kZWZpbml0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBCUkVBSycpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNZTVMuQlJFQUtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlKHZhbClcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/simple.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/lib/tagged.js":
/*!*****************************************!*\
  !*** ./node_modules/cbor/lib/tagged.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/cbor/lib/constants.js\")\nconst utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/cbor/lib/utils.js\")\nconst INTERNAL_JSON = Symbol('INTERNAL_JSON')\n\nfunction setBuffersToJSON(obj, fn) {\n  // The data item tagged can be a byte string or any other data item.  In the\n  // latter case, the tag applies to all of the byte string data items\n  // contained in the data item, except for those contained in a nested data\n  // item tagged with an expected conversion.\n  if (utils.isBufferish(obj)) {\n    obj.toJSON = fn\n  } else if (Array.isArray(obj)) {\n    for (const v of obj) {\n      setBuffersToJSON(v, fn)\n    }\n  } else if (obj && (typeof obj === 'object')) {\n    // FFS, complexity in the protocol.\n\n    // There's some circular dependency in here.\n    // eslint-disable-next-line no-use-before-define\n    if (!(obj instanceof Tagged) || (obj.tag < 21) || (obj.tag > 23)) {\n      for (const v of Object.values(obj)) {\n        setBuffersToJSON(v, fn)\n      }\n    }\n  }\n}\n\nfunction b64this() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64(this)\n}\n\nfunction b64urlThis() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64url(this)\n}\n\nfunction hexThis() {\n  // eslint-disable-next-line no-invalid-this\n  return this.toString('hex')\n}\n\nfunction swapEndian(ab, size, byteOffset, byteLength) {\n  const dv = new DataView(ab)\n  const [getter, setter] = {\n    2: [dv.getUint16, dv.setUint16],\n    4: [dv.getUint32, dv.setUint32],\n    8: [dv.getBigUint64, dv.setBigUint64],\n  }[size]\n\n  const end = byteOffset + byteLength\n  for (let offset = byteOffset; offset < end; offset += size) {\n    setter.call(dv, offset, getter.call(dv, offset, true))\n  }\n}\n\n/**\n * Convert a tagged value to a more interesting JavaScript type.  Errors\n * thrown in this function will be captured into the \"err\" property of the\n * original Tagged instance.\n *\n * @callback TagFunction\n * @param {any} value The value inside the tag.\n * @param {Tagged} tag The enclosing Tagged instance; useful if you want to\n *   modify it and return it.  Also available as \"this\".\n * @returns {any} The transformed value.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, TagFunction>} TagMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {TagMap}\n * @private\n */\nconst TAGS = {\n  // Standard date/time string; see Section 3.4.1\n  0: v => new Date(v),\n  // Epoch-based date/time; see Section 3.4.2\n  1: v => new Date(v * 1000),\n  // Positive bignum; see Section 3.4.3\n  2: v => utils.bufferToBigInt(v),\n  // Negative bignum; see Section 3.4.3\n  3: v => constants.BI.MINUS_ONE - utils.bufferToBigInt(v),\n  // Expected conversion to base64url encoding; see Section 3.4.5.2\n  21: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64urlThis\n    } else {\n      setBuffersToJSON(v, b64urlThis)\n    }\n    return tag\n  },\n  // Expected conversion to base64 encoding; see Section 3.4.5.2\n  22: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64this\n    } else {\n      setBuffersToJSON(v, b64this)\n    }\n    return tag\n  },\n  // Expected conversion to base16 encoding; see Section Section 3.4.5.2\n  23: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = hexThis\n    } else {\n      setBuffersToJSON(v, hexThis)\n    }\n    return tag\n  },\n  // URI; see Section 3.4.5.3\n  32: v => new URL(v),\n  // Base64url; see Section 3.4.5.3\n  33: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {\n      throw new Error('Invalid base64url characters')\n    }\n    const last = v.length % 4\n    if (last === 1) {\n      throw new Error('Invalid base64url length')\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (last === 2) {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    } else if (last === 3) {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    }\n\n    //    Or\n    // -  the base64url encoding has padding characters,\n    // (caught above)\n\n    // the string is invalid.\n    return tag\n  },\n  // Base64; see Section 3.4.5.3\n  34: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    const m = v.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/)\n    if (!m) {\n      throw new Error('Invalid base64 characters')\n    }\n    if ((v.length % 4) !== 0) {\n      throw new Error('Invalid base64 length')\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (m.groups.padding === '=') {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    } else if (m.groups.padding === '==') {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    }\n\n    // -  the base64 encoding has the wrong number of padding characters,\n    // (caught above)\n    // the string is invalid.\n    return tag\n  },\n  // Regular expression; see Section 2.4.4.3\n  35: v => new RegExp(v),\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  258: v => new Set(v),\n}\n\nconst TYPED_ARRAY_TAGS = {\n  64: Uint8Array,\n  65: Uint16Array,\n  66: Uint32Array,\n  // 67: BigUint64Array,  Safari doesn't implement\n  68: Uint8ClampedArray,\n  69: Uint16Array,\n  70: Uint32Array,\n  // 71: BigUint64Array,  Safari doesn't implement\n  72: Int8Array,\n  73: Int16Array,\n  74: Int32Array,\n  // 75: BigInt64Array,  Safari doesn't implement\n  // 76: reserved\n  77: Int16Array,\n  78: Int32Array,\n  // 79: BigInt64Array,  Safari doesn't implement\n  // 80: not implemented, float16 array\n  81: Float32Array,\n  82: Float64Array,\n  // 83: not implemented, float128 array\n  // 84: not implemented, float16 array\n  85: Float32Array,\n  86: Float64Array,\n  // 87: not implemented, float128 array\n}\n\n// Safari\nif (typeof BigUint64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[67] = BigUint64Array\n  TYPED_ARRAY_TAGS[71] = BigUint64Array\n}\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[75] = BigInt64Array\n  TYPED_ARRAY_TAGS[79] = BigInt64Array\n}\n\nfunction _toTypedArray(val, tagged) {\n  if (!utils.isBufferish(val)) {\n    throw new TypeError('val not a buffer')\n  }\n  const {tag} = tagged\n  // See https://tools.ietf.org/html/rfc8746\n  const TypedClass = TYPED_ARRAY_TAGS[tag]\n  if (!TypedClass) {\n    throw new Error(`Invalid typed array tag: ${tag}`)\n  }\n  const little = tag & 0b00000100\n  const float = (tag & 0b00010000) >> 4\n  const sz = 2 ** (float + (tag & 0b00000011))\n\n  if ((!little !== utils.isBigEndian()) && (sz > 1)) {\n    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength)\n  }\n\n  const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength)\n  return new TypedClass(ab)\n}\n\nfor (const n of Object.keys(TYPED_ARRAY_TAGS)) {\n  TAGS[n] = _toTypedArray\n}\n\n/**\n * @type {TagMap}\n * @private\n */\nlet current_TAGS = {}\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag The number of the tag.\n   * @param {any} value The value inside the tag.\n   * @param {Error} [err] The error that was thrown parsing the tag, or null.\n   */\n  constructor(tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error(`Invalid tag type (${typeof this.tag})`)\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error(`Tag must be a positive integer: ${this.tag}`)\n    }\n  }\n\n  toJSON() {\n    if (this[INTERNAL_JSON]) {\n      return this[INTERNAL_JSON].call(this.value)\n    }\n    const ret = {\n      tag: this.tag,\n      value: this.value,\n    }\n    if (this.err) {\n      ret.err = this.err\n    }\n    return ret\n  }\n\n  /**\n   * Convert to a String.\n   *\n   * @returns {string} String of the form '1(2)'.\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {object} converters Keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} The converted item.\n   */\n  convert(converters) {\n    let f = (converters == null) ? undefined : converters[this.tag]\n    if (f === null) { // === is intentional. null has semantic meaning as above\n      return this\n    }\n    if (typeof f !== 'function') {\n      f = Tagged.TAGS[this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(this, this.value, this)\n    } catch (error) {\n      if (error && error.message && (error.message.length > 0)) {\n        this.err = error.message\n      } else {\n        this.err = error\n      }\n      return this\n    }\n  }\n\n  /**\n   * The current set of supported tags.  May be modified by plugins.\n   *\n   * @type {TagMap}\n   * @static\n   */\n  static get TAGS() {\n    return current_TAGS\n  }\n\n  static set TAGS(val) {\n    current_TAGS = val\n  }\n\n  /**\n   * Reset the supported tags to the original set, before any plugins modified\n   * the list.\n   */\n  static reset() {\n    Tagged.TAGS = {...TAGS}\n  }\n}\nTagged.INTERNAL_JSON = INTERNAL_JSON\nTagged.reset()\nmodule.exports = Tagged\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvdGFnZ2VkLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQixtQkFBTyxDQUFDLCtEQUFhO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyx1REFBUztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsUUFBUSxtQ0FBbUM7QUFDdEQ7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhCQUE4QjtBQUMzQztBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVU7QUFDVjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGNBQWMsU0FBUyxHQUFHLDJCQUEyQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0LWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yL2xpYi90YWdnZWQuanM/YzUxYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IElOVEVSTkFMX0pTT04gPSBTeW1ib2woJ0lOVEVSTkFMX0pTT04nKVxuXG5mdW5jdGlvbiBzZXRCdWZmZXJzVG9KU09OKG9iaiwgZm4pIHtcbiAgLy8gVGhlIGRhdGEgaXRlbSB0YWdnZWQgY2FuIGJlIGEgYnl0ZSBzdHJpbmcgb3IgYW55IG90aGVyIGRhdGEgaXRlbS4gIEluIHRoZVxuICAvLyBsYXR0ZXIgY2FzZSwgdGhlIHRhZyBhcHBsaWVzIHRvIGFsbCBvZiB0aGUgYnl0ZSBzdHJpbmcgZGF0YSBpdGVtc1xuICAvLyBjb250YWluZWQgaW4gdGhlIGRhdGEgaXRlbSwgZXhjZXB0IGZvciB0aG9zZSBjb250YWluZWQgaW4gYSBuZXN0ZWQgZGF0YVxuICAvLyBpdGVtIHRhZ2dlZCB3aXRoIGFuIGV4cGVjdGVkIGNvbnZlcnNpb24uXG4gIGlmICh1dGlscy5pc0J1ZmZlcmlzaChvYmopKSB7XG4gICAgb2JqLnRvSlNPTiA9IGZuXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgZm9yIChjb25zdCB2IG9mIG9iaikge1xuICAgICAgc2V0QnVmZmVyc1RvSlNPTih2LCBmbilcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JykpIHtcbiAgICAvLyBGRlMsIGNvbXBsZXhpdHkgaW4gdGhlIHByb3RvY29sLlxuXG4gICAgLy8gVGhlcmUncyBzb21lIGNpcmN1bGFyIGRlcGVuZGVuY3kgaW4gaGVyZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBUYWdnZWQpIHx8IChvYmoudGFnIDwgMjEpIHx8IChvYmoudGFnID4gMjMpKSB7XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgT2JqZWN0LnZhbHVlcyhvYmopKSB7XG4gICAgICAgIHNldEJ1ZmZlcnNUb0pTT04odiwgZm4pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGI2NHRoaXMoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pbnZhbGlkLXRoaXNcbiAgcmV0dXJuIHV0aWxzLmJhc2U2NCh0aGlzKVxufVxuXG5mdW5jdGlvbiBiNjR1cmxUaGlzKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW52YWxpZC10aGlzXG4gIHJldHVybiB1dGlscy5iYXNlNjR1cmwodGhpcylcbn1cblxuZnVuY3Rpb24gaGV4VGhpcygpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWludmFsaWQtdGhpc1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnaGV4Jylcbn1cblxuZnVuY3Rpb24gc3dhcEVuZGlhbihhYiwgc2l6ZSwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhhYilcbiAgY29uc3QgW2dldHRlciwgc2V0dGVyXSA9IHtcbiAgICAyOiBbZHYuZ2V0VWludDE2LCBkdi5zZXRVaW50MTZdLFxuICAgIDQ6IFtkdi5nZXRVaW50MzIsIGR2LnNldFVpbnQzMl0sXG4gICAgODogW2R2LmdldEJpZ1VpbnQ2NCwgZHYuc2V0QmlnVWludDY0XSxcbiAgfVtzaXplXVxuXG4gIGNvbnN0IGVuZCA9IGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoXG4gIGZvciAobGV0IG9mZnNldCA9IGJ5dGVPZmZzZXQ7IG9mZnNldCA8IGVuZDsgb2Zmc2V0ICs9IHNpemUpIHtcbiAgICBzZXR0ZXIuY2FsbChkdiwgb2Zmc2V0LCBnZXR0ZXIuY2FsbChkdiwgb2Zmc2V0LCB0cnVlKSlcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB0YWdnZWQgdmFsdWUgdG8gYSBtb3JlIGludGVyZXN0aW5nIEphdmFTY3JpcHQgdHlwZS4gIEVycm9yc1xuICogdGhyb3duIGluIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYXB0dXJlZCBpbnRvIHRoZSBcImVyclwiIHByb3BlcnR5IG9mIHRoZVxuICogb3JpZ2luYWwgVGFnZ2VkIGluc3RhbmNlLlxuICpcbiAqIEBjYWxsYmFjayBUYWdGdW5jdGlvblxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSBpbnNpZGUgdGhlIHRhZy5cbiAqIEBwYXJhbSB7VGFnZ2VkfSB0YWcgVGhlIGVuY2xvc2luZyBUYWdnZWQgaW5zdGFuY2U7IHVzZWZ1bCBpZiB5b3Ugd2FudCB0b1xuICogICBtb2RpZnkgaXQgYW5kIHJldHVybiBpdC4gIEFsc28gYXZhaWxhYmxlIGFzIFwidGhpc1wiLlxuICogQHJldHVybnMge2FueX0gVGhlIHRyYW5zZm9ybWVkIHZhbHVlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGpzZG9jL2NoZWNrLXR5cGVzICovXG4vKipcbiAqIEEgbWFwcGluZyBmcm9tIHRhZyBudW1iZXIgdG8gYSB0YWcgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKlxuICogQHR5cGVkZWYge09iamVjdC48c3RyaW5nLCBUYWdGdW5jdGlvbj59IFRhZ01hcFxuICovXG4vKiBlc2xpbnQtZW5hYmxlIGpzZG9jL2NoZWNrLXR5cGVzICovXG5cbi8qKlxuICogQHR5cGUge1RhZ01hcH1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IFRBR1MgPSB7XG4gIC8vIFN0YW5kYXJkIGRhdGUvdGltZSBzdHJpbmc7IHNlZSBTZWN0aW9uIDMuNC4xXG4gIDA6IHYgPT4gbmV3IERhdGUodiksXG4gIC8vIEVwb2NoLWJhc2VkIGRhdGUvdGltZTsgc2VlIFNlY3Rpb24gMy40LjJcbiAgMTogdiA9PiBuZXcgRGF0ZSh2ICogMTAwMCksXG4gIC8vIFBvc2l0aXZlIGJpZ251bTsgc2VlIFNlY3Rpb24gMy40LjNcbiAgMjogdiA9PiB1dGlscy5idWZmZXJUb0JpZ0ludCh2KSxcbiAgLy8gTmVnYXRpdmUgYmlnbnVtOyBzZWUgU2VjdGlvbiAzLjQuM1xuICAzOiB2ID0+IGNvbnN0YW50cy5CSS5NSU5VU19PTkUgLSB1dGlscy5idWZmZXJUb0JpZ0ludCh2KSxcbiAgLy8gRXhwZWN0ZWQgY29udmVyc2lvbiB0byBiYXNlNjR1cmwgZW5jb2Rpbmc7IHNlZSBTZWN0aW9uIDMuNC41LjJcbiAgMjE6ICh2LCB0YWcpID0+IHtcbiAgICBpZiAodXRpbHMuaXNCdWZmZXJpc2godikpIHtcbiAgICAgIHRhZ1tJTlRFUk5BTF9KU09OXSA9IGI2NHVybFRoaXNcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0QnVmZmVyc1RvSlNPTih2LCBiNjR1cmxUaGlzKVxuICAgIH1cbiAgICByZXR1cm4gdGFnXG4gIH0sXG4gIC8vIEV4cGVjdGVkIGNvbnZlcnNpb24gdG8gYmFzZTY0IGVuY29kaW5nOyBzZWUgU2VjdGlvbiAzLjQuNS4yXG4gIDIyOiAodiwgdGFnKSA9PiB7XG4gICAgaWYgKHV0aWxzLmlzQnVmZmVyaXNoKHYpKSB7XG4gICAgICB0YWdbSU5URVJOQUxfSlNPTl0gPSBiNjR0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEJ1ZmZlcnNUb0pTT04odiwgYjY0dGhpcylcbiAgICB9XG4gICAgcmV0dXJuIHRhZ1xuICB9LFxuICAvLyBFeHBlY3RlZCBjb252ZXJzaW9uIHRvIGJhc2UxNiBlbmNvZGluZzsgc2VlIFNlY3Rpb24gU2VjdGlvbiAzLjQuNS4yXG4gIDIzOiAodiwgdGFnKSA9PiB7XG4gICAgaWYgKHV0aWxzLmlzQnVmZmVyaXNoKHYpKSB7XG4gICAgICB0YWdbSU5URVJOQUxfSlNPTl0gPSBoZXhUaGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEJ1ZmZlcnNUb0pTT04odiwgaGV4VGhpcylcbiAgICB9XG4gICAgcmV0dXJuIHRhZ1xuICB9LFxuICAvLyBVUkk7IHNlZSBTZWN0aW9uIDMuNC41LjNcbiAgMzI6IHYgPT4gbmV3IFVSTCh2KSxcbiAgLy8gQmFzZTY0dXJsOyBzZWUgU2VjdGlvbiAzLjQuNS4zXG4gIDMzOiAodiwgdGFnKSA9PiB7XG4gICAgLy8gSWYgYW55IG9mIHRoZSBmb2xsb3dpbmcgYXBwbHk6XG4gICAgLy8gLSAgdGhlIGVuY29kZWQgdGV4dCBzdHJpbmcgY29udGFpbnMgbm9uLWFscGhhYmV0IGNoYXJhY3RlcnMgb3JcbiAgICAvLyAgICBvbmx5IDEgYWxwaGFiZXQgY2hhcmFjdGVyIGluIHRoZSBsYXN0IGJsb2NrIG9mIDQgKHdoZXJlXG4gICAgLy8gICAgYWxwaGFiZXQgaXMgZGVmaW5lZCBieSBTZWN0aW9uIDUgb2YgW1JGQzQ2NDhdIGZvciB0YWcgbnVtYmVyIDMzXG4gICAgLy8gICAgYW5kIFNlY3Rpb24gNCBvZiBbUkZDNDY0OF0gZm9yIHRhZyBudW1iZXIgMzQpLCBvclxuICAgIGlmICghdi5tYXRjaCgvXlthLXpBLVowLTlfLV0rJC8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmFzZTY0dXJsIGNoYXJhY3RlcnMnKVxuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gdi5sZW5ndGggJSA0XG4gICAgaWYgKGxhc3QgPT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYXNlNjR1cmwgbGVuZ3RoJylcbiAgICB9XG4gICAgLy8gLSAgdGhlIHBhZGRpbmcgYml0cyBpbiBhIDItIG9yIDMtY2hhcmFjdGVyIGJsb2NrIGFyZSBub3QgMCwgb3JcbiAgICBpZiAobGFzdCA9PT0gMikge1xuICAgICAgLy8gVGhlIGxhc3QgNCBiaXRzIG9mIHRoZSBsYXN0IGNoYXJhY3RlciBuZWVkIHRvIGJlIHplcm8uXG4gICAgICBpZiAoJ0FRZ3cnLmluZGV4T2Yodlt2Lmxlbmd0aCAtIDFdKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJhc2U2NCBwYWRkaW5nJylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09IDMpIHtcbiAgICAgIC8vIFRoZSBsYXN0IDIgYml0cyBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgbmVlZCB0byBiZSB6ZXJvLlxuICAgICAgaWYgKCdBRUlNUVVZY2drb3N3MDQ4Jy5pbmRleE9mKHZbdi5sZW5ndGggLSAxXSkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYXNlNjQgcGFkZGluZycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gICAgT3JcbiAgICAvLyAtICB0aGUgYmFzZTY0dXJsIGVuY29kaW5nIGhhcyBwYWRkaW5nIGNoYXJhY3RlcnMsXG4gICAgLy8gKGNhdWdodCBhYm92ZSlcblxuICAgIC8vIHRoZSBzdHJpbmcgaXMgaW52YWxpZC5cbiAgICByZXR1cm4gdGFnXG4gIH0sXG4gIC8vIEJhc2U2NDsgc2VlIFNlY3Rpb24gMy40LjUuM1xuICAzNDogKHYsIHRhZykgPT4ge1xuICAgIC8vIElmIGFueSBvZiB0aGUgZm9sbG93aW5nIGFwcGx5OlxuICAgIC8vIC0gIHRoZSBlbmNvZGVkIHRleHQgc3RyaW5nIGNvbnRhaW5zIG5vbi1hbHBoYWJldCBjaGFyYWN0ZXJzIG9yXG4gICAgLy8gICAgb25seSAxIGFscGhhYmV0IGNoYXJhY3RlciBpbiB0aGUgbGFzdCBibG9jayBvZiA0ICh3aGVyZVxuICAgIC8vICAgIGFscGhhYmV0IGlzIGRlZmluZWQgYnkgU2VjdGlvbiA1IG9mIFtSRkM0NjQ4XSBmb3IgdGFnIG51bWJlciAzM1xuICAgIC8vICAgIGFuZCBTZWN0aW9uIDQgb2YgW1JGQzQ2NDhdIGZvciB0YWcgbnVtYmVyIDM0KSwgb3JcbiAgICBjb25zdCBtID0gdi5tYXRjaCgvXlthLXpBLVowLTkrL10rKD88cGFkZGluZz49ezAsMn0pJC8pXG4gICAgaWYgKCFtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmFzZTY0IGNoYXJhY3RlcnMnKVxuICAgIH1cbiAgICBpZiAoKHYubGVuZ3RoICUgNCkgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYXNlNjQgbGVuZ3RoJylcbiAgICB9XG4gICAgLy8gLSAgdGhlIHBhZGRpbmcgYml0cyBpbiBhIDItIG9yIDMtY2hhcmFjdGVyIGJsb2NrIGFyZSBub3QgMCwgb3JcbiAgICBpZiAobS5ncm91cHMucGFkZGluZyA9PT0gJz0nKSB7XG4gICAgICAvLyBUaGUgbGFzdCA0IGJpdHMgb2YgdGhlIGxhc3QgY2hhcmFjdGVyIG5lZWQgdG8gYmUgemVyby5cbiAgICAgIGlmICgnQVFndycuaW5kZXhPZih2W3YubGVuZ3RoIC0gMl0pID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmFzZTY0IHBhZGRpbmcnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobS5ncm91cHMucGFkZGluZyA9PT0gJz09Jykge1xuICAgICAgLy8gVGhlIGxhc3QgMiBiaXRzIG9mIHRoZSBsYXN0IGNoYXJhY3RlciBuZWVkIHRvIGJlIHplcm8uXG4gICAgICBpZiAoJ0FFSU1RVVljZ2tvc3cwNDgnLmluZGV4T2Yodlt2Lmxlbmd0aCAtIDNdKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJhc2U2NCBwYWRkaW5nJylcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAtICB0aGUgYmFzZTY0IGVuY29kaW5nIGhhcyB0aGUgd3JvbmcgbnVtYmVyIG9mIHBhZGRpbmcgY2hhcmFjdGVycyxcbiAgICAvLyAoY2F1Z2h0IGFib3ZlKVxuICAgIC8vIHRoZSBzdHJpbmcgaXMgaW52YWxpZC5cbiAgICByZXR1cm4gdGFnXG4gIH0sXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbjsgc2VlIFNlY3Rpb24gMi40LjQuM1xuICAzNTogdiA9PiBuZXcgUmVnRXhwKHYpLFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vaW5wdXQtb3V0cHV0LWhrL2Nib3Itc2V0cy1zcGVjL2Jsb2IvbWFzdGVyL0NCT1JfU0VUUy5tZFxuICAyNTg6IHYgPT4gbmV3IFNldCh2KSxcbn1cblxuY29uc3QgVFlQRURfQVJSQVlfVEFHUyA9IHtcbiAgNjQ6IFVpbnQ4QXJyYXksXG4gIDY1OiBVaW50MTZBcnJheSxcbiAgNjY6IFVpbnQzMkFycmF5LFxuICAvLyA2NzogQmlnVWludDY0QXJyYXksICBTYWZhcmkgZG9lc24ndCBpbXBsZW1lbnRcbiAgNjg6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuICA2OTogVWludDE2QXJyYXksXG4gIDcwOiBVaW50MzJBcnJheSxcbiAgLy8gNzE6IEJpZ1VpbnQ2NEFycmF5LCAgU2FmYXJpIGRvZXNuJ3QgaW1wbGVtZW50XG4gIDcyOiBJbnQ4QXJyYXksXG4gIDczOiBJbnQxNkFycmF5LFxuICA3NDogSW50MzJBcnJheSxcbiAgLy8gNzU6IEJpZ0ludDY0QXJyYXksICBTYWZhcmkgZG9lc24ndCBpbXBsZW1lbnRcbiAgLy8gNzY6IHJlc2VydmVkXG4gIDc3OiBJbnQxNkFycmF5LFxuICA3ODogSW50MzJBcnJheSxcbiAgLy8gNzk6IEJpZ0ludDY0QXJyYXksICBTYWZhcmkgZG9lc24ndCBpbXBsZW1lbnRcbiAgLy8gODA6IG5vdCBpbXBsZW1lbnRlZCwgZmxvYXQxNiBhcnJheVxuICA4MTogRmxvYXQzMkFycmF5LFxuICA4MjogRmxvYXQ2NEFycmF5LFxuICAvLyA4Mzogbm90IGltcGxlbWVudGVkLCBmbG9hdDEyOCBhcnJheVxuICAvLyA4NDogbm90IGltcGxlbWVudGVkLCBmbG9hdDE2IGFycmF5XG4gIDg1OiBGbG9hdDMyQXJyYXksXG4gIDg2OiBGbG9hdDY0QXJyYXksXG4gIC8vIDg3OiBub3QgaW1wbGVtZW50ZWQsIGZsb2F0MTI4IGFycmF5XG59XG5cbi8vIFNhZmFyaVxuaWYgKHR5cGVvZiBCaWdVaW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgVFlQRURfQVJSQVlfVEFHU1s2N10gPSBCaWdVaW50NjRBcnJheVxuICBUWVBFRF9BUlJBWV9UQUdTWzcxXSA9IEJpZ1VpbnQ2NEFycmF5XG59XG5pZiAodHlwZW9mIEJpZ0ludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gIFRZUEVEX0FSUkFZX1RBR1NbNzVdID0gQmlnSW50NjRBcnJheVxuICBUWVBFRF9BUlJBWV9UQUdTWzc5XSA9IEJpZ0ludDY0QXJyYXlcbn1cblxuZnVuY3Rpb24gX3RvVHlwZWRBcnJheSh2YWwsIHRhZ2dlZCkge1xuICBpZiAoIXV0aWxzLmlzQnVmZmVyaXNoKHZhbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbm90IGEgYnVmZmVyJylcbiAgfVxuICBjb25zdCB7dGFnfSA9IHRhZ2dlZFxuICAvLyBTZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzg3NDZcbiAgY29uc3QgVHlwZWRDbGFzcyA9IFRZUEVEX0FSUkFZX1RBR1NbdGFnXVxuICBpZiAoIVR5cGVkQ2xhc3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHlwZWQgYXJyYXkgdGFnOiAke3RhZ31gKVxuICB9XG4gIGNvbnN0IGxpdHRsZSA9IHRhZyAmIDBiMDAwMDAxMDBcbiAgY29uc3QgZmxvYXQgPSAodGFnICYgMGIwMDAxMDAwMCkgPj4gNFxuICBjb25zdCBzeiA9IDIgKiogKGZsb2F0ICsgKHRhZyAmIDBiMDAwMDAwMTEpKVxuXG4gIGlmICgoIWxpdHRsZSAhPT0gdXRpbHMuaXNCaWdFbmRpYW4oKSkgJiYgKHN6ID4gMSkpIHtcbiAgICBzd2FwRW5kaWFuKHZhbC5idWZmZXIsIHN6LCB2YWwuYnl0ZU9mZnNldCwgdmFsLmJ5dGVMZW5ndGgpXG4gIH1cblxuICBjb25zdCBhYiA9IHZhbC5idWZmZXIuc2xpY2UodmFsLmJ5dGVPZmZzZXQsIHZhbC5ieXRlT2Zmc2V0ICsgdmFsLmJ5dGVMZW5ndGgpXG4gIHJldHVybiBuZXcgVHlwZWRDbGFzcyhhYilcbn1cblxuZm9yIChjb25zdCBuIG9mIE9iamVjdC5rZXlzKFRZUEVEX0FSUkFZX1RBR1MpKSB7XG4gIFRBR1Nbbl0gPSBfdG9UeXBlZEFycmF5XG59XG5cbi8qKlxuICogQHR5cGUge1RhZ01hcH1cbiAqIEBwcml2YXRlXG4gKi9cbmxldCBjdXJyZW50X1RBR1MgPSB7fVxuXG4vKipcbiAqIEEgQ0JPUiB0YWdnZWQgaXRlbSwgd2hlcmUgdGhlIHRhZyBkb2VzIG5vdCBoYXZlIHNlbWFudGljcyBzcGVjaWZpZWQgYXQgdGhlXG4gKiBtb21lbnQsIG9yIHRob3NlIHNlbWFudGljcyB0aHJldyBhbiBlcnJvciBkdXJpbmcgcGFyc2luZy4gVHlwaWNhbGx5IHRoaXMgd2lsbFxuICogYmUgYW4gZXh0ZW5zaW9uIHBvaW50IHlvdSdyZSBub3QgeWV0IGV4cGVjdGluZy5cbiAqL1xuY2xhc3MgVGFnZ2VkIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVGFnZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGFnIFRoZSBudW1iZXIgb2YgdGhlIHRhZy5cbiAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSBpbnNpZGUgdGhlIHRhZy5cbiAgICogQHBhcmFtIHtFcnJvcn0gW2Vycl0gVGhlIGVycm9yIHRoYXQgd2FzIHRocm93biBwYXJzaW5nIHRoZSB0YWcsIG9yIG51bGwuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0YWcsIHZhbHVlLCBlcnIpIHtcbiAgICB0aGlzLnRhZyA9IHRhZ1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuZXJyID0gZXJyXG4gICAgaWYgKHR5cGVvZiB0aGlzLnRhZyAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0YWcgdHlwZSAoJHt0eXBlb2YgdGhpcy50YWd9KWApXG4gICAgfVxuICAgIGlmICgodGhpcy50YWcgPCAwKSB8fCAoKHRoaXMudGFnIHwgMCkgIT09IHRoaXMudGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXI6ICR7dGhpcy50YWd9YClcbiAgICB9XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgaWYgKHRoaXNbSU5URVJOQUxfSlNPTl0pIHtcbiAgICAgIHJldHVybiB0aGlzW0lOVEVSTkFMX0pTT05dLmNhbGwodGhpcy52YWx1ZSlcbiAgICB9XG4gICAgY29uc3QgcmV0ID0ge1xuICAgICAgdGFnOiB0aGlzLnRhZyxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgIH1cbiAgICBpZiAodGhpcy5lcnIpIHtcbiAgICAgIHJldC5lcnIgPSB0aGlzLmVyclxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0byBhIFN0cmluZy5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIG9mIHRoZSBmb3JtICcxKDIpJy5cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgJHt0aGlzLnRhZ30oJHtKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlKX0pYFxuICB9XG5cbiAgLyoqXG4gICAqIFB1c2ggdGhlIHNpbXBsZSB2YWx1ZSBvbnRvIHRoZSBDQk9SIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGdlbiBUaGUgZ2VuZXJhdG9yIHRvIHB1c2ggb250by5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICovXG4gIGVuY29kZUNCT1IoZ2VuKSB7XG4gICAgZ2VuLl9wdXNoVGFnKHRoaXMudGFnKVxuICAgIHJldHVybiBnZW4ucHVzaEFueSh0aGlzLnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIElmIHdlIGhhdmUgYSBjb252ZXJ0ZXIgZm9yIHRoaXMgdHlwZSwgZG8gdGhlIGNvbnZlcnNpb24uICBTb21lIGNvbnZlcnRlcnNcbiAgICogYXJlIGJ1aWx0LWluLiAgQWRkaXRpb25hbCBvbmVzIGNhbiBiZSBwYXNzZWQgaW4uICBJZiB5b3Ugd2FudCB0byByZW1vdmVcbiAgICogYSBidWlsdC1pbiBjb252ZXJ0ZXIsIHBhc3MgYSBjb252ZXJ0ZXIgaW4gd2hvc2UgdmFsdWUgaXMgJ251bGwnIGluc3RlYWRcbiAgICogb2YgYSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnZlcnRlcnMgS2V5cyBpbiB0aGUgb2JqZWN0IGFyZSBhIHRhZyBudW1iZXIsIHRoZSB2YWx1ZVxuICAgKiAgIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgZGVjb2RlZCBDQk9SIGFuZCByZXR1cm5zIGEgSmF2YVNjcmlwdCB2YWx1ZVxuICAgKiAgIG9mIHRoZSBhcHByb3ByaWF0ZSB0eXBlLiAgVGhyb3cgYW4gZXhjZXB0aW9uIGluIHRoZSBmdW5jdGlvbiBvbiBlcnJvcnMuXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjb252ZXJ0ZWQgaXRlbS5cbiAgICovXG4gIGNvbnZlcnQoY29udmVydGVycykge1xuICAgIGxldCBmID0gKGNvbnZlcnRlcnMgPT0gbnVsbCkgPyB1bmRlZmluZWQgOiBjb252ZXJ0ZXJzW3RoaXMudGFnXVxuICAgIGlmIChmID09PSBudWxsKSB7IC8vID09PSBpcyBpbnRlbnRpb25hbC4gbnVsbCBoYXMgc2VtYW50aWMgbWVhbmluZyBhcyBhYm92ZVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmID0gVGFnZ2VkLlRBR1NbdGhpcy50YWddXG4gICAgICBpZiAodHlwZW9mIGYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmLmNhbGwodGhpcywgdGhpcy52YWx1ZSwgdGhpcylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yICYmIGVycm9yLm1lc3NhZ2UgJiYgKGVycm9yLm1lc3NhZ2UubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgdGhpcy5lcnIgPSBlcnJvci5tZXNzYWdlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVyciA9IGVycm9yXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzZXQgb2Ygc3VwcG9ydGVkIHRhZ3MuICBNYXkgYmUgbW9kaWZpZWQgYnkgcGx1Z2lucy5cbiAgICpcbiAgICogQHR5cGUge1RhZ01hcH1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgc3RhdGljIGdldCBUQUdTKCkge1xuICAgIHJldHVybiBjdXJyZW50X1RBR1NcbiAgfVxuXG4gIHN0YXRpYyBzZXQgVEFHUyh2YWwpIHtcbiAgICBjdXJyZW50X1RBR1MgPSB2YWxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgc3VwcG9ydGVkIHRhZ3MgdG8gdGhlIG9yaWdpbmFsIHNldCwgYmVmb3JlIGFueSBwbHVnaW5zIG1vZGlmaWVkXG4gICAqIHRoZSBsaXN0LlxuICAgKi9cbiAgc3RhdGljIHJlc2V0KCkge1xuICAgIFRhZ2dlZC5UQUdTID0gey4uLlRBR1N9XG4gIH1cbn1cblRhZ2dlZC5JTlRFUk5BTF9KU09OID0gSU5URVJOQUxfSlNPTlxuVGFnZ2VkLnJlc2V0KClcbm1vZHVsZS5leHBvcnRzID0gVGFnZ2VkXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/tagged.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/lib/utils.js":
/*!****************************************!*\
  !*** ./node_modules/cbor/lib/utils.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nconst {Buffer} = __webpack_require__(/*! buffer */ \"buffer\")\nconst NoFilter = __webpack_require__(/*! nofilter */ \"(ssr)/./node_modules/nofilter/lib/index.js\")\nconst stream = __webpack_require__(/*! stream */ \"stream\")\nconst constants = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/cbor/lib/constants.js\")\nconst {NUMBYTES, SHIFT32, BI, SYMS} = constants\nconst MAX_SAFE_HIGH = 0x1fffff\n\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n *\n * @private\n */\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})\nexports.utf8 = buf => td.decode(buf)\nexports.utf8.checksUTF8 = true\n\nfunction isReadable(s) {\n  // Is this a readable stream?  In the webpack version, instanceof isn't\n  // working correctly.\n  if (s instanceof stream.Readable) {\n    return true\n  }\n  return ['read', 'on', 'pipe'].every(f => typeof s[f] === 'function')\n}\n\nexports.isBufferish = function isBufferish(b) {\n  return b &&\n    (typeof b === 'object') &&\n    ((Buffer.isBuffer(b)) ||\n      (b instanceof Uint8Array) ||\n      (b instanceof Uint8ClampedArray) ||\n      (b instanceof ArrayBuffer) ||\n      (b instanceof DataView))\n}\n\nexports.bufferishToBuffer = function bufferishToBuffer(b) {\n  if (Buffer.isBuffer(b)) {\n    return b\n  } else if (ArrayBuffer.isView(b)) {\n    return Buffer.from(b.buffer, b.byteOffset, b.byteLength)\n  } else if (b instanceof ArrayBuffer) {\n    return Buffer.from(b)\n  }\n  return null\n}\n\nexports.parseCBORint = function parseCBORint(ai, buf) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0)\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0)\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0)\n    case NUMBYTES.EIGHT: {\n      const f = buf.readUInt32BE(0)\n      const g = buf.readUInt32BE(4)\n      if (f > MAX_SAFE_HIGH) {\n        return (BigInt(f) * BI.SHIFT32) + BigInt(g)\n      }\n      return (f * SHIFT32) + g\n    }\n    default:\n      throw new Error(`Invalid additional info for int: ${ai}`)\n  }\n}\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // Assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4)\n  u32.writeFloatBE(half, 0)\n  const u = u32.readUInt32BE(0)\n\n  // If ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits aren't 0,\n  // we will lose precision in the conversion.\n  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13\n  if ((u & 0x1FFF) !== 0) {\n    return false\n  }\n\n  // Sign, exponent, mantissa\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  let s16 = (u >> 16) & 0x8000 // Top bit is sign\n  const exp = (u >> 23) & 0xff // Then 5 bits of exponent\n  const mant = u & 0x7fffff\n\n  // Hildjj: zeros already handled.  Assert if you don't believe me.\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13)\n  } else if ((exp >= 103) && (exp < 113)) {\n    // Denormalized numbers\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp))\n  } else {\n  //   } else if (exp == 255 && mant == 0) { /* Inf */\n  //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n    //   } else\n    //     goto float32;           /* loss of range */\n\n    return false\n  }\n\n  // Done\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16)\n  return true\n}\n\nexports.parseHalf = function parseHalf(buf) {\n  const sign = buf[0] & 0x80 ? -1 : 1\n  const exp = (buf[0] & 0x7C) >> 2\n  const mant = ((buf[0] & 0x03) << 8) | buf[1]\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant\n  } else if (exp === 0x1f) {\n    return sign * (mant ? NaN : Infinity)\n  }\n  return sign * (2 ** (exp - 25)) * (1024 + mant)\n}\n\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf)\n    case 4:\n      return buf.readFloatBE(0)\n    case 8:\n      return buf.readDoubleBE(0)\n    default:\n      throw new Error(`Invalid float size: ${buf.length}`)\n  }\n}\n\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex')\n}\n\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '')\n  let start = 0\n  let end = (s.length % 8) || 8\n  const chunks = []\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2))\n    start = end\n    end += 8\n  }\n  return Buffer.from(chunks)\n}\n\nexports.arrayEqual = function arrayEqual(a, b) {\n  if ((a == null) && (b == null)) {\n    return true\n  }\n  if ((a == null) || (b == null)) {\n    return false\n  }\n  return (a.length === b.length) && a.every((elem, i) => elem === b[i])\n}\n\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return BigInt(`0x${buf.toString('hex')}`)\n}\n\nexports.cborValueToString = function cborValueToString(val, float_bytes = -1) {\n  switch (typeof val) {\n    case 'symbol': {\n      switch (val) {\n        case SYMS.NULL:\n          return 'null'\n        case SYMS.UNDEFINED:\n          return 'undefined'\n        case SYMS.BREAK:\n          return 'BREAK'\n      }\n      // Impossible in node 10\n      /* istanbul ignore if */\n      if (val.description) {\n        return val.description\n      }\n      // On node10, Symbol doesn't have description.  Parse it out of the\n      // toString value, which looks like `Symbol(foo)`.\n      const s = val.toString()\n      const m = s.match(/^Symbol\\((?<name>.*)\\)/)\n      /* istanbul ignore if */\n      if (m && m.groups.name) {\n        // Impossible in node 12+\n        /* istanbul ignore next */\n        return m.groups.name\n      }\n      return 'Symbol'\n    }\n    case 'string':\n      return JSON.stringify(val)\n    case 'bigint':\n      return val.toString()\n    case 'number': {\n      const s = Object.is(val, -0) ? '-0' : String(val)\n      return (float_bytes > 0) ? `${s}_${float_bytes}` : s\n    }\n    case 'object': {\n      // A null should be caught above\n      const buf = exports.bufferishToBuffer(val)\n      if (buf) {\n        const hex = buf.toString('hex')\n        return (float_bytes === -Infinity) ? hex : `h'${hex}'`\n      }\n      if (typeof val[Symbol.for('nodejs.util.inspect.custom')] === 'function') {\n        return val[Symbol.for('nodejs.util.inspect.custom')]()\n      }\n      // Shouldn't get non-empty arrays here\n      if (Array.isArray(val)) {\n        return '[]'\n      }\n      // This should be all that is left\n      return '{}'\n    }\n  }\n  return String(val)\n}\n\nexports.guessEncoding = function guessEncoding(input, encoding) {\n  if (typeof input === 'string') {\n    return new NoFilter(input, (encoding == null) ? 'hex' : encoding)\n  }\n  const buf = exports.bufferishToBuffer(input)\n  if (buf) {\n    return new NoFilter(buf)\n  }\n  if (isReadable(input)) {\n    return input\n  }\n  throw new Error('Unknown input type')\n}\n\nconst B64URL_SWAPS = {\n  '=': '',\n  '+': '-',\n  '/': '_',\n}\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64url string.\n * @private\n */\nexports.base64url = function base64url(buf) {\n  return exports.bufferishToBuffer(buf)\n    .toString('base64')\n    .replace(/[=+/]/g, c => B64URL_SWAPS[c])\n}\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64 string.\n * @private\n */\nexports.base64 = function base64(buf) {\n  return exports.bufferishToBuffer(buf).toString('base64')\n}\n\nexports.isBigEndian = function isBigEndian() {\n  const array = new Uint8Array(4)\n  const view = new Uint32Array(array.buffer)\n  return !((view[0] = 1) & array[0])\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosT0FBTyxRQUFRLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBVTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsK0RBQWE7QUFDdkMsT0FBTyw2QkFBNkI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZCQUE2QjtBQUNqRSxZQUFZO0FBQ1osdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxHQUFHO0FBQzdEO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixTQUFTLG9DQUFvQztBQUM3Qzs7QUFFQTs7QUFFQSxXQUFXO0FBQ1gsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFdBQVc7QUFDeEQ7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIscUJBQXFCLG9CQUFvQjtBQUN6Qzs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUUsR0FBRyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxJQUFJO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDBEQUEwRDtBQUNyRTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywwREFBMEQ7QUFDckU7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NtYXJ0LXdhbGxldC1jbGllbnQvLi9ub2RlX21vZHVsZXMvY2Jvci9saWIvdXRpbHMuanM/MDlmZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge0J1ZmZlcn0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgTm9GaWx0ZXIgPSByZXF1aXJlKCdub2ZpbHRlcicpXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3Qge05VTUJZVEVTLCBTSElGVDMyLCBCSSwgU1lNU30gPSBjb25zdGFudHNcbmNvbnN0IE1BWF9TQUZFX0hJR0ggPSAweDFmZmZmZlxuXG4vKipcbiAqIENvbnZlcnQgYSBVVEY4LWVuY29kZWQgQnVmZmVyIHRvIGEgSlMgc3RyaW5nLiAgSWYgcG9zc2libGUsIHRocm93IGFuIGVycm9yXG4gKiBvbiBpbnZhbGlkIFVURjguICBCeXRlIE9yZGVyIE1hcmtzIGFyZSBub3QgbG9va2VkIGF0IG9yIHN0cmlwcGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHRkID0gbmV3IFRleHREZWNvZGVyKCd1dGY4Jywge2ZhdGFsOiB0cnVlLCBpZ25vcmVCT006IHRydWV9KVxuZXhwb3J0cy51dGY4ID0gYnVmID0+IHRkLmRlY29kZShidWYpXG5leHBvcnRzLnV0ZjguY2hlY2tzVVRGOCA9IHRydWVcblxuZnVuY3Rpb24gaXNSZWFkYWJsZShzKSB7XG4gIC8vIElzIHRoaXMgYSByZWFkYWJsZSBzdHJlYW0/ICBJbiB0aGUgd2VicGFjayB2ZXJzaW9uLCBpbnN0YW5jZW9mIGlzbid0XG4gIC8vIHdvcmtpbmcgY29ycmVjdGx5LlxuICBpZiAocyBpbnN0YW5jZW9mIHN0cmVhbS5SZWFkYWJsZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIFsncmVhZCcsICdvbicsICdwaXBlJ10uZXZlcnkoZiA9PiB0eXBlb2Ygc1tmXSA9PT0gJ2Z1bmN0aW9uJylcbn1cblxuZXhwb3J0cy5pc0J1ZmZlcmlzaCA9IGZ1bmN0aW9uIGlzQnVmZmVyaXNoKGIpIHtcbiAgcmV0dXJuIGIgJiZcbiAgICAodHlwZW9mIGIgPT09ICdvYmplY3QnKSAmJlxuICAgICgoQnVmZmVyLmlzQnVmZmVyKGIpKSB8fFxuICAgICAgKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fFxuICAgICAgKGIgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgfHxcbiAgICAgIChiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAoYiBpbnN0YW5jZW9mIERhdGFWaWV3KSlcbn1cblxuZXhwb3J0cy5idWZmZXJpc2hUb0J1ZmZlciA9IGZ1bmN0aW9uIGJ1ZmZlcmlzaFRvQnVmZmVyKGIpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHJldHVybiBiXG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGIpKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgfSBlbHNlIGlmIChiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYilcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnRzLnBhcnNlQ0JPUmludCA9IGZ1bmN0aW9uIHBhcnNlQ0JPUmludChhaSwgYnVmKSB7XG4gIHN3aXRjaCAoYWkpIHtcbiAgICBjYXNlIE5VTUJZVEVTLk9ORTpcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQ4KDApXG4gICAgY2FzZSBOVU1CWVRFUy5UV086XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRSgwKVxuICAgIGNhc2UgTlVNQllURVMuRk9VUjpcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQzMkJFKDApXG4gICAgY2FzZSBOVU1CWVRFUy5FSUdIVDoge1xuICAgICAgY29uc3QgZiA9IGJ1Zi5yZWFkVUludDMyQkUoMClcbiAgICAgIGNvbnN0IGcgPSBidWYucmVhZFVJbnQzMkJFKDQpXG4gICAgICBpZiAoZiA+IE1BWF9TQUZFX0hJR0gpIHtcbiAgICAgICAgcmV0dXJuIChCaWdJbnQoZikgKiBCSS5TSElGVDMyKSArIEJpZ0ludChnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIChmICogU0hJRlQzMikgKyBnXG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYWRkaXRpb25hbCBpbmZvIGZvciBpbnQ6ICR7YWl9YClcbiAgfVxufVxuXG5leHBvcnRzLndyaXRlSGFsZiA9IGZ1bmN0aW9uIHdyaXRlSGFsZihidWYsIGhhbGYpIHtcbiAgLy8gQXNzdW1lIDAsIC0wLCBOYU4sIEluZmluaXR5LCBhbmQgLUluZmluaXR5IGhhdmUgYWxyZWFkeSBiZWVuIGNhdWdodFxuXG4gIC8vIEhBQ0s6IGV2ZXJ5b25lIHNldHRsZSBpbi4gIFRoaXMgaXNuJ3QgZ29pbmcgdG8gYmUgcHJldHR5LlxuICAvLyBUcmFuc2xhdGUgY24tY2JvcidzIEMgY29kZSAoZnJvbSBDYXJzdGVuIEJvcm1hbik6XG5cbiAgLy8gdWludDMyX3QgYmUzMjtcbiAgLy8gdWludDE2X3QgYmUxNiwgdTE2O1xuICAvLyB1bmlvbiB7XG4gIC8vICAgZmxvYXQgZjtcbiAgLy8gICB1aW50MzJfdCB1O1xuICAvLyB9IHUzMjtcbiAgLy8gdTMyLmYgPSBmbG9hdF92YWw7XG5cbiAgY29uc3QgdTMyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpXG4gIHUzMi53cml0ZUZsb2F0QkUoaGFsZiwgMClcbiAgY29uc3QgdSA9IHUzMi5yZWFkVUludDMyQkUoMClcblxuICAvLyBJZiAoKHUzMi51ICYgMHgxRkZGKSA9PSAwKSB7IC8qIHdvcnRoIHRyeWluZyBoYWxmICovXG5cbiAgLy8gaGlsZGpqOiBJZiB0aGUgbG93ZXIgMTMgYml0cyBhcmVuJ3QgMCxcbiAgLy8gd2Ugd2lsbCBsb3NlIHByZWNpc2lvbiBpbiB0aGUgY29udmVyc2lvbi5cbiAgLy8gbWFudDMyID0gMjRiaXRzLCBtYW50MTYgPSAxMWJpdHMsIDI0LTExID0gMTNcbiAgaWYgKCh1ICYgMHgxRkZGKSAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gU2lnbiwgZXhwb25lbnQsIG1hbnRpc3NhXG4gIC8vICAgaW50IHMxNiA9ICh1MzIudSA+PiAxNikgJiAweDgwMDA7XG4gIC8vICAgaW50IGV4cCA9ICh1MzIudSA+PiAyMykgJiAweGZmO1xuICAvLyAgIGludCBtYW50ID0gdTMyLnUgJiAweDdmZmZmZjtcblxuICBsZXQgczE2ID0gKHUgPj4gMTYpICYgMHg4MDAwIC8vIFRvcCBiaXQgaXMgc2lnblxuICBjb25zdCBleHAgPSAodSA+PiAyMykgJiAweGZmIC8vIFRoZW4gNSBiaXRzIG9mIGV4cG9uZW50XG4gIGNvbnN0IG1hbnQgPSB1ICYgMHg3ZmZmZmZcblxuICAvLyBIaWxkamo6IHplcm9zIGFscmVhZHkgaGFuZGxlZC4gIEFzc2VydCBpZiB5b3UgZG9uJ3QgYmVsaWV2ZSBtZS5cbiAgLy8gICBpZiAoZXhwID09IDAgJiYgbWFudCA9PSAwKVxuICAvLyAgICAgOyAgICAgICAgICAgICAgLyogMC4wLCAtMC4wICovXG5cbiAgLy8gICBlbHNlIGlmIChleHAgPj0gMTEzICYmIGV4cCA8PSAxNDIpIC8qIG5vcm1hbGl6ZWQgKi9cbiAgLy8gICAgIHMxNiArPSAoKGV4cCAtIDExMikgPDwgMTApICsgKG1hbnQgPj4gMTMpO1xuXG4gIGlmICgoZXhwID49IDExMykgJiYgKGV4cCA8PSAxNDIpKSB7XG4gICAgczE2ICs9ICgoZXhwIC0gMTEyKSA8PCAxMCkgKyAobWFudCA+PiAxMylcbiAgfSBlbHNlIGlmICgoZXhwID49IDEwMykgJiYgKGV4cCA8IDExMykpIHtcbiAgICAvLyBEZW5vcm1hbGl6ZWQgbnVtYmVyc1xuICAgIC8vICAgZWxzZSBpZiAoZXhwID49IDEwMyAmJiBleHAgPCAxMTMpIHsgLyogZGVub3JtLCBleHAxNiA9IDAgKi9cbiAgICAvLyAgICAgaWYgKG1hbnQgJiAoKDEgPDwgKDEyNiAtIGV4cCkpIC0gMSkpXG4gICAgLy8gICAgICAgZ290byBmbG9hdDMyOyAgICAgICAgIC8qIGxvc3Mgb2YgcHJlY2lzaW9uICovXG4gICAgLy8gICAgIHMxNiArPSAoKG1hbnQgKyAweDgwMDAwMCkgPj4gKDEyNiAtIGV4cCkpO1xuXG4gICAgaWYgKG1hbnQgJiAoKDEgPDwgKDEyNiAtIGV4cCkpIC0gMSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBzMTYgKz0gKChtYW50ICsgMHg4MDAwMDApID4+ICgxMjYgLSBleHApKVxuICB9IGVsc2Uge1xuICAvLyAgIH0gZWxzZSBpZiAoZXhwID09IDI1NSAmJiBtYW50ID09IDApIHsgLyogSW5mICovXG4gIC8vICAgICBzMTYgKz0gMHg3YzAwO1xuXG4gICAgLy8gaGlsZGpqOiBJbmZpbml0eSBhbHJlYWR5IGhhbmRsZWRcblxuICAgIC8vICAgfSBlbHNlXG4gICAgLy8gICAgIGdvdG8gZmxvYXQzMjsgICAgICAgICAgIC8qIGxvc3Mgb2YgcmFuZ2UgKi9cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gRG9uZVxuICAvLyAgIGVuc3VyZV93cml0YWJsZSgzKTtcbiAgLy8gICB1MTYgPSBzMTY7XG4gIC8vICAgYmUxNiA9IGh0b24xNnAoKGNvbnN0IHVpbnQ4X3QqKSZ1MTYpO1xuICBidWYud3JpdGVVSW50MTZCRShzMTYpXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydHMucGFyc2VIYWxmID0gZnVuY3Rpb24gcGFyc2VIYWxmKGJ1Zikge1xuICBjb25zdCBzaWduID0gYnVmWzBdICYgMHg4MCA/IC0xIDogMVxuICBjb25zdCBleHAgPSAoYnVmWzBdICYgMHg3QykgPj4gMlxuICBjb25zdCBtYW50ID0gKChidWZbMF0gJiAweDAzKSA8PCA4KSB8IGJ1ZlsxXVxuICBpZiAoIWV4cCkge1xuICAgIHJldHVybiBzaWduICogNS45NjA0NjQ0Nzc1MzkwNjI1ZS04ICogbWFudFxuICB9IGVsc2UgaWYgKGV4cCA9PT0gMHgxZikge1xuICAgIHJldHVybiBzaWduICogKG1hbnQgPyBOYU4gOiBJbmZpbml0eSlcbiAgfVxuICByZXR1cm4gc2lnbiAqICgyICoqIChleHAgLSAyNSkpICogKDEwMjQgKyBtYW50KVxufVxuXG5leHBvcnRzLnBhcnNlQ0JPUmZsb2F0ID0gZnVuY3Rpb24gcGFyc2VDQk9SZmxvYXQoYnVmKSB7XG4gIHN3aXRjaCAoYnVmLmxlbmd0aCkge1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBleHBvcnRzLnBhcnNlSGFsZihidWYpXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGJ1Zi5yZWFkRmxvYXRCRSgwKVxuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBidWYucmVhZERvdWJsZUJFKDApXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmbG9hdCBzaXplOiAke2J1Zi5sZW5ndGh9YClcbiAgfVxufVxuXG5leHBvcnRzLmhleCA9IGZ1bmN0aW9uIGhleChzKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzLnJlcGxhY2UoL14weC8sICcnKSwgJ2hleCcpXG59XG5cbmV4cG9ydHMuYmluID0gZnVuY3Rpb24gYmluKHMpIHtcbiAgcyA9IHMucmVwbGFjZSgvXFxzL2csICcnKVxuICBsZXQgc3RhcnQgPSAwXG4gIGxldCBlbmQgPSAocy5sZW5ndGggJSA4KSB8fCA4XG4gIGNvbnN0IGNodW5rcyA9IFtdXG4gIHdoaWxlIChlbmQgPD0gcy5sZW5ndGgpIHtcbiAgICBjaHVua3MucHVzaChwYXJzZUludChzLnNsaWNlKHN0YXJ0LCBlbmQpLCAyKSlcbiAgICBzdGFydCA9IGVuZFxuICAgIGVuZCArPSA4XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rcylcbn1cblxuZXhwb3J0cy5hcnJheUVxdWFsID0gZnVuY3Rpb24gYXJyYXlFcXVhbChhLCBiKSB7XG4gIGlmICgoYSA9PSBudWxsKSAmJiAoYiA9PSBudWxsKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKChhID09IG51bGwpIHx8IChiID09IG51bGwpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIChhLmxlbmd0aCA9PT0gYi5sZW5ndGgpICYmIGEuZXZlcnkoKGVsZW0sIGkpID0+IGVsZW0gPT09IGJbaV0pXG59XG5cbmV4cG9ydHMuYnVmZmVyVG9CaWdJbnQgPSBmdW5jdGlvbiBidWZmZXJUb0JpZ0ludChidWYpIHtcbiAgcmV0dXJuIEJpZ0ludChgMHgke2J1Zi50b1N0cmluZygnaGV4Jyl9YClcbn1cblxuZXhwb3J0cy5jYm9yVmFsdWVUb1N0cmluZyA9IGZ1bmN0aW9uIGNib3JWYWx1ZVRvU3RyaW5nKHZhbCwgZmxvYXRfYnl0ZXMgPSAtMSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcbiAgICBjYXNlICdzeW1ib2wnOiB7XG4gICAgICBzd2l0Y2ggKHZhbCkge1xuICAgICAgICBjYXNlIFNZTVMuTlVMTDpcbiAgICAgICAgICByZXR1cm4gJ251bGwnXG4gICAgICAgIGNhc2UgU1lNUy5VTkRFRklORUQ6XG4gICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnXG4gICAgICAgIGNhc2UgU1lNUy5CUkVBSzpcbiAgICAgICAgICByZXR1cm4gJ0JSRUFLJ1xuICAgICAgfVxuICAgICAgLy8gSW1wb3NzaWJsZSBpbiBub2RlIDEwXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh2YWwuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHZhbC5kZXNjcmlwdGlvblxuICAgICAgfVxuICAgICAgLy8gT24gbm9kZTEwLCBTeW1ib2wgZG9lc24ndCBoYXZlIGRlc2NyaXB0aW9uLiAgUGFyc2UgaXQgb3V0IG9mIHRoZVxuICAgICAgLy8gdG9TdHJpbmcgdmFsdWUsIHdoaWNoIGxvb2tzIGxpa2UgYFN5bWJvbChmb28pYC5cbiAgICAgIGNvbnN0IHMgPSB2YWwudG9TdHJpbmcoKVxuICAgICAgY29uc3QgbSA9IHMubWF0Y2goL15TeW1ib2xcXCgoPzxuYW1lPi4qKVxcKS8pXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChtICYmIG0uZ3JvdXBzLm5hbWUpIHtcbiAgICAgICAgLy8gSW1wb3NzaWJsZSBpbiBub2RlIDEyK1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gbS5ncm91cHMubmFtZVxuICAgICAgfVxuICAgICAgcmV0dXJuICdTeW1ib2wnXG4gICAgfVxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsKVxuICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICByZXR1cm4gdmFsLnRvU3RyaW5nKClcbiAgICBjYXNlICdudW1iZXInOiB7XG4gICAgICBjb25zdCBzID0gT2JqZWN0LmlzKHZhbCwgLTApID8gJy0wJyA6IFN0cmluZyh2YWwpXG4gICAgICByZXR1cm4gKGZsb2F0X2J5dGVzID4gMCkgPyBgJHtzfV8ke2Zsb2F0X2J5dGVzfWAgOiBzXG4gICAgfVxuICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgIC8vIEEgbnVsbCBzaG91bGQgYmUgY2F1Z2h0IGFib3ZlXG4gICAgICBjb25zdCBidWYgPSBleHBvcnRzLmJ1ZmZlcmlzaFRvQnVmZmVyKHZhbClcbiAgICAgIGlmIChidWYpIHtcbiAgICAgICAgY29uc3QgaGV4ID0gYnVmLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgICByZXR1cm4gKGZsb2F0X2J5dGVzID09PSAtSW5maW5pdHkpID8gaGV4IDogYGgnJHtoZXh9J2BcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB2YWxbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oKVxuICAgICAgfVxuICAgICAgLy8gU2hvdWxkbid0IGdldCBub24tZW1wdHkgYXJyYXlzIGhlcmVcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuICdbXSdcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGFsbCB0aGF0IGlzIGxlZnRcbiAgICAgIHJldHVybiAne30nXG4gICAgfVxuICB9XG4gIHJldHVybiBTdHJpbmcodmFsKVxufVxuXG5leHBvcnRzLmd1ZXNzRW5jb2RpbmcgPSBmdW5jdGlvbiBndWVzc0VuY29kaW5nKGlucHV0LCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgTm9GaWx0ZXIoaW5wdXQsIChlbmNvZGluZyA9PSBudWxsKSA/ICdoZXgnIDogZW5jb2RpbmcpXG4gIH1cbiAgY29uc3QgYnVmID0gZXhwb3J0cy5idWZmZXJpc2hUb0J1ZmZlcihpbnB1dClcbiAgaWYgKGJ1Zikge1xuICAgIHJldHVybiBuZXcgTm9GaWx0ZXIoYnVmKVxuICB9XG4gIGlmIChpc1JlYWRhYmxlKGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dFxuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBpbnB1dCB0eXBlJylcbn1cblxuY29uc3QgQjY0VVJMX1NXQVBTID0ge1xuICAnPSc6ICcnLFxuICAnKyc6ICctJyxcbiAgJy8nOiAnXycsXG59XG5cbi8qKlxuICogQHBhcmFtIHtCdWZmZXJ8VWludDhBcnJheXxVaW50OENsYW1wZWRBcnJheXxBcnJheUJ1ZmZlcnxEYXRhVmlld30gYnVmXG4gKiAgIEJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0dXJsIHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuYmFzZTY0dXJsID0gZnVuY3Rpb24gYmFzZTY0dXJsKGJ1Zikge1xuICByZXR1cm4gZXhwb3J0cy5idWZmZXJpc2hUb0J1ZmZlcihidWYpXG4gICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIC5yZXBsYWNlKC9bPSsvXS9nLCBjID0+IEI2NFVSTF9TV0FQU1tjXSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcnxVaW50OEFycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fEFycmF5QnVmZmVyfERhdGFWaWV3fSBidWZcbiAqICAgQnVmZmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5iYXNlNjQgPSBmdW5jdGlvbiBiYXNlNjQoYnVmKSB7XG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlcmlzaFRvQnVmZmVyKGJ1ZikudG9TdHJpbmcoJ2Jhc2U2NCcpXG59XG5cbmV4cG9ydHMuaXNCaWdFbmRpYW4gPSBmdW5jdGlvbiBpc0JpZ0VuZGlhbigpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheSg0KVxuICBjb25zdCB2aWV3ID0gbmV3IFVpbnQzMkFycmF5KGFycmF5LmJ1ZmZlcilcbiAgcmV0dXJuICEoKHZpZXdbMF0gPSAxKSAmIGFycmF5WzBdKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cbor/vendor/binary-parse-stream/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/cbor/vendor/binary-parse-stream/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n\n// binary-parse-stream is now unmaintained, so I have rewritten it as\n// more modern JS so I can get tsc to help check types.\n\n\nconst stream = __webpack_require__(/*! stream */ \"stream\")\nconst NoFilter = __webpack_require__(/*! nofilter */ \"(ssr)/./node_modules/nofilter/lib/index.js\")\n\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @extends stream.Transform\n */\nclass BinaryParseStream extends stream.Transform {\n  /**\n   * Creates an instance of BinaryParseStream.\n   *\n   * @memberof BinaryParseStream\n   * @param {stream.TransformOptions} options Stream options.\n   */\n  constructor(options) {\n    super(options)\n    // Doesn't work to pass these in as opts, for some reason\n    // also, work around typescript not knowing TransformStream internals\n    // eslint-disable-next-line dot-notation\n    this['_writableState'].objectMode = false\n    // eslint-disable-next-line dot-notation\n    this['_readableState'].objectMode = true\n\n    this.bs = new NoFilter()\n    this.__restart()\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.bs.write(fresh)\n\n    while (this.bs.length >= this.__needed) {\n      let ret = null\n      const chunk = (this.__needed === null) ?\n        undefined :\n        this.bs.read(this.__needed)\n\n      try {\n        ret = this.__parser.next(chunk)\n      } catch (e) {\n        return cb(e)\n      }\n\n      if (this.__needed) {\n        this.__fresh = false\n      }\n\n      if (ret.done) {\n        this.push(ret.value)\n        this.__restart()\n      } else {\n        this.__needed = ret.value || Infinity\n      }\n    }\n\n    return cb()\n  }\n\n  /**\n   * Subclasses must override this to set their parsing behavior.  Yield a\n   * number to receive a Buffer of that many bytes.\n   *\n   * @abstract\n   * @returns {Generator<number, any, Buffer>}\n   */\n  /* istanbul ignore next */\n  *_parse() { // eslint-disable-line class-methods-use-this, require-yield\n    throw new Error('Must be implemented in subclass')\n  }\n\n  __restart() {\n    this.__needed = null\n    this.__parser = this._parse()\n    this.__fresh = true\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    cb(this.__fresh ? null : new Error('unexpected end of input'))\n  }\n}\n\nmodule.exports = BinaryParseStream\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2Jvci92ZW5kb3IvYmluYXJ5LXBhcnNlLXN0cmVhbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRVk7QUFDWixlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsNERBQVU7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQixhQUFhLGdCQUFnQjtBQUM3QixhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0LWNsaWVudC8uL25vZGVfbW9kdWxlcy9jYm9yL3ZlbmRvci9iaW5hcnktcGFyc2Utc3RyZWFtL2luZGV4LmpzPzI4NDciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVHdlYWtlZCB2ZXJzaW9uIG9mIG5hdGhhbjcncyBiaW5hcnktcGFyc2Utc3RyZWFtXG4vLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXRoYW43L2JpbmFyeS1wYXJzZS1zdHJlYW0pXG4vLyBVc2VzIE5vRmlsdGVyIGluc3RlYWQgb2YgdGhlIHJlYWRhYmxlIGluIHRoZSBvcmlnaW5hbC4gIFJlbW92ZXNcbi8vIHRoZSBhYmlsaXR5IHRvIHJlYWQgLTEsIHdoaWNoIHdhcyBvZGQgYW5kIHVuLW5lZWRlZC5cbi8vIExpY2Vuc2UgZm9yIGJpbmFyeS1wYXJzZS1zdHJlYW06IE1JVFxuXG4vLyBiaW5hcnktcGFyc2Utc3RyZWFtIGlzIG5vdyB1bm1haW50YWluZWQsIHNvIEkgaGF2ZSByZXdyaXR0ZW4gaXQgYXNcbi8vIG1vcmUgbW9kZXJuIEpTIHNvIEkgY2FuIGdldCB0c2MgdG8gaGVscCBjaGVjayB0eXBlcy5cblxuJ3VzZSBzdHJpY3QnXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3QgTm9GaWx0ZXIgPSByZXF1aXJlKCdub2ZpbHRlcicpXG5cbi8qKlxuICogQmluYXJ5UGFyc2VTdHJlYW0gaXMgYSBUcmFuc2Zvcm1TdHJlYW0gdGhhdCBjb25zdW1lcyBidWZmZXJzIGFuZCBvdXRwdXRzXG4gKiBvYmplY3RzIG9uIHRoZSBvdGhlciBlbmQuICBJdCBleHBlY3RzIHlvdXIgc3ViY2xhc3MgdG8gaW1wbGVtZW50IGEgYF9wYXJzZWBcbiAqIG1ldGhvZCB0aGF0IGlzIGEgZ2VuZXJhdG9yLiAgV2hlbiB5b3VyIGdlbmVyYXRvciB5aWVsZHMgYSBudW1iZXIsIGl0J2xsIGJlXG4gKiBmZWQgYSBidWZmZXIgb2YgdGhhdCBsZW5ndGggZnJvbSB0aGUgaW5wdXQuICBXaGVuIHlvdXIgZ2VuZXJhdG9yIHJldHVybnMsXG4gKiB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgcHVzaGVkIHRvIHRoZSBvdXRwdXQgc2lkZS5cbiAqXG4gKiBAZXh0ZW5kcyBzdHJlYW0uVHJhbnNmb3JtXG4gKi9cbmNsYXNzIEJpbmFyeVBhcnNlU3RyZWFtIGV4dGVuZHMgc3RyZWFtLlRyYW5zZm9ybSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJpbmFyeVBhcnNlU3RyZWFtLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQmluYXJ5UGFyc2VTdHJlYW1cbiAgICogQHBhcmFtIHtzdHJlYW0uVHJhbnNmb3JtT3B0aW9uc30gb3B0aW9ucyBTdHJlYW0gb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKVxuICAgIC8vIERvZXNuJ3Qgd29yayB0byBwYXNzIHRoZXNlIGluIGFzIG9wdHMsIGZvciBzb21lIHJlYXNvblxuICAgIC8vIGFsc28sIHdvcmsgYXJvdW5kIHR5cGVzY3JpcHQgbm90IGtub3dpbmcgVHJhbnNmb3JtU3RyZWFtIGludGVybmFsc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkb3Qtbm90YXRpb25cbiAgICB0aGlzWydfd3JpdGFibGVTdGF0ZSddLm9iamVjdE1vZGUgPSBmYWxzZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkb3Qtbm90YXRpb25cbiAgICB0aGlzWydfcmVhZGFibGVTdGF0ZSddLm9iamVjdE1vZGUgPSB0cnVlXG5cbiAgICB0aGlzLmJzID0gbmV3IE5vRmlsdGVyKClcbiAgICB0aGlzLl9fcmVzdGFydCgpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gZnJlc2ggQnVmZmVyIHRvIHRyYW5zY29kZS5cbiAgICogQHBhcmFtIHtCdWZmZXJFbmNvZGluZ30gZW5jb2RpbmcgTmFtZSBvZiBlbmNvZGluZy5cbiAgICogQHBhcmFtIHtzdHJlYW0uVHJhbnNmb3JtQ2FsbGJhY2t9IGNiIENhbGxiYWNrIHdoZW4gZG9uZS5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgX3RyYW5zZm9ybShmcmVzaCwgZW5jb2RpbmcsIGNiKSB7XG4gICAgdGhpcy5icy53cml0ZShmcmVzaClcblxuICAgIHdoaWxlICh0aGlzLmJzLmxlbmd0aCA+PSB0aGlzLl9fbmVlZGVkKSB7XG4gICAgICBsZXQgcmV0ID0gbnVsbFxuICAgICAgY29uc3QgY2h1bmsgPSAodGhpcy5fX25lZWRlZCA9PT0gbnVsbCkgP1xuICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICB0aGlzLmJzLnJlYWQodGhpcy5fX25lZWRlZClcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gdGhpcy5fX3BhcnNlci5uZXh0KGNodW5rKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2IoZSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19uZWVkZWQpIHtcbiAgICAgICAgdGhpcy5fX2ZyZXNoID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKHJldC5kb25lKSB7XG4gICAgICAgIHRoaXMucHVzaChyZXQudmFsdWUpXG4gICAgICAgIHRoaXMuX19yZXN0YXJ0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19uZWVkZWQgPSByZXQudmFsdWUgfHwgSW5maW5pdHlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2IoKVxuICB9XG5cbiAgLyoqXG4gICAqIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzIHRvIHNldCB0aGVpciBwYXJzaW5nIGJlaGF2aW9yLiAgWWllbGQgYVxuICAgKiBudW1iZXIgdG8gcmVjZWl2ZSBhIEJ1ZmZlciBvZiB0aGF0IG1hbnkgYnl0ZXMuXG4gICAqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJucyB7R2VuZXJhdG9yPG51bWJlciwgYW55LCBCdWZmZXI+fVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgKl9wYXJzZSgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzLCByZXF1aXJlLXlpZWxkXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzJylcbiAgfVxuXG4gIF9fcmVzdGFydCgpIHtcbiAgICB0aGlzLl9fbmVlZGVkID0gbnVsbFxuICAgIHRoaXMuX19wYXJzZXIgPSB0aGlzLl9wYXJzZSgpXG4gICAgdGhpcy5fX2ZyZXNoID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmVhbS5UcmFuc2Zvcm1DYWxsYmFja30gY2IgQ2FsbGJhY2sgd2hlbiBkb25lLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfZmx1c2goY2IpIHtcbiAgICBjYih0aGlzLl9fZnJlc2ggPyBudWxsIDogbmV3IEVycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmluYXJ5UGFyc2VTdHJlYW1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cbor/vendor/binary-parse-stream/index.js\n");

/***/ })

};
;