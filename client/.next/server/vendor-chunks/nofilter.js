"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nofilter";
exports.ids = ["vendor-chunks/nofilter"];
exports.modules = {

/***/ "(ssr)/./node_modules/nofilter/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/nofilter/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst stream = __webpack_require__(/*! stream */ \"stream\")\nconst {Buffer} = __webpack_require__(/*! buffer */ \"buffer\")\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})\n\n/**\n * @typedef {object} NoFilterOptions\n * @property {string|Buffer} [input=null] Input source data.\n * @property {BufferEncoding} [inputEncoding=null] Encoding name for input,\n *   ignored if input is not a String.\n * @property {number} [highWaterMark=16384] The maximum number of bytes to\n *   store in the internal buffer before ceasing to read from the underlying\n *   resource. Default=16kb, or 16 for objectMode streams.\n * @property {BufferEncoding} [encoding=null] If specified, then buffers\n *   will be decoded to strings using the specified encoding.\n * @property {boolean} [objectMode=false] Whether this stream should behave\n *   as a stream of objects. Meaning that stream.read(n) returns a single\n *   value instead of a Buffer of size n.\n * @property {boolean} [decodeStrings=true] Whether or not to decode\n *   strings into Buffers before passing them to _write().\n * @property {boolean} [watchPipe=true] Whether to watch for 'pipe' events,\n *   setting this stream's objectMode based on the objectMode of the input\n *   stream.\n * @property {boolean} [readError=false] If true, when a read() underflows,\n *   throw an error.\n * @property {boolean} [allowHalfOpen=true] If set to false, then the\n *   stream will automatically end the writable side when the readable side\n *   ends.\n * @property {boolean} [autoDestroy=true] Whether this stream should\n *   automatically call .destroy() on itself after ending.\n * @property {BufferEncoding} [defaultEncoding='utf8'] The default encoding\n *   that is used when no encoding is specified as an argument to\n *   stream.write().\n * @property {boolean} [emitClose=true] Whether or not the stream should\n *   emit 'close' after it has been destroyed.\n * @property {number} [readableHighWaterMark] Sets highWaterMark for the\n *   readable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [readableObjectMode=false] Sets objectMode for\n *   readable side of the stream. Has no effect if objectMode is true.\n * @property {number} [writableHighWaterMark] Sets highWaterMark for the\n *   writable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [writableObjectMode=false] Sets objectMode for\n *   writable side of the stream. Has no effect if objectMode is true.\n */\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source and sink</caption>\n * const source = new NoFilter('Zm9v', 'base64')\n * source.pipe(process.stdout)\n * const sink = new Nofilter()\n * // NOTE: 'finish' fires when the input is done writing\n * sink.on('finish', () => console.log(n.toString('base64')))\n * process.stdin.pipe(sink)\n */\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.\n   * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding\n   *   name for input, ignored if input is not a String.\n   * @param {NoFilterOptions} [options] Other options.\n   */\n  constructor(input, inputEncoding, options = {}) {\n    let inp = null\n    let inpE = /** @type {BufferEncoding?} */ (null)\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input\n        } else if (input) {\n          options = input\n        }\n        break\n      case 'string':\n        inp = input\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid input')\n    }\n    switch (typeof inputEncoding) {\n      case 'object':\n        if (inputEncoding) {\n          options = inputEncoding\n        }\n        break\n      case 'string':\n        inpE = /** @type {BufferEncoding} */ (inputEncoding)\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid inputEncoding')\n    }\n    if (!options || typeof options !== 'object') {\n      throw new TypeError('Invalid options')\n    }\n    if (inp == null) {\n      inp = options.input\n    }\n    if (inpE == null) {\n      inpE = options.inputEncoding\n    }\n    delete options.input\n    delete options.inputEncoding\n    const watchPipe = options.watchPipe == null ? true : options.watchPipe\n    delete options.watchPipe\n    const readError = Boolean(options.readError)\n    delete options.readError\n    super(options)\n\n    this.readError = readError\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        // @ts-ignore: TS2339 (using internal interface)\n        const om = readable._readableState.objectMode\n        // @ts-ignore: TS2339 (using internal interface)\n        if ((this.length > 0) && (om !== this._readableState.objectMode)) {\n          throw new Error(\n            'Do not switch objectMode in the middle of the stream'\n          )\n        }\n\n        // @ts-ignore: TS2339 (using internal interface)\n        this._readableState.objectMode = om\n        // @ts-ignore: TS2339 (using internal interface)\n        this._writableState.objectMode = om\n      })\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE)\n    }\n  }\n\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {object} obj The object to test.\n   * @returns {boolean} True if obj is a NoFilter.\n   */\n  static isNoFilter(obj) {\n    return obj instanceof this\n  }\n\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 The first object to compare.\n   * @param {NoFilter} nf2 The second object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments not NoFilter instances.\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')]\n   * arr.sort(NoFilter.compare)\n   */\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (nf1 === nf2) {\n      return 0\n    }\n    return nf1.compare(nf2)\n  }\n\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read.\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer.\n   * @throws {TypeError} List not array of NoFilters.\n   */\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters')\n    }\n    if ((list.length === 0) || (length === 0)) {\n      return Buffer.alloc(0)\n    }\n    if ((length == null)) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters')\n        }\n        return tot + nf.length\n      }, 0)\n    }\n    let allBufs = true\n    let allObjs = true\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters')\n      }\n      const buf = nf.slice()\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false\n      } else {\n        allBufs = false\n      }\n      return buf\n    })\n    if (allBufs) {\n      // @ts-ignore: TS2322, tsc can't see the type checking above\n      return Buffer.concat(bufs, length)\n    }\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length)\n    }\n    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n    throw new Error('Concatenating mixed object and byte streams not supported')\n  }\n\n  /**\n   * @ignore\n   */\n  _transform(chunk, encoding, callback) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n    this.push(chunk)\n    callback()\n  }\n\n  /**\n   * @returns {Buffer[]} The current internal buffers.  They are layed out\n   *   end to end.\n   * @ignore\n   */\n  _bufArray() {\n    // @ts-ignore: TS2339 (using internal interface)\n    let bufs = this._readableState.buffer\n    // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head\n      bufs = []\n      while (b != null) {\n        bufs.push(b.data)\n        b = b.next\n      }\n    }\n    return bufs\n  }\n\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer.\n   * @throws Error If readError is true and there was underflow.\n   * @fires NoFilter#read When read from.\n   */\n  read(size) {\n    const buf = super.read(size)\n    if (buf != null) {\n      /**\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @param {Buffer|string|object} buf What was read.\n       */\n      this.emit('read', buf)\n      if (this.readError && (buf.length < size)) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`)\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`)\n    }\n    return buf\n  }\n\n  /**\n   * Read the full number of bytes asked for, no matter how long it takes.\n   * Fail if an error occurs in the meantime, or if the stream finishes before\n   * enough data is available.\n   *\n   * Note: This function won't work fully correctly if you are using\n   * stream-browserify (for example, on the Web).\n   *\n   * @param {number} size The number of bytes to read.\n   * @returns {Promise<string|Buffer>} A promise for the data read.\n   */\n  readFull(size) {\n    let onReadable = null\n    let onFinish = null\n    let onError = null\n    return new Promise((resolve, reject) => {\n      if (this.length >= size) {\n        resolve(this.read(size))\n        return\n      }\n\n      // Added in Node 12.19.  This won't work with stream-browserify yet.\n      // If it's needed, file a bug, and I'll do a work-around.\n      if (this.writableFinished) {\n        // Already finished writing, so no more coming.\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n        return\n      }\n\n      onReadable = chunk => {\n        if (this.length >= size) {\n          resolve(this.read(size))\n        }\n      }\n      onFinish = () => {\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n      }\n      onError = reject\n      this.on('readable', onReadable)\n      this.on('error', onError)\n      this.on('finish', onFinish)\n    }).finally(() => {\n      if (onReadable) {\n        this.removeListener('readable', onReadable)\n        this.removeListener('error', onError)\n        this.removeListener('finish', onFinish)\n      }\n    })\n  }\n\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {Function} [cb=null] Finished/error callback used in *addition*\n   *   to the promise.\n   * @returns {Promise<Buffer|string>} Fulfilled when complete.\n   */\n  promise(cb) {\n    let done = false\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read()\n        if ((cb != null) && !done) {\n          done = true\n          cb(null, data)\n        }\n        resolve(data)\n      })\n      this.on('error', er => {\n        if ((cb != null) && !done) {\n          done = true\n          cb(er)\n        }\n        reject(er)\n      })\n    })\n  }\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other The other object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments must be NoFilters.\n   */\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (this === other) {\n      return 0\n    }\n\n    const buf1 = this.slice()\n    const buf2 = other.slice()\n    // These will both be buffers because of the check above.\n    if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n      return buf1.compare(buf2)\n    }\n    throw new Error('Cannot compare streams in object mode')\n  }\n\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other Other NoFilter to compare against.\n   * @returns {boolean} Equal?\n   */\n  equals(other) {\n    return this.compare(other) === 0\n  }\n\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {number} [start=0] Beginning offset.\n   * @param {number} [end=length] Ending offset.\n   * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n  slice(start, end) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end)\n    }\n    const bufs = this._bufArray()\n    switch (bufs.length) {\n      case 0: return Buffer.alloc(0)\n      case 1: return bufs[0].slice(start, end)\n      default: {\n        const b = Buffer.concat(bufs)\n        // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n        return b.slice(start, end)\n      }\n    }\n  }\n\n  /**\n   * Get a byte by offset.  I didn't want to get into metaprogramming\n   * to give you the `NoFilter[0]` syntax.\n   *\n   * @param {number} index The byte to retrieve.\n   * @returns {number} 0-255.\n   */\n  get(index) {\n    return this.slice()[index]\n  }\n\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so that\n   * round-tripping will produce a Buffer.\n   *\n   * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,\n   *   the objects.  Otherwise, JSON text.\n   * @example <caption>output for 'foo', not in object mode</caption>\n   * ({\n   *   type: 'Buffer',\n   *   data: [102, 111, 111],\n   * })\n   */\n  toJSON() {\n    const b = this.slice()\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON()\n    }\n    return b\n  }\n\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?\n   * @param {number} [start=0] Start offset.\n   * @param {number} [end=length] End offset.\n   * @returns {string} String version of the contents.\n   */\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end)\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf)\n    }\n    if (!encoding || (encoding === 'utf8')) {\n      return td.decode(buf)\n    }\n    return buf.toString(encoding)\n  }\n\n  /**\n   * @ignore\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options) {\n    const bufs = this._bufArray()\n    const hex = bufs.map(b => {\n      if (Buffer.isBuffer(b)) {\n        return options.stylize(b.toString('hex'), 'string')\n      }\n      return JSON.stringify(b)\n    }).join(', ')\n    return `${this.constructor.name} [${hex}]`\n  }\n\n  /**\n   * Current readable length, in bytes.\n   *\n   * @returns {number} Length of the contents.\n   */\n  get length() {\n    // @ts-ignore: TS2339 (using internal interface)\n    return this._readableState.length\n  }\n\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val The value to write.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt(val) {\n    let str = val.toString(16)\n    if (val < 0) {\n      // Two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2))\n      const mask = BigInt(1) << (sz * BigInt(8))\n      val = mask + val\n      str = val.toString(16)\n    }\n    if (str.length % 2) {\n      str = `0${str}`\n    }\n    return this.push(Buffer.from(str, 'hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readUBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return BigInt(`0x${b.toString('hex')}`)\n  }\n\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    let ret = BigInt(`0x${b.toString('hex')}`)\n    // Negative?\n    if (b[0] & 0x80) {\n      // Two's complement\n      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))\n      ret -= mask\n    }\n    return ret\n  }\n\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value 0..255.\n   * @returns {boolean} True on success.\n   */\n  writeUInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value (-128)..127.\n   * @returns {boolean} True on success.\n   */\n  writeInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatLE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatBE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleLE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleBE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt8()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16BE()\n  }\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32BE()\n  }\n\n  /**\n   * Read a signed 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt8()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16BE()\n  }\n\n  /**\n   * Read a little-endian signed 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32BE()\n  }\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatLE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatLE()\n  }\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatBE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatBE()\n  }\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleLE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleLE()\n  }\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleBE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleBE()\n  }\n\n  /**\n   * Read a signed 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64LE()\n  }\n\n  /**\n   * Read a signed 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64BE()\n  }\n\n  /**\n   * Read an unsigned 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64LE()\n  }\n\n  /**\n   * Read an unsigned 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64BE()\n  }\n}\n\nmodule.exports = NoFilter\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9maWx0ZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixPQUFPLFFBQVEsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLG9DQUFvQyw2QkFBNkI7O0FBRWpFO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsZUFBZTtBQUM3QixjQUFjLGdCQUFnQjtBQUM5QjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQThDO0FBQzNELGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsY0FBYztBQUM3QjtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsV0FBVyxLQUFLO0FBQzNEO0FBQ0EsTUFBTTtBQUNOLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsd0JBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYyxnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyx1QkFBdUIsR0FBRyxJQUFJO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zbWFydC13YWxsZXQtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL25vZmlsdGVyL2xpYi9pbmRleC5qcz9iYzYwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuY29uc3Qge0J1ZmZlcn0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgdGQgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7ZmF0YWw6IHRydWUsIGlnbm9yZUJPTTogdHJ1ZX0pXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gTm9GaWx0ZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ3xCdWZmZXJ9IFtpbnB1dD1udWxsXSBJbnB1dCBzb3VyY2UgZGF0YS5cbiAqIEBwcm9wZXJ0eSB7QnVmZmVyRW5jb2Rpbmd9IFtpbnB1dEVuY29kaW5nPW51bGxdIEVuY29kaW5nIG5hbWUgZm9yIGlucHV0LFxuICogICBpZ25vcmVkIGlmIGlucHV0IGlzIG5vdCBhIFN0cmluZy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGlnaFdhdGVyTWFyaz0xNjM4NF0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGJ5dGVzIHRvXG4gKiAgIHN0b3JlIGluIHRoZSBpbnRlcm5hbCBidWZmZXIgYmVmb3JlIGNlYXNpbmcgdG8gcmVhZCBmcm9tIHRoZSB1bmRlcmx5aW5nXG4gKiAgIHJlc291cmNlLiBEZWZhdWx0PTE2a2IsIG9yIDE2IGZvciBvYmplY3RNb2RlIHN0cmVhbXMuXG4gKiBAcHJvcGVydHkge0J1ZmZlckVuY29kaW5nfSBbZW5jb2Rpbmc9bnVsbF0gSWYgc3BlY2lmaWVkLCB0aGVuIGJ1ZmZlcnNcbiAqICAgd2lsbCBiZSBkZWNvZGVkIHRvIHN0cmluZ3MgdXNpbmcgdGhlIHNwZWNpZmllZCBlbmNvZGluZy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29iamVjdE1vZGU9ZmFsc2VdIFdoZXRoZXIgdGhpcyBzdHJlYW0gc2hvdWxkIGJlaGF2ZVxuICogICBhcyBhIHN0cmVhbSBvZiBvYmplY3RzLiBNZWFuaW5nIHRoYXQgc3RyZWFtLnJlYWQobikgcmV0dXJucyBhIHNpbmdsZVxuICogICB2YWx1ZSBpbnN0ZWFkIG9mIGEgQnVmZmVyIG9mIHNpemUgbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlY29kZVN0cmluZ3M9dHJ1ZV0gV2hldGhlciBvciBub3QgdG8gZGVjb2RlXG4gKiAgIHN0cmluZ3MgaW50byBCdWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gX3dyaXRlKCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3YXRjaFBpcGU9dHJ1ZV0gV2hldGhlciB0byB3YXRjaCBmb3IgJ3BpcGUnIGV2ZW50cyxcbiAqICAgc2V0dGluZyB0aGlzIHN0cmVhbSdzIG9iamVjdE1vZGUgYmFzZWQgb24gdGhlIG9iamVjdE1vZGUgb2YgdGhlIGlucHV0XG4gKiAgIHN0cmVhbS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlYWRFcnJvcj1mYWxzZV0gSWYgdHJ1ZSwgd2hlbiBhIHJlYWQoKSB1bmRlcmZsb3dzLFxuICogICB0aHJvdyBhbiBlcnJvci5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FsbG93SGFsZk9wZW49dHJ1ZV0gSWYgc2V0IHRvIGZhbHNlLCB0aGVuIHRoZVxuICogICBzdHJlYW0gd2lsbCBhdXRvbWF0aWNhbGx5IGVuZCB0aGUgd3JpdGFibGUgc2lkZSB3aGVuIHRoZSByZWFkYWJsZSBzaWRlXG4gKiAgIGVuZHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthdXRvRGVzdHJveT10cnVlXSBXaGV0aGVyIHRoaXMgc3RyZWFtIHNob3VsZFxuICogICBhdXRvbWF0aWNhbGx5IGNhbGwgLmRlc3Ryb3koKSBvbiBpdHNlbGYgYWZ0ZXIgZW5kaW5nLlxuICogQHByb3BlcnR5IHtCdWZmZXJFbmNvZGluZ30gW2RlZmF1bHRFbmNvZGluZz0ndXRmOCddIFRoZSBkZWZhdWx0IGVuY29kaW5nXG4gKiAgIHRoYXQgaXMgdXNlZCB3aGVuIG5vIGVuY29kaW5nIGlzIHNwZWNpZmllZCBhcyBhbiBhcmd1bWVudCB0b1xuICogICBzdHJlYW0ud3JpdGUoKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2VtaXRDbG9zZT10cnVlXSBXaGV0aGVyIG9yIG5vdCB0aGUgc3RyZWFtIHNob3VsZFxuICogICBlbWl0ICdjbG9zZScgYWZ0ZXIgaXQgaGFzIGJlZW4gZGVzdHJveWVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZWFkYWJsZUhpZ2hXYXRlck1hcmtdIFNldHMgaGlnaFdhdGVyTWFyayBmb3IgdGhlXG4gKiAgIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHN0cmVhbS4gSGFzIG5vIGVmZmVjdCBpZiBoaWdoV2F0ZXJNYXJrIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVhZGFibGVPYmplY3RNb2RlPWZhbHNlXSBTZXRzIG9iamVjdE1vZGUgZm9yXG4gKiAgIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHN0cmVhbS4gSGFzIG5vIGVmZmVjdCBpZiBvYmplY3RNb2RlIGlzIHRydWUuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dyaXRhYmxlSGlnaFdhdGVyTWFya10gU2V0cyBoaWdoV2F0ZXJNYXJrIGZvciB0aGVcbiAqICAgd3JpdGFibGUgc2lkZSBvZiB0aGUgc3RyZWFtLiBIYXMgbm8gZWZmZWN0IGlmIGhpZ2hXYXRlck1hcmsgaXMgcHJvdmlkZWQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt3cml0YWJsZU9iamVjdE1vZGU9ZmFsc2VdIFNldHMgb2JqZWN0TW9kZSBmb3JcbiAqICAgd3JpdGFibGUgc2lkZSBvZiB0aGUgc3RyZWFtLiBIYXMgbm8gZWZmZWN0IGlmIG9iamVjdE1vZGUgaXMgdHJ1ZS5cbiAqL1xuXG4vKipcbiAqIE5vRmlsdGVyIHN0cmVhbS4gIENhbiBiZSB1c2VkIHRvIHNpbmsgb3Igc291cmNlIGRhdGEgdG8gYW5kIGZyb21cbiAqIG90aGVyIG5vZGUgc3RyZWFtcy4gIEltcGxlbWVudGVkIGFzIHRoZSBcImlkZW50aXR5XCIgVHJhbnNmb3JtIHN0cmVhbVxuICogKGhlbmNlIHRoZSBuYW1lKSwgYnV0IGFsbG93cyBmb3IgaW5zcGVjdGluZyBkYXRhIHRoYXQgaXMgaW4tZmxpZ2h0LlxuICpcbiAqIEFsbG93cyBwYXNzaW5nIGluIHNvdXJjZSBkYXRhIChpbnB1dCwgaW5wdXRFbmNvZGluZykgYXQgY3JlYXRpb25cbiAqIHRpbWUuICBTb3VyY2UgZGF0YSBjYW4gYWxzbyBiZSBwYXNzZWQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnNvdXJjZSBhbmQgc2luazwvY2FwdGlvbj5cbiAqIGNvbnN0IHNvdXJjZSA9IG5ldyBOb0ZpbHRlcignWm05dicsICdiYXNlNjQnKVxuICogc291cmNlLnBpcGUocHJvY2Vzcy5zdGRvdXQpXG4gKiBjb25zdCBzaW5rID0gbmV3IE5vZmlsdGVyKClcbiAqIC8vIE5PVEU6ICdmaW5pc2gnIGZpcmVzIHdoZW4gdGhlIGlucHV0IGlzIGRvbmUgd3JpdGluZ1xuICogc2luay5vbignZmluaXNoJywgKCkgPT4gY29uc29sZS5sb2cobi50b1N0cmluZygnYmFzZTY0JykpKVxuICogcHJvY2Vzcy5zdGRpbi5waXBlKHNpbmspXG4gKi9cbmNsYXNzIE5vRmlsdGVyIGV4dGVuZHMgc3RyZWFtLlRyYW5zZm9ybSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgTm9GaWx0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxCdWZmZXJFbmNvZGluZ3xOb0ZpbHRlck9wdGlvbnN9IFtpbnB1dF0gU291cmNlIGRhdGEuXG4gICAqIEBwYXJhbSB7QnVmZmVyRW5jb2Rpbmd8Tm9GaWx0ZXJPcHRpb25zfSBbaW5wdXRFbmNvZGluZ10gRW5jb2RpbmdcbiAgICogICBuYW1lIGZvciBpbnB1dCwgaWdub3JlZCBpZiBpbnB1dCBpcyBub3QgYSBTdHJpbmcuXG4gICAqIEBwYXJhbSB7Tm9GaWx0ZXJPcHRpb25zfSBbb3B0aW9uc10gT3RoZXIgb3B0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlucHV0LCBpbnB1dEVuY29kaW5nLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgaW5wID0gbnVsbFxuICAgIGxldCBpbnBFID0gLyoqIEB0eXBlIHtCdWZmZXJFbmNvZGluZz99ICovIChudWxsKVxuICAgIHN3aXRjaCAodHlwZW9mIGlucHV0KSB7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICAgIGlucCA9IGlucHV0XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQpIHtcbiAgICAgICAgICBvcHRpb25zID0gaW5wdXRcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgaW5wID0gaW5wdXRcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGlucHV0JylcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgaW5wdXRFbmNvZGluZykge1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKGlucHV0RW5jb2RpbmcpIHtcbiAgICAgICAgICBvcHRpb25zID0gaW5wdXRFbmNvZGluZ1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpbnBFID0gLyoqIEB0eXBlIHtCdWZmZXJFbmNvZGluZ30gKi8gKGlucHV0RW5jb2RpbmcpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBpbnB1dEVuY29kaW5nJylcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvcHRpb25zJylcbiAgICB9XG4gICAgaWYgKGlucCA9PSBudWxsKSB7XG4gICAgICBpbnAgPSBvcHRpb25zLmlucHV0XG4gICAgfVxuICAgIGlmIChpbnBFID09IG51bGwpIHtcbiAgICAgIGlucEUgPSBvcHRpb25zLmlucHV0RW5jb2RpbmdcbiAgICB9XG4gICAgZGVsZXRlIG9wdGlvbnMuaW5wdXRcbiAgICBkZWxldGUgb3B0aW9ucy5pbnB1dEVuY29kaW5nXG4gICAgY29uc3Qgd2F0Y2hQaXBlID0gb3B0aW9ucy53YXRjaFBpcGUgPT0gbnVsbCA/IHRydWUgOiBvcHRpb25zLndhdGNoUGlwZVxuICAgIGRlbGV0ZSBvcHRpb25zLndhdGNoUGlwZVxuICAgIGNvbnN0IHJlYWRFcnJvciA9IEJvb2xlYW4ob3B0aW9ucy5yZWFkRXJyb3IpXG4gICAgZGVsZXRlIG9wdGlvbnMucmVhZEVycm9yXG4gICAgc3VwZXIob3B0aW9ucylcblxuICAgIHRoaXMucmVhZEVycm9yID0gcmVhZEVycm9yXG5cbiAgICBpZiAod2F0Y2hQaXBlKSB7XG4gICAgICB0aGlzLm9uKCdwaXBlJywgcmVhZGFibGUgPT4ge1xuICAgICAgICAvLyBAdHMtaWdub3JlOiBUUzIzMzkgKHVzaW5nIGludGVybmFsIGludGVyZmFjZSlcbiAgICAgICAgY29uc3Qgb20gPSByZWFkYWJsZS5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlXG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IFRTMjMzOSAodXNpbmcgaW50ZXJuYWwgaW50ZXJmYWNlKVxuICAgICAgICBpZiAoKHRoaXMubGVuZ3RoID4gMCkgJiYgKG9tICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0RvIG5vdCBzd2l0Y2ggb2JqZWN0TW9kZSBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzdHJlYW0nXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZTogVFMyMzM5ICh1c2luZyBpbnRlcm5hbCBpbnRlcmZhY2UpXG4gICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSA9IG9tXG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IFRTMjMzOSAodXNpbmcgaW50ZXJuYWwgaW50ZXJmYWNlKVxuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLm9iamVjdE1vZGUgPSBvbVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoaW5wICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZW5kKGlucCwgaW5wRSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIG9iamVjdCBhIHtOb0ZpbHRlcn0/XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBvYmogaXMgYSBOb0ZpbHRlci5cbiAgICovXG4gIHN0YXRpYyBpc05vRmlsdGVyKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogVGhlIHNhbWUgYXMgbmYxLmNvbXBhcmUobmYyKS4gVXNlZnVsIGZvciBzb3J0aW5nIGFuIEFycmF5IG9mIE5vRmlsdGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtOb0ZpbHRlcn0gbmYxIFRoZSBmaXJzdCBvYmplY3QgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHtOb0ZpbHRlcn0gbmYyIFRoZSBzZWNvbmQgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0xLCAwLCAxIGZvciBsZXNzLCBlcXVhbCwgZ3JlYXRlci5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBBcmd1bWVudHMgbm90IE5vRmlsdGVyIGluc3RhbmNlcy5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgYXJyID0gW25ldyBOb0ZpbHRlcignMTIzNCcpLCBuZXcgTm9GaWx0ZXIoJzAxMjMnKV1cbiAgICogYXJyLnNvcnQoTm9GaWx0ZXIuY29tcGFyZSlcbiAgICovXG4gIHN0YXRpYyBjb21wYXJlKG5mMSwgbmYyKSB7XG4gICAgaWYgKCEobmYxIGluc3RhbmNlb2YgdGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIE5vRmlsdGVycycpXG4gICAgfVxuICAgIGlmIChuZjEgPT09IG5mMikge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgcmV0dXJuIG5mMS5jb21wYXJlKG5mMilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYnVmZmVyIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgY29uY2F0ZW5hdGluZyBhbGwgdGhlXG4gICAqIE5vRmlsdGVycyBpbiB0aGUgbGlzdCB0b2dldGhlci4gSWYgdGhlIGxpc3QgaGFzIG5vIGl0ZW1zLCBvciBpZlxuICAgKiB0aGUgdG90YWxMZW5ndGggaXMgMCwgdGhlbiBpdCByZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyLlxuICAgKlxuICAgKiBJZiBsZW5ndGggaXMgbm90IHByb3ZpZGVkLCBpdCBpcyByZWFkIGZyb20gdGhlIGJ1ZmZlcnMgaW4gdGhlXG4gICAqIGxpc3QuIEhvd2V2ZXIsIHRoaXMgYWRkcyBhbiBhZGRpdGlvbmFsIGxvb3AgdG8gdGhlIGZ1bmN0aW9uLCBzb1xuICAgKiBpdCBpcyBmYXN0ZXIgdG8gcHJvdmlkZSB0aGUgbGVuZ3RoIGV4cGxpY2l0bHkgaWYgeW91IGFscmVhZHkga25vdyBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxOb0ZpbHRlcj59IGxpc3QgSW5wdXRzLiAgTXVzdCBub3QgYmUgYWxsIGVpdGhlciBpbiBvYmplY3RcbiAgICogICBtb2RlLCBvciBhbGwgbm90IGluIG9iamVjdCBtb2RlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1udWxsXSBOdW1iZXIgb2YgYnl0ZXMgb3Igb2JqZWN0cyB0byByZWFkLlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfEFycmF5fSBUaGUgY29uY2F0ZW5hdGVkIHZhbHVlcyBhcyBhbiBhcnJheSBpZiBpbiBvYmplY3RcbiAgICogICBtb2RlLCBvdGhlcndpc2UgYSBCdWZmZXIuXG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gTGlzdCBub3QgYXJyYXkgb2YgTm9GaWx0ZXJzLlxuICAgKi9cbiAgc3RhdGljIGNvbmNhdChsaXN0LCBsZW5ndGgpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBOb0ZpbHRlcnMnKVxuICAgIH1cbiAgICBpZiAoKGxpc3QubGVuZ3RoID09PSAwKSB8fCAobGVuZ3RoID09PSAwKSkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICAgIH1cbiAgICBpZiAoKGxlbmd0aCA9PSBudWxsKSkge1xuICAgICAgbGVuZ3RoID0gbGlzdC5yZWR1Y2UoKHRvdCwgbmYpID0+IHtcbiAgICAgICAgaWYgKCEobmYgaW5zdGFuY2VvZiBOb0ZpbHRlcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgTm9GaWx0ZXJzJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90ICsgbmYubGVuZ3RoXG4gICAgICB9LCAwKVxuICAgIH1cbiAgICBsZXQgYWxsQnVmcyA9IHRydWVcbiAgICBsZXQgYWxsT2JqcyA9IHRydWVcbiAgICBjb25zdCBidWZzID0gbGlzdC5tYXAobmYgPT4ge1xuICAgICAgaWYgKCEobmYgaW5zdGFuY2VvZiBOb0ZpbHRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIE5vRmlsdGVycycpXG4gICAgICB9XG4gICAgICBjb25zdCBidWYgPSBuZi5zbGljZSgpXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgICAgYWxsT2JqcyA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxCdWZzID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZcbiAgICB9KVxuICAgIGlmIChhbGxCdWZzKSB7XG4gICAgICAvLyBAdHMtaWdub3JlOiBUUzIzMjIsIHRzYyBjYW4ndCBzZWUgdGhlIHR5cGUgY2hlY2tpbmcgYWJvdmVcbiAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZnMsIGxlbmd0aClcbiAgICB9XG4gICAgaWYgKGFsbE9ianMpIHtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoLi4uYnVmcykuc2xpY2UoMCwgbGVuZ3RoKVxuICAgIH1cbiAgICAvLyBUT0RPOiBtYXliZSBjb2FsZXNjZSBidWZmZXJzLCBjb3VudGluZyBieXRlcywgYW5kIGZsYXR0ZW4gaW4gYXJyYXlzXG4gICAgLy8gY291bnRpbmcgb2JqZWN0cz8gIEkgY2FuJ3QgaW1hZ2luZSB3aHkgdGhhdCB3b3VsZCBiZSB1c2VmdWwuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25jYXRlbmF0aW5nIG1peGVkIG9iamVjdCBhbmQgYnl0ZSBzdHJlYW1zIG5vdCBzdXBwb3J0ZWQnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIC8vIEB0cy1pZ25vcmU6IFRTMjMzOSAodXNpbmcgaW50ZXJuYWwgaW50ZXJmYWNlKVxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZylcbiAgICB9XG4gICAgdGhpcy5wdXNoKGNodW5rKVxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyW119IFRoZSBjdXJyZW50IGludGVybmFsIGJ1ZmZlcnMuICBUaGV5IGFyZSBsYXllZCBvdXRcbiAgICogICBlbmQgdG8gZW5kLlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBfYnVmQXJyYXkoKSB7XG4gICAgLy8gQHRzLWlnbm9yZTogVFMyMzM5ICh1c2luZyBpbnRlcm5hbCBpbnRlcmZhY2UpXG4gICAgbGV0IGJ1ZnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlclxuICAgIC8vIEhBQ0s6IHJlcGxhY2Ugd2l0aCBzb21ldGhpbmcgZWxzZSBvbmUgZGF5LiAgVGhpcyBpcyB3aGF0IEkgZ2V0IGZvclxuICAgIC8vIHJlbHlpbmcgb24gaW50ZXJuYWxzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheShidWZzKSkge1xuICAgICAgbGV0IGIgPSBidWZzLmhlYWRcbiAgICAgIGJ1ZnMgPSBbXVxuICAgICAgd2hpbGUgKGIgIT0gbnVsbCkge1xuICAgICAgICBidWZzLnB1c2goYi5kYXRhKVxuICAgICAgICBiID0gYi5uZXh0XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZzXG4gIH1cblxuICAvKipcbiAgICogUHVsbHMgc29tZSBkYXRhIG91dCBvZiB0aGUgaW50ZXJuYWwgYnVmZmVyIGFuZCByZXR1cm5zIGl0LlxuICAgKiBJZiB0aGVyZSBpcyBubyBkYXRhIGF2YWlsYWJsZSwgdGhlbiBpdCB3aWxsIHJldHVybiBudWxsLlxuICAgKlxuICAgKiBJZiB5b3UgcGFzcyBpbiBhIHNpemUgYXJndW1lbnQsIHRoZW4gaXQgd2lsbCByZXR1cm4gdGhhdCBtYW55IGJ5dGVzLiBJZlxuICAgKiBzaXplIGJ5dGVzIGFyZSBub3QgYXZhaWxhYmxlLCB0aGVuIGl0IHdpbGwgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZVxuICAgKiBlbmRlZCwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIHJldHVybiB0aGUgZGF0YSByZW1haW5pbmcgaW4gdGhlIGJ1ZmZlci5cbiAgICpcbiAgICogSWYgeW91IGRvIG5vdCBzcGVjaWZ5IGEgc2l6ZSBhcmd1bWVudCwgdGhlbiBpdCB3aWxsIHJldHVybiBhbGwgdGhlIGRhdGEgaW5cbiAgICogdGhlIGludGVybmFsIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPW51bGxdIE51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfEJ1ZmZlcnxudWxsfSBJZiBubyBkYXRhIG9yIG5vdCBlbm91Z2ggZGF0YSwgbnVsbC4gIElmXG4gICAqICAgZGVjb2Rpbmcgb3V0cHV0IGEgc3RyaW5nLCBvdGhlcndpc2UgYSBCdWZmZXIuXG4gICAqIEB0aHJvd3MgRXJyb3IgSWYgcmVhZEVycm9yIGlzIHRydWUgYW5kIHRoZXJlIHdhcyB1bmRlcmZsb3cuXG4gICAqIEBmaXJlcyBOb0ZpbHRlciNyZWFkIFdoZW4gcmVhZCBmcm9tLlxuICAgKi9cbiAgcmVhZChzaXplKSB7XG4gICAgY29uc3QgYnVmID0gc3VwZXIucmVhZChzaXplKVxuICAgIGlmIChidWYgIT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBSZWFkIGV2ZW50LiBGaXJlZCB3aGVuZXZlciBhbnl0aGluZyBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgTm9GaWx0ZXIjcmVhZFxuICAgICAgICogQHBhcmFtIHtCdWZmZXJ8c3RyaW5nfG9iamVjdH0gYnVmIFdoYXQgd2FzIHJlYWQuXG4gICAgICAgKi9cbiAgICAgIHRoaXMuZW1pdCgncmVhZCcsIGJ1ZilcbiAgICAgIGlmICh0aGlzLnJlYWRFcnJvciAmJiAoYnVmLmxlbmd0aCA8IHNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVhZCAke2J1Zi5sZW5ndGh9LCB3YW50ZWQgJHtzaXplfWApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlYWRFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBkYXRhIGF2YWlsYWJsZSwgd2FudGVkICR7c2l6ZX1gKVxuICAgIH1cbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgZnVsbCBudW1iZXIgb2YgYnl0ZXMgYXNrZWQgZm9yLCBubyBtYXR0ZXIgaG93IGxvbmcgaXQgdGFrZXMuXG4gICAqIEZhaWwgaWYgYW4gZXJyb3Igb2NjdXJzIGluIHRoZSBtZWFudGltZSwgb3IgaWYgdGhlIHN0cmVhbSBmaW5pc2hlcyBiZWZvcmVcbiAgICogZW5vdWdoIGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIHdvbid0IHdvcmsgZnVsbHkgY29ycmVjdGx5IGlmIHlvdSBhcmUgdXNpbmdcbiAgICogc3RyZWFtLWJyb3dzZXJpZnkgKGZvciBleGFtcGxlLCBvbiB0aGUgV2ViKS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgVGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmd8QnVmZmVyPn0gQSBwcm9taXNlIGZvciB0aGUgZGF0YSByZWFkLlxuICAgKi9cbiAgcmVhZEZ1bGwoc2l6ZSkge1xuICAgIGxldCBvblJlYWRhYmxlID0gbnVsbFxuICAgIGxldCBvbkZpbmlzaCA9IG51bGxcbiAgICBsZXQgb25FcnJvciA9IG51bGxcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID49IHNpemUpIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzLnJlYWQoc2l6ZSkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBBZGRlZCBpbiBOb2RlIDEyLjE5LiAgVGhpcyB3b24ndCB3b3JrIHdpdGggc3RyZWFtLWJyb3dzZXJpZnkgeWV0LlxuICAgICAgLy8gSWYgaXQncyBuZWVkZWQsIGZpbGUgYSBidWcsIGFuZCBJJ2xsIGRvIGEgd29yay1hcm91bmQuXG4gICAgICBpZiAodGhpcy53cml0YWJsZUZpbmlzaGVkKSB7XG4gICAgICAgIC8vIEFscmVhZHkgZmluaXNoZWQgd3JpdGluZywgc28gbm8gbW9yZSBjb21pbmcuXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFN0cmVhbSBmaW5pc2hlZCBiZWZvcmUgJHtzaXplfSBieXRlcyB3ZXJlIGF2YWlsYWJsZWApKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgb25SZWFkYWJsZSA9IGNodW5rID0+IHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID49IHNpemUpIHtcbiAgICAgICAgICByZXNvbHZlKHRoaXMucmVhZChzaXplKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25GaW5pc2ggPSAoKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFN0cmVhbSBmaW5pc2hlZCBiZWZvcmUgJHtzaXplfSBieXRlcyB3ZXJlIGF2YWlsYWJsZWApKVxuICAgICAgfVxuICAgICAgb25FcnJvciA9IHJlamVjdFxuICAgICAgdGhpcy5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlKVxuICAgICAgdGhpcy5vbignZXJyb3InLCBvbkVycm9yKVxuICAgICAgdGhpcy5vbignZmluaXNoJywgb25GaW5pc2gpXG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBpZiAob25SZWFkYWJsZSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIG9uUmVhZGFibGUpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcilcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25GaW5pc2gpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHRoZSBmdWxsIGNvbnRlbnRzLCBhZnRlciB0aGUgJ2ZpbmlzaCdcbiAgICogZXZlbnQgZmlyZXMuICBFcnJvcnMgb24gdGhlIHN0cmVhbSBjYXVzZSB0aGUgcHJvbWlzZSB0byBiZSByZWplY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiPW51bGxdIEZpbmlzaGVkL2Vycm9yIGNhbGxiYWNrIHVzZWQgaW4gKmFkZGl0aW9uKlxuICAgKiAgIHRvIHRoZSBwcm9taXNlLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXJ8c3RyaW5nPn0gRnVsZmlsbGVkIHdoZW4gY29tcGxldGUuXG4gICAqL1xuICBwcm9taXNlKGNiKSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlYWQoKVxuICAgICAgICBpZiAoKGNiICE9IG51bGwpICYmICFkb25lKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWVcbiAgICAgICAgICBjYihudWxsLCBkYXRhKVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgICB0aGlzLm9uKCdlcnJvcicsIGVyID0+IHtcbiAgICAgICAgaWYgKChjYiAhPSBudWxsKSAmJiAhZG9uZSkge1xuICAgICAgICAgIGRvbmUgPSB0cnVlXG4gICAgICAgICAgY2IoZXIpXG4gICAgICAgIH1cbiAgICAgICAgcmVqZWN0KGVyKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBudW1iZXIgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgY29tZXMgYmVmb3JlIG9yIGFmdGVyIG9yIGlzIHRoZVxuICAgKiBzYW1lIGFzIHRoZSBvdGhlciBOb0ZpbHRlciBpbiBzb3J0IG9yZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge05vRmlsdGVyfSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0xLCAwLCAxIGZvciBsZXNzLCBlcXVhbCwgZ3JlYXRlci5cbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBBcmd1bWVudHMgbXVzdCBiZSBOb0ZpbHRlcnMuXG4gICAqL1xuICBjb21wYXJlKG90aGVyKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBOb0ZpbHRlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIE5vRmlsdGVycycpXG4gICAgfVxuICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICBjb25zdCBidWYxID0gdGhpcy5zbGljZSgpXG4gICAgY29uc3QgYnVmMiA9IG90aGVyLnNsaWNlKClcbiAgICAvLyBUaGVzZSB3aWxsIGJvdGggYmUgYnVmZmVycyBiZWNhdXNlIG9mIHRoZSBjaGVjayBhYm92ZS5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZjEpICYmIEJ1ZmZlci5pc0J1ZmZlcihidWYyKSkge1xuICAgICAgcmV0dXJuIGJ1ZjEuY29tcGFyZShidWYyKVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wYXJlIHN0cmVhbXMgaW4gb2JqZWN0IG1vZGUnKVxuICB9XG5cbiAgLyoqXG4gICAqIERvIHRoZXNlIE5vRmlsdGVyJ3MgY29udGFpbiB0aGUgc2FtZSBieXRlcz8gIERvZXNuJ3Qgd29yayBpZiBlaXRoZXIgaXNcbiAgICogaW4gb2JqZWN0IG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9GaWx0ZXJ9IG90aGVyIE90aGVyIE5vRmlsdGVyIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IEVxdWFsP1xuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlcikgPT09IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGJ5dGVzIG9yIG9iamVjdHMgd2l0aG91dCBjb25zdW1pbmcgdGhlbS4gIFVzZWZ1bCBmb3IgZGlhZ25vc3RpY3MuXG4gICAqIE5vdGU6IGFzIGEgc2lkZS1lZmZlY3QsIGNvbmNhdGVuYXRlcyBtdWx0aXBsZSB3cml0ZXMgdG9nZXRoZXIgaW50byB3aGF0XG4gICAqIGxvb2tzIGxpa2UgYSBzaW5nbGUgd3JpdGUsIHNvIHRoYXQgdGhpcyBjb25jYXQgZG9lc24ndCBoYXZlIHRvIGhhcHBlblxuICAgKiBtdWx0aXBsZSB0aW1lcyB3aGVuIHlvdSdyZSBmdXR6aW5nIHdpdGggdGhlIHNhbWUgTm9GaWx0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gQmVnaW5uaW5nIG9mZnNldC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9bGVuZ3RoXSBFbmRpbmcgb2Zmc2V0LlxuICAgKiBAcmV0dXJucyB7QnVmZmVyfEFycmF5fSBJZiBpbiBvYmplY3QgbW9kZSwgYW4gYXJyYXkgb2Ygb2JqZWN0cy4gIE90aGVyd2lzZSxcbiAgICogICBjb25jYXRlbmF0ZWQgYXJyYXkgb2YgY29udGVudHMuXG4gICAqL1xuICBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgLy8gQHRzLWlnbm9yZTogVFMyMzM5ICh1c2luZyBpbnRlcm5hbCBpbnRlcmZhY2UpXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2J1ZkFycmF5KCkuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICB9XG4gICAgY29uc3QgYnVmcyA9IHRoaXMuX2J1ZkFycmF5KClcbiAgICBzd2l0Y2ggKGJ1ZnMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgICAgIGNhc2UgMTogcmV0dXJuIGJ1ZnNbMF0uc2xpY2Uoc3RhcnQsIGVuZClcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgYiA9IEJ1ZmZlci5jb25jYXQoYnVmcylcbiAgICAgICAgLy8gVE9ETzogc3RvcmUgdGhlIGNvbmNhdGVudGVkIGJ1ZnMgYmFja1xuICAgICAgICAvLyBAX3JlYWRhYmxlU3RhdGUuYnVmZmVyID0gW2JdXG4gICAgICAgIHJldHVybiBiLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJ5dGUgYnkgb2Zmc2V0LiAgSSBkaWRuJ3Qgd2FudCB0byBnZXQgaW50byBtZXRhcHJvZ3JhbW1pbmdcbiAgICogdG8gZ2l2ZSB5b3UgdGhlIGBOb0ZpbHRlclswXWAgc3ludGF4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGJ5dGUgdG8gcmV0cmlldmUuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IDAtMjU1LlxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoKVtpbmRleF1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb2JqZWN0IGNvbXBhdGlibGUgd2l0aCBCdWZmZXIncyB0b0pTT04gaW1wbGVtZW50YXRpb24sIHNvIHRoYXRcbiAgICogcm91bmQtdHJpcHBpbmcgd2lsbCBwcm9kdWNlIGEgQnVmZmVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfEFycmF5fHt0eXBlOiAnQnVmZmVyJyxkYXRhOiBudW1iZXJbXX19IElmIGluIG9iamVjdCBtb2RlLFxuICAgKiAgIHRoZSBvYmplY3RzLiAgT3RoZXJ3aXNlLCBKU09OIHRleHQuXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPm91dHB1dCBmb3IgJ2ZvbycsIG5vdCBpbiBvYmplY3QgbW9kZTwvY2FwdGlvbj5cbiAgICogKHtcbiAgICogICB0eXBlOiAnQnVmZmVyJyxcbiAgICogICBkYXRhOiBbMTAyLCAxMTEsIDExMV0sXG4gICAqIH0pXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgY29uc3QgYiA9IHRoaXMuc2xpY2UoKVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBiLnRvSlNPTigpXG4gICAgfVxuICAgIHJldHVybiBiXG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyBhbmQgcmV0dXJucyBhIHN0cmluZyBmcm9tIGJ1ZmZlciBkYXRhIGVuY29kZWQgdXNpbmcgdGhlIHNwZWNpZmllZFxuICAgKiBjaGFyYWN0ZXIgc2V0IGVuY29kaW5nLiBJZiBlbmNvZGluZyBpcyB1bmRlZmluZWQgb3IgbnVsbCwgdGhlbiBlbmNvZGluZ1xuICAgKiBkZWZhdWx0cyB0byAndXRmOCcuIFRoZSBzdGFydCBhbmQgZW5kIHBhcmFtZXRlcnMgZGVmYXVsdCB0byAwIGFuZFxuICAgKiBOb0ZpbHRlci5sZW5ndGggd2hlbiB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyRW5jb2Rpbmd9IFtlbmNvZGluZz0ndXRmOCddIFdoaWNoIHRvIHVzZSBmb3IgZGVjb2Rpbmc/XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gU3RhcnQgb2Zmc2V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1sZW5ndGhdIEVuZCBvZmZzZXQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyB2ZXJzaW9uIG9mIHRoZSBjb250ZW50cy5cbiAgICovXG4gIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnVmID0gdGhpcy5zbGljZShzdGFydCwgZW5kKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShidWYpXG4gICAgfVxuICAgIGlmICghZW5jb2RpbmcgfHwgKGVuY29kaW5nID09PSAndXRmOCcpKSB7XG4gICAgICByZXR1cm4gdGQuZGVjb2RlKGJ1ZilcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi50b1N0cmluZyhlbmNvZGluZylcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBidWZzID0gdGhpcy5fYnVmQXJyYXkoKVxuICAgIGNvbnN0IGhleCA9IGJ1ZnMubWFwKGIgPT4ge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5zdHlsaXplKGIudG9TdHJpbmcoJ2hleCcpLCAnc3RyaW5nJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShiKVxuICAgIH0pLmpvaW4oJywgJylcbiAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBbJHtoZXh9XWBcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHJlYWRhYmxlIGxlbmd0aCwgaW4gYnl0ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IExlbmd0aCBvZiB0aGUgY29udGVudHMuXG4gICAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIC8vIEB0cy1pZ25vcmU6IFRTMjMzOSAodXNpbmcgaW50ZXJuYWwgaW50ZXJmYWNlKVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgSmF2YVNjcmlwdCBCaWdJbnQgdG8gdGhlIHN0cmVhbS4gIE5lZ2F0aXZlIG51bWJlcnMgd2lsbCBiZVxuICAgKiB3cml0dGVuIGFzIHRoZWlyIDIncyBjb21wbGVtZW50IHZlcnNpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7YmlnaW50fSB2YWwgVGhlIHZhbHVlIHRvIHdyaXRlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKi9cbiAgd3JpdGVCaWdJbnQodmFsKSB7XG4gICAgbGV0IHN0ciA9IHZhbC50b1N0cmluZygxNilcbiAgICBpZiAodmFsIDwgMCkge1xuICAgICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuICAgICAgLy8gTm90ZTogc3RyIGFsd2F5cyBzdGFydHMgd2l0aCAnLScgaGVyZS5cbiAgICAgIGNvbnN0IHN6ID0gQmlnSW50KE1hdGguZmxvb3Ioc3RyLmxlbmd0aCAvIDIpKVxuICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgxKSA8PCAoc3ogKiBCaWdJbnQoOCkpXG4gICAgICB2YWwgPSBtYXNrICsgdmFsXG4gICAgICBzdHIgPSB2YWwudG9TdHJpbmcoMTYpXG4gICAgfVxuICAgIGlmIChzdHIubGVuZ3RoICUgMikge1xuICAgICAgc3RyID0gYDAke3N0cn1gXG4gICAgfVxuICAgIHJldHVybiB0aGlzLnB1c2goQnVmZmVyLmZyb20oc3RyLCAnaGV4JykpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHZhcmlhYmxlLXNpemVkIEphdmFTY3JpcHQgdW5zaWduZWQgQmlnSW50IGZyb20gdGhlIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW49bnVsbF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQgb3IgYWxsIHJlbWFpbmluZ1xuICAgKiAgIGlmIG51bGwuXG4gICAqIEByZXR1cm5zIHtiaWdpbnR9IEEgQmlnSW50LlxuICAgKi9cbiAgcmVhZFVCaWdJbnQobGVuKSB7XG4gICAgY29uc3QgYiA9IHRoaXMucmVhZChsZW4pXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoYDB4JHtiLnRvU3RyaW5nKCdoZXgnKX1gKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSB2YXJpYWJsZS1zaXplZCBKYXZhU2NyaXB0IHNpZ25lZCBCaWdJbnQgZnJvbSB0aGUgc3RyZWFtIGluIDInc1xuICAgKiBjb21wbGVtZW50IGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW49bnVsbF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQgb3IgYWxsIHJlbWFpbmluZ1xuICAgKiAgIGlmIG51bGwuXG4gICAqIEByZXR1cm5zIHtiaWdpbnR9IEEgQmlnSW50LlxuICAgKi9cbiAgcmVhZEJpZ0ludChsZW4pIHtcbiAgICBjb25zdCBiID0gdGhpcy5yZWFkKGxlbilcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgbGV0IHJldCA9IEJpZ0ludChgMHgke2IudG9TdHJpbmcoJ2hleCcpfWApXG4gICAgLy8gTmVnYXRpdmU/XG4gICAgaWYgKGJbMF0gJiAweDgwKSB7XG4gICAgICAvLyBUd28ncyBjb21wbGVtZW50XG4gICAgICBjb25zdCBtYXNrID0gQmlnSW50KDEpIDw8IChCaWdJbnQoYi5sZW5ndGgpICogQmlnSW50KDgpKVxuICAgICAgcmV0IC09IG1hc2tcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGFuIDgtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHMgMSBieXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgMC4uMjU1LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKi9cbiAgd3JpdGVVSW50OCh2YWx1ZSkge1xuICAgIGNvbnN0IGIgPSBCdWZmZXIuZnJvbShbdmFsdWVdKVxuICAgIHJldHVybiB0aGlzLnB1c2goYilcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIGxpdHRsZS1lbmRpYW4gMTYtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHNcbiAgICogMiBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIDAuLjY1NTM1LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKi9cbiAgd3JpdGVVSW50MTZMRSh2YWx1ZSkge1xuICAgIGNvbnN0IGIgPSBCdWZmZXIuYWxsb2MoMilcbiAgICBiLndyaXRlVUludDE2TEUodmFsdWUpXG4gICAgcmV0dXJuIHRoaXMucHVzaChiKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgYmlnLWVuZGlhbiAxNi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byB0aGUgc3RyZWFtLiAgQWRkc1xuICAgKiAyIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgMC4uNjU1MzUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqL1xuICB3cml0ZVVJbnQxNkJFKHZhbHVlKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5hbGxvYygyKVxuICAgIGIud3JpdGVVSW50MTZCRSh2YWx1ZSlcbiAgICByZXR1cm4gdGhpcy5wdXNoKGIpXG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgYSBsaXR0bGUtZW5kaWFuIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzXG4gICAqIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAwLi4yKiozMi0xLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKi9cbiAgd3JpdGVVSW50MzJMRSh2YWx1ZSkge1xuICAgIGNvbnN0IGIgPSBCdWZmZXIuYWxsb2MoNClcbiAgICBiLndyaXRlVUludDMyTEUodmFsdWUpXG4gICAgcmV0dXJuIHRoaXMucHVzaChiKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgYmlnLWVuZGlhbiAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byB0aGUgc3RyZWFtLiAgQWRkc1xuICAgKiA0IGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgMC4uMioqMzItMS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICovXG4gIHdyaXRlVUludDMyQkUodmFsdWUpIHtcbiAgICBjb25zdCBiID0gQnVmZmVyLmFsbG9jKDQpXG4gICAgYi53cml0ZVVJbnQzMkJFKHZhbHVlKVxuICAgIHJldHVybiB0aGlzLnB1c2goYilcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHNpZ25lZCA4LWJpdCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzIDEgYnl0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlICgtMTI4KS4uMTI3LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKi9cbiAgd3JpdGVJbnQ4KHZhbHVlKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKFt2YWx1ZV0pXG4gICAgcmV0dXJuIHRoaXMucHVzaChiKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgc2lnbmVkIGxpdHRsZS1lbmRpYW4gMTYtYml0IGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHMgMiBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlICgtMzI3NjgpLi4zMjc2Ny5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICovXG4gIHdyaXRlSW50MTZMRSh2YWx1ZSkge1xuICAgIGNvbnN0IGIgPSBCdWZmZXIuYWxsb2MoMilcbiAgICBiLndyaXRlVUludDE2TEUodmFsdWUpXG4gICAgcmV0dXJuIHRoaXMucHVzaChiKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgc2lnbmVkIGJpZy1lbmRpYW4gMTYtYml0IGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHMgMiBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlICgtMzI3NjgpLi4zMjc2Ny5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICovXG4gIHdyaXRlSW50MTZCRSh2YWx1ZSkge1xuICAgIGNvbnN0IGIgPSBCdWZmZXIuYWxsb2MoMilcbiAgICBiLndyaXRlVUludDE2QkUodmFsdWUpXG4gICAgcmV0dXJuIHRoaXMucHVzaChiKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgc2lnbmVkIGxpdHRsZS1lbmRpYW4gMzItYml0IGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHMgNCBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlICgtMioqMzEpLi4oMioqMzEtMSkuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqL1xuICB3cml0ZUludDMyTEUodmFsdWUpIHtcbiAgICBjb25zdCBiID0gQnVmZmVyLmFsbG9jKDQpXG4gICAgYi53cml0ZVVJbnQzMkxFKHZhbHVlKVxuICAgIHJldHVybiB0aGlzLnB1c2goYilcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHNpZ25lZCBiaWctZW5kaWFuIDMyLWJpdCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAoLTIqKjMxKS4uKDIqKjMxLTEpLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKi9cbiAgd3JpdGVJbnQzMkJFKHZhbHVlKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5hbGxvYyg0KVxuICAgIGIud3JpdGVVSW50MzJCRSh2YWx1ZSlcbiAgICByZXR1cm4gdGhpcy5wdXNoKGIpXG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgYSBsaXR0bGUtZW5kaWFuIDMyLWJpdCBmbG9hdCB0byB0aGUgc3RyZWFtLiAgQWRkcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgMzItYml0IGZsb2F0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKi9cbiAgd3JpdGVGbG9hdExFKHZhbHVlKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5hbGxvYyg0KVxuICAgIGIud3JpdGVGbG9hdExFKHZhbHVlKVxuICAgIHJldHVybiB0aGlzLnB1c2goYilcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIGJpZy1lbmRpYW4gMzItYml0IGZsb2F0IHRvIHRoZSBzdHJlYW0uICBBZGRzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAzMi1iaXQgZmxvYXQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqL1xuICB3cml0ZUZsb2F0QkUodmFsdWUpIHtcbiAgICBjb25zdCBiID0gQnVmZmVyLmFsbG9jKDQpXG4gICAgYi53cml0ZUZsb2F0QkUodmFsdWUpXG4gICAgcmV0dXJuIHRoaXMucHVzaChiKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgbGl0dGxlLWVuZGlhbiA2NC1iaXQgZG91YmxlIHRvIHRoZSBzdHJlYW0uICBBZGRzIDggYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSA2NC1iaXQgZmxvYXQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIG9uIHN1Y2Nlc3MuXG4gICAqL1xuICB3cml0ZURvdWJsZUxFKHZhbHVlKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5hbGxvYyg4KVxuICAgIGIud3JpdGVEb3VibGVMRSh2YWx1ZSlcbiAgICByZXR1cm4gdGhpcy5wdXNoKGIpXG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgYSBiaWctZW5kaWFuIDY0LWJpdCBmbG9hdCB0byB0aGUgc3RyZWFtLiAgQWRkcyA4IGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgNjQtYml0IGZsb2F0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKi9cbiAgd3JpdGVEb3VibGVCRSh2YWx1ZSkge1xuICAgIGNvbnN0IGIgPSBCdWZmZXIuYWxsb2MoOClcbiAgICBiLndyaXRlRG91YmxlQkUodmFsdWUpXG4gICAgcmV0dXJuIHRoaXMucHVzaChiKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgc2lnbmVkIGxpdHRsZS1lbmRpYW4gNjQtYml0IEJpZ0ludCB0byB0aGUgc3RyZWFtLiAgQWRkcyA4IGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2JpZ2ludH0gdmFsdWUgQmlnSW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKi9cbiAgd3JpdGVCaWdJbnQ2NExFKHZhbHVlKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5hbGxvYyg4KVxuICAgIGIud3JpdGVCaWdJbnQ2NExFKHZhbHVlKVxuICAgIHJldHVybiB0aGlzLnB1c2goYilcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHNpZ25lZCBiaWctZW5kaWFuIDY0LWJpdCBCaWdJbnQgdG8gdGhlIHN0cmVhbS4gIEFkZHMgOCBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtiaWdpbnR9IHZhbHVlIEJpZ0ludC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICovXG4gIHdyaXRlQmlnSW50NjRCRSh2YWx1ZSkge1xuICAgIGNvbnN0IGIgPSBCdWZmZXIuYWxsb2MoOClcbiAgICBiLndyaXRlQmlnSW50NjRCRSh2YWx1ZSlcbiAgICByZXR1cm4gdGhpcy5wdXNoKGIpXG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgYW4gdW5zaWduZWQgbGl0dGxlLWVuZGlhbiA2NC1iaXQgQmlnSW50IHRvIHRoZSBzdHJlYW0uICBBZGRzIDggYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7YmlnaW50fSB2YWx1ZSBOb24tbmVnYXRpdmUgQmlnSW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBvbiBzdWNjZXNzLlxuICAgKi9cbiAgd3JpdGVCaWdVSW50NjRMRSh2YWx1ZSkge1xuICAgIGNvbnN0IGIgPSBCdWZmZXIuYWxsb2MoOClcbiAgICBiLndyaXRlQmlnVUludDY0TEUodmFsdWUpXG4gICAgcmV0dXJuIHRoaXMucHVzaChiKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGFuIHVuc2lnbmVkIGJpZy1lbmRpYW4gNjQtYml0IEJpZ0ludCB0byB0aGUgc3RyZWFtLiAgQWRkcyA4IGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2JpZ2ludH0gdmFsdWUgTm9uLW5lZ2F0aXZlIEJpZ0ludC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgb24gc3VjY2Vzcy5cbiAgICovXG4gIHdyaXRlQmlnVUludDY0QkUodmFsdWUpIHtcbiAgICBjb25zdCBiID0gQnVmZmVyLmFsbG9jKDgpXG4gICAgYi53cml0ZUJpZ1VJbnQ2NEJFKHZhbHVlKVxuICAgIHJldHVybiB0aGlzLnB1c2goYilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGFuIHVuc2lnbmVkIDgtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLiAgQ29uc3VtZXMgMSBieXRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkLlxuICAgKi9cbiAgcmVhZFVJbnQ4KCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLnJlYWQoMSlcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZFVJbnQ4KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgbGl0dGxlLWVuZGlhbiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDIgYnl0ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWQuXG4gICAqL1xuICByZWFkVUludDE2TEUoKSB7XG4gICAgY29uc3QgYiA9IHRoaXMucmVhZCgyKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkVUludDE2TEUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VyIGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgMiBieXRlcy5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZC5cbiAgICovXG4gIHJlYWRVSW50MTZCRSgpIHtcbiAgICBjb25zdCBiID0gdGhpcy5yZWFkKDIpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRVSW50MTZCRSgpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgMzItYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkLlxuICAgKi9cbiAgcmVhZFVJbnQzMkxFKCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLnJlYWQoNClcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZFVJbnQzMkxFKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgbGl0dGxlLWVuZGlhbiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWQuXG4gICAqL1xuICByZWFkVUludDMyQkUoKSB7XG4gICAgY29uc3QgYiA9IHRoaXMucmVhZCg0KVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkVUludDMyQkUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzaWduZWQgOC1iaXQgaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uICBDb25zdW1lcyAxIGJ5dGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWQuXG4gICAqL1xuICByZWFkSW50OCgpIHtcbiAgICBjb25zdCBiID0gdGhpcy5yZWFkKDEpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRJbnQ4KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgbGl0dGxlLWVuZGlhbiBzaWduZWQgMTYtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyAyIGJ5dGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkLlxuICAgKi9cbiAgcmVhZEludDE2TEUoKSB7XG4gICAgY29uc3QgYiA9IHRoaXMucmVhZCgyKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkSW50MTZMRSgpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIGxpdHRsZS1lbmRpYW4gc2lnbmVkIDE2LWJpdCBpbnRlZ2VyIGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgMiBieXRlcy5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZC5cbiAgICovXG4gIHJlYWRJbnQxNkJFKCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLnJlYWQoMilcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZEludDE2QkUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBsaXR0bGUtZW5kaWFuIHNpZ25lZCAzMi1iaXQgaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWQuXG4gICAqL1xuICByZWFkSW50MzJMRSgpIHtcbiAgICBjb25zdCBiID0gdGhpcy5yZWFkKDQpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRJbnQzMkxFKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgbGl0dGxlLWVuZGlhbiBzaWduZWQgMTYtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkLlxuICAgKi9cbiAgcmVhZEludDMyQkUoKSB7XG4gICAgY29uc3QgYiA9IHRoaXMucmVhZCg0KVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkSW50MzJCRSgpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIDMyLWJpdCBsaXR0bGUtZW5kaWFuIGZsb2F0IGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgNCBieXRlcy5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZC5cbiAgICovXG4gIHJlYWRGbG9hdExFKCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLnJlYWQoNClcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZEZsb2F0TEUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSAzMi1iaXQgYmlnLWVuZGlhbiBmbG9hdCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWQuXG4gICAqL1xuICByZWFkRmxvYXRCRSgpIHtcbiAgICBjb25zdCBiID0gdGhpcy5yZWFkKDQpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRGbG9hdEJFKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgNjQtYml0IGxpdHRsZS1lbmRpYW4gZmxvYXQgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA4IGJ5dGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkLlxuICAgKi9cbiAgcmVhZERvdWJsZUxFKCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLnJlYWQoOClcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZERvdWJsZUxFKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgNjQtYml0IGJpZy1lbmRpYW4gZmxvYXQgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA4IGJ5dGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkLlxuICAgKi9cbiAgcmVhZERvdWJsZUJFKCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLnJlYWQoOClcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIGIucmVhZERvdWJsZUJFKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2lnbmVkIDY0LWJpdCBsaXR0bGUtZW5kaWFuIEJpZ0ludCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDggYnl0ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtiaWdpbnR9IFZhbHVlIHJlYWQuXG4gICAqL1xuICByZWFkQmlnSW50NjRMRSgpIHtcbiAgICBjb25zdCBiID0gdGhpcy5yZWFkKDgpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRCaWdJbnQ2NExFKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2lnbmVkIDY0LWJpdCBiaWctZW5kaWFuIEJpZ0ludCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDggYnl0ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtiaWdpbnR9IFZhbHVlIHJlYWQuXG4gICAqL1xuICByZWFkQmlnSW50NjRCRSgpIHtcbiAgICBjb25zdCBiID0gdGhpcy5yZWFkKDgpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRCaWdJbnQ2NEJFKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIGFuIHVuc2lnbmVkIDY0LWJpdCBsaXR0bGUtZW5kaWFuIEJpZ0ludCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDggYnl0ZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtiaWdpbnR9IFZhbHVlIHJlYWQuXG4gICAqL1xuICByZWFkQmlnVUludDY0TEUoKSB7XG4gICAgY29uc3QgYiA9IHRoaXMucmVhZCg4KVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gYi5yZWFkQmlnVUludDY0TEUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYW4gdW5zaWduZWQgNjQtYml0IGJpZy1lbmRpYW4gQmlnSW50IGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgOCBieXRlcy5cbiAgICpcbiAgICogQHJldHVybnMge2JpZ2ludH0gVmFsdWUgcmVhZC5cbiAgICovXG4gIHJlYWRCaWdVSW50NjRCRSgpIHtcbiAgICBjb25zdCBiID0gdGhpcy5yZWFkKDgpXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiBiLnJlYWRCaWdVSW50NjRCRSgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOb0ZpbHRlclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nofilter/lib/index.js\n");

/***/ })

};
;