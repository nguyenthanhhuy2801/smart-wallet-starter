"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-qrcode-logo";
exports.ids = ["vendor-chunks/react-qrcode-logo"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-qrcode-logo/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/react-qrcode-logo/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QRCode = void 0;\nvar isEqual = __webpack_require__(/*! lodash.isequal */ \"(ssr)/./node_modules/lodash.isequal/index.js\");\nvar qrGenerator = __webpack_require__(/*! qrcode-generator */ \"(ssr)/./node_modules/qrcode-generator/qrcode.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar QRCode = /** @class */ (function (_super) {\n    __extends(QRCode, _super);\n    function QRCode(props) {\n        var _this = _super.call(this, props) || this;\n        _this.canvasRef = React.createRef();\n        return _this;\n    }\n    QRCode.prototype.download = function (fileType, fileName) {\n        if (this.canvasRef.current) {\n            var mimeType = void 0;\n            switch (fileType) {\n                case 'jpg':\n                    mimeType = 'image/jpeg';\n                    break;\n                case 'webp':\n                    mimeType = 'image/webp';\n                    break;\n                case 'png':\n                default:\n                    mimeType = 'image/png';\n                    break;\n            }\n            var url = this.canvasRef.current.toDataURL(mimeType, 1.0);\n            var link = document.createElement('a');\n            link.download = fileName !== null && fileName !== void 0 ? fileName : 'react-qrcode-logo';\n            link.href = url;\n            link.click();\n        }\n    };\n    QRCode.prototype.utf16to8 = function (str) {\n        var out = '', i, c;\n        var len = str.length;\n        for (i = 0; i < len; i++) {\n            c = str.charCodeAt(i);\n            if ((c >= 0x0001) && (c <= 0x007F)) {\n                out += str.charAt(i);\n            }\n            else if (c > 0x07FF) {\n                out += String.fromCharCode(0xE0 | ((c >> 12) & 0x0F));\n                out += String.fromCharCode(0x80 | ((c >> 6) & 0x3F));\n                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));\n            }\n            else {\n                out += String.fromCharCode(0xC0 | ((c >> 6) & 0x1F));\n                out += String.fromCharCode(0x80 | ((c >> 0) & 0x3F));\n            }\n        }\n        return out;\n    };\n    /**\n     * Draw a rounded square in the canvas\n     */\n    QRCode.prototype.drawRoundedSquare = function (lineWidth, x, y, size, color, radii, fill, ctx) {\n        ctx.lineWidth = lineWidth;\n        ctx.fillStyle = color;\n        ctx.strokeStyle = color;\n        // Adjust coordinates so that the outside of the stroke is aligned to the edges\n        y += lineWidth / 2;\n        x += lineWidth / 2;\n        size -= lineWidth;\n        if (!Array.isArray(radii)) {\n            radii = [radii, radii, radii, radii];\n        }\n        // Radius should not be greater than half the size or less than zero\n        radii = radii.map(function (r) {\n            r = Math.min(r, size / 2);\n            return (r < 0) ? 0 : r;\n        });\n        var rTopLeft = radii[0] || 0;\n        var rTopRight = radii[1] || 0;\n        var rBottomRight = radii[2] || 0;\n        var rBottomLeft = radii[3] || 0;\n        ctx.beginPath();\n        ctx.moveTo(x + rTopLeft, y);\n        ctx.lineTo(x + size - rTopRight, y);\n        if (rTopRight)\n            ctx.quadraticCurveTo(x + size, y, x + size, y + rTopRight);\n        ctx.lineTo(x + size, y + size - rBottomRight);\n        if (rBottomRight)\n            ctx.quadraticCurveTo(x + size, y + size, x + size - rBottomRight, y + size);\n        ctx.lineTo(x + rBottomLeft, y + size);\n        if (rBottomLeft)\n            ctx.quadraticCurveTo(x, y + size, x, y + size - rBottomLeft);\n        ctx.lineTo(x, y + rTopLeft);\n        if (rTopLeft)\n            ctx.quadraticCurveTo(x, y, x + rTopLeft, y);\n        ctx.closePath();\n        ctx.stroke();\n        if (fill) {\n            ctx.fill();\n        }\n    };\n    /**\n     * Draw a single positional pattern eye.\n     */\n    QRCode.prototype.drawPositioningPattern = function (ctx, cellSize, offset, row, col, color, radii) {\n        if (radii === void 0) { radii = [0, 0, 0, 0]; }\n        var lineWidth = Math.ceil(cellSize);\n        var radiiOuter;\n        var radiiInner;\n        if (typeof radii !== 'number' && !Array.isArray(radii)) {\n            radiiOuter = radii.outer || 0;\n            radiiInner = radii.inner || 0;\n        }\n        else {\n            radiiOuter = radii;\n            radiiInner = radiiOuter;\n        }\n        var colorOuter;\n        var colorInner;\n        if (typeof color !== 'string') {\n            colorOuter = color.outer;\n            colorInner = color.inner;\n        }\n        else {\n            colorOuter = color;\n            colorInner = color;\n        }\n        var y = (row * cellSize) + offset;\n        var x = (col * cellSize) + offset;\n        var size = cellSize * 7;\n        // Outer box\n        this.drawRoundedSquare(lineWidth, x, y, size, colorOuter, radiiOuter, false, ctx);\n        // Inner box\n        size = cellSize * 3;\n        y += cellSize * 2;\n        x += cellSize * 2;\n        this.drawRoundedSquare(lineWidth, x, y, size, colorInner, radiiInner, true, ctx);\n    };\n    ;\n    /**\n     * Is this dot inside a positional pattern zone.\n     */\n    QRCode.prototype.isInPositioninZone = function (col, row, zones) {\n        return zones.some(function (zone) { return (row >= zone.row && row <= zone.row + 7 &&\n            col >= zone.col && col <= zone.col + 7); });\n    };\n    QRCode.prototype.transformPixelLengthIntoNumberOfCells = function (pixelLength, cellSize) {\n        return pixelLength / cellSize;\n    };\n    QRCode.prototype.isCoordinateInImage = function (col, row, dWidthLogo, dHeightLogo, dxLogo, dyLogo, cellSize, logoImage) {\n        if (logoImage) {\n            var numberOfCellsMargin = 2;\n            var firstRowOfLogo = this.transformPixelLengthIntoNumberOfCells(dxLogo, cellSize);\n            var firstColumnOfLogo = this.transformPixelLengthIntoNumberOfCells(dyLogo, cellSize);\n            var logoWidthInCells = this.transformPixelLengthIntoNumberOfCells(dWidthLogo, cellSize) - 1;\n            var logoHeightInCells = this.transformPixelLengthIntoNumberOfCells(dHeightLogo, cellSize) - 1;\n            return row >= firstRowOfLogo - numberOfCellsMargin && row <= firstRowOfLogo + logoWidthInCells + numberOfCellsMargin // check rows\n                && col >= firstColumnOfLogo - numberOfCellsMargin && col <= firstColumnOfLogo + logoHeightInCells + numberOfCellsMargin; // check cols\n        }\n        else {\n            return false;\n        }\n    };\n    QRCode.prototype.shouldComponentUpdate = function (nextProps) {\n        return !isEqual(this.props, nextProps);\n    };\n    QRCode.prototype.componentDidMount = function () {\n        this.update();\n    };\n    QRCode.prototype.componentDidUpdate = function () {\n        this.update();\n    };\n    QRCode.prototype.update = function () {\n        var _a;\n        var _b = this.props, value = _b.value, ecLevel = _b.ecLevel, enableCORS = _b.enableCORS, bgColor = _b.bgColor, fgColor = _b.fgColor, logoImage = _b.logoImage, logoOpacity = _b.logoOpacity, logoOnLoad = _b.logoOnLoad, removeQrCodeBehindLogo = _b.removeQrCodeBehindLogo, qrStyle = _b.qrStyle, eyeRadius = _b.eyeRadius, eyeColor = _b.eyeColor, logoPaddingStyle = _b.logoPaddingStyle;\n        // just make sure that these params are passed as numbers\n        var size = +this.props.size;\n        var quietZone = +this.props.quietZone;\n        var logoWidth = this.props.logoWidth ? +this.props.logoWidth : 0;\n        var logoHeight = this.props.logoHeight ? +this.props.logoHeight : 0;\n        var logoPadding = this.props.logoPadding ? +this.props.logoPadding : 0;\n        var qrCode = qrGenerator(0, ecLevel);\n        qrCode.addData(this.utf16to8(value));\n        qrCode.make();\n        var canvas = (_a = this.canvasRef) === null || _a === void 0 ? void 0 : _a.current;\n        var ctx = canvas.getContext('2d');\n        var canvasSize = size + (2 * quietZone);\n        var length = qrCode.getModuleCount();\n        var cellSize = size / length;\n        var scale = (window.devicePixelRatio || 1);\n        canvas.height = canvas.width = canvasSize * scale;\n        ctx.scale(scale, scale);\n        ctx.fillStyle = bgColor;\n        ctx.fillRect(0, 0, canvasSize, canvasSize);\n        var offset = quietZone;\n        var positioningZones = [\n            { row: 0, col: 0 },\n            { row: 0, col: length - 7 },\n            { row: length - 7, col: 0 },\n        ];\n        ctx.strokeStyle = fgColor;\n        if (qrStyle === 'dots') {\n            ctx.fillStyle = fgColor;\n            var radius = cellSize / 2;\n            for (var row = 0; row < length; row++) {\n                for (var col = 0; col < length; col++) {\n                    if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {\n                        ctx.beginPath();\n                        ctx.arc(Math.round(col * cellSize) + radius + offset, Math.round(row * cellSize) + radius + offset, (radius / 100) * 75, 0, 2 * Math.PI, false);\n                        ctx.closePath();\n                        ctx.fill();\n                    }\n                }\n            }\n        }\n        else if (qrStyle === 'fluid') {\n            var radius = Math.ceil(cellSize / 2);\n            for (var row = 0; row < length; row++) {\n                for (var col = 0; col < length; col++) {\n                    if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {\n                        var roundedCorners = [false, false, false, false]; // top-left, top-right, bottom-right, bottom-left\n                        if ((row > 0 && !qrCode.isDark(row - 1, col)) && (col > 0 && !qrCode.isDark(row, col - 1)))\n                            roundedCorners[0] = true;\n                        if ((row > 0 && !qrCode.isDark(row - 1, col)) && (col < length - 1 && !qrCode.isDark(row, col + 1)))\n                            roundedCorners[1] = true;\n                        if ((row < length - 1 && !qrCode.isDark(row + 1, col)) && (col < length - 1 && !qrCode.isDark(row, col + 1)))\n                            roundedCorners[2] = true;\n                        if ((row < length - 1 && !qrCode.isDark(row + 1, col)) && (col > 0 && !qrCode.isDark(row, col - 1)))\n                            roundedCorners[3] = true;\n                        var w = (Math.ceil((col + 1) * cellSize) - Math.floor(col * cellSize));\n                        var h = (Math.ceil((row + 1) * cellSize) - Math.floor(row * cellSize));\n                        ctx.fillStyle = fgColor;\n                        ctx.beginPath();\n                        ctx.arc(Math.round(col * cellSize) + radius + offset, Math.round(row * cellSize) + radius + offset, radius, 0, 2 * Math.PI, false);\n                        ctx.closePath();\n                        ctx.fill();\n                        if (!roundedCorners[0])\n                            ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset, w / 2, h / 2);\n                        if (!roundedCorners[1])\n                            ctx.fillRect(Math.round(col * cellSize) + offset + Math.floor(w / 2), Math.round(row * cellSize) + offset, w / 2, h / 2);\n                        if (!roundedCorners[2])\n                            ctx.fillRect(Math.round(col * cellSize) + offset + Math.floor(w / 2), Math.round(row * cellSize) + offset + Math.floor(h / 2), w / 2, h / 2);\n                        if (!roundedCorners[3])\n                            ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset + Math.floor(h / 2), w / 2, h / 2);\n                    }\n                }\n            }\n        }\n        else {\n            for (var row = 0; row < length; row++) {\n                for (var col = 0; col < length; col++) {\n                    if (qrCode.isDark(row, col) && !this.isInPositioninZone(row, col, positioningZones)) {\n                        ctx.fillStyle = fgColor;\n                        var w = (Math.ceil((col + 1) * cellSize) - Math.floor(col * cellSize));\n                        var h = (Math.ceil((row + 1) * cellSize) - Math.floor(row * cellSize));\n                        ctx.fillRect(Math.round(col * cellSize) + offset, Math.round(row * cellSize) + offset, w, h);\n                    }\n                }\n            }\n        }\n        // Draw positioning patterns\n        for (var i = 0; i < 3; i++) {\n            var _c = positioningZones[i], row = _c.row, col = _c.col;\n            var radii = eyeRadius;\n            var color = void 0;\n            if (Array.isArray(radii)) {\n                radii = radii[i];\n            }\n            if (typeof radii == 'number') {\n                radii = [radii, radii, radii, radii];\n            }\n            if (!eyeColor) { // if not specified, eye color is the same as foreground, \n                color = fgColor;\n            }\n            else {\n                if (Array.isArray(eyeColor)) { // if array, we pass the single color\n                    color = eyeColor[i];\n                }\n                else {\n                    color = eyeColor;\n                }\n            }\n            this.drawPositioningPattern(ctx, cellSize, offset, row, col, color, radii);\n        }\n        if (logoImage) {\n            var image_1 = new Image();\n            if (enableCORS) {\n                image_1.crossOrigin = 'Anonymous';\n            }\n            image_1.onload = function (e) {\n                ctx.save();\n                var dWidthLogo = logoWidth || size * 0.2;\n                var dHeightLogo = logoHeight || dWidthLogo;\n                var dxLogo = ((size - dWidthLogo) / 2);\n                var dyLogo = ((size - dHeightLogo) / 2);\n                if (removeQrCodeBehindLogo || logoPadding) {\n                    ctx.beginPath();\n                    ctx.strokeStyle = bgColor;\n                    ctx.fillStyle = bgColor;\n                    var dWidthLogoPadding = dWidthLogo + (2 * logoPadding);\n                    var dHeightLogoPadding = dHeightLogo + (2 * logoPadding);\n                    var dxLogoPadding = dxLogo + offset - logoPadding;\n                    var dyLogoPadding = dyLogo + offset - logoPadding;\n                    if (logoPaddingStyle === 'circle') {\n                        var dxCenterLogoPadding = dxLogoPadding + (dWidthLogoPadding / 2);\n                        var dyCenterLogoPadding = dyLogoPadding + (dHeightLogoPadding / 2);\n                        ctx.ellipse(dxCenterLogoPadding, dyCenterLogoPadding, dWidthLogoPadding / 2, dHeightLogoPadding / 2, 0, 0, 2 * Math.PI);\n                        ctx.stroke();\n                        ctx.fill();\n                    }\n                    else {\n                        ctx.fillRect(dxLogoPadding, dyLogoPadding, dWidthLogoPadding, dHeightLogoPadding);\n                    }\n                }\n                ctx.globalAlpha = logoOpacity;\n                ctx.drawImage(image_1, dxLogo + offset, dyLogo + offset, dWidthLogo, dHeightLogo);\n                ctx.restore();\n                if (logoOnLoad) {\n                    logoOnLoad(e);\n                }\n            };\n            image_1.src = logoImage;\n        }\n    };\n    QRCode.prototype.render = function () {\n        var _a;\n        var qrSize = +this.props.size + (2 * +this.props.quietZone);\n        return React.createElement(\"canvas\", { id: (_a = this.props.id) !== null && _a !== void 0 ? _a : 'react-qrcode-logo', height: qrSize, width: qrSize, style: __assign({ height: qrSize + 'px', width: qrSize + 'px' }, this.props.style), ref: this.canvasRef });\n    };\n    QRCode.defaultProps = {\n        value: 'https://reactjs.org/',\n        ecLevel: 'M',\n        enableCORS: false,\n        size: 150,\n        quietZone: 10,\n        bgColor: '#FFFFFF',\n        fgColor: '#000000',\n        logoOpacity: 1,\n        qrStyle: 'squares',\n        eyeRadius: [0, 0, 0],\n        logoPaddingStyle: 'square'\n    };\n    return QRCode;\n}(React.Component));\nexports.QRCode = QRCode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcXJjb2RlLWxvZ28vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxjQUFjLG1CQUFPLENBQUMsb0VBQWdCO0FBQ3RDLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFrQjtBQUM1QyxZQUFZLG1CQUFPLENBQUMsd0dBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SUFBeUk7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCLGNBQWMseUJBQXlCO0FBQ3ZDLGNBQWMseUJBQXlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QyxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUMsa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QyxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdJQUFnSSw2Q0FBNkMsMENBQTBDO0FBQ3RRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc21hcnQtd2FsbGV0LWNsaWVudC8uL25vZGVfbW9kdWxlcy9yZWFjdC1xcmNvZGUtbG9nby9kaXN0L2luZGV4LmpzPzAxMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUVJDb2RlID0gdm9pZCAwO1xudmFyIGlzRXF1YWwgPSByZXF1aXJlKFwibG9kYXNoLmlzZXF1YWxcIik7XG52YXIgcXJHZW5lcmF0b3IgPSByZXF1aXJlKFwicXJjb2RlLWdlbmVyYXRvclwiKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBRUkNvZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFFSQ29kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBRUkNvZGUocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNhbnZhc1JlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFFSQ29kZS5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbiAoZmlsZVR5cGUsIGZpbGVOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbnZhc1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWltZVR5cGUgPSB2b2lkIDA7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpbGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnanBnJzpcbiAgICAgICAgICAgICAgICAgICAgbWltZVR5cGUgPSAnaW1hZ2UvanBlZyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlYnAnOlxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSA9ICdpbWFnZS93ZWJwJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncG5nJzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSA9ICdpbWFnZS9wbmcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLmNhbnZhc1JlZi5jdXJyZW50LnRvRGF0YVVSTChtaW1lVHlwZSwgMS4wKTtcbiAgICAgICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgbGluay5kb3dubG9hZCA9IGZpbGVOYW1lICE9PSBudWxsICYmIGZpbGVOYW1lICE9PSB2b2lkIDAgPyBmaWxlTmFtZSA6ICdyZWFjdC1xcmNvZGUtbG9nbyc7XG4gICAgICAgICAgICBsaW5rLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICBsaW5rLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFFSQ29kZS5wcm90b3R5cGUudXRmMTZ0bzggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHZhciBvdXQgPSAnJywgaSwgYztcbiAgICAgICAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKChjID49IDB4MDAwMSkgJiYgKGMgPD0gMHgwMDdGKSkge1xuICAgICAgICAgICAgICAgIG91dCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA+IDB4MDdGRikge1xuICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RTAgfCAoKGMgPj4gMTIpICYgMHgwRikpO1xuICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGMgPj4gNikgJiAweDNGKSk7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8ICgoYyA+PiAwKSAmIDB4M0YpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4QzAgfCAoKGMgPj4gNikgJiAweDFGKSk7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8ICgoYyA+PiAwKSAmIDB4M0YpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHJvdW5kZWQgc3F1YXJlIGluIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBRUkNvZGUucHJvdG90eXBlLmRyYXdSb3VuZGVkU3F1YXJlID0gZnVuY3Rpb24gKGxpbmVXaWR0aCwgeCwgeSwgc2l6ZSwgY29sb3IsIHJhZGlpLCBmaWxsLCBjdHgpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgLy8gQWRqdXN0IGNvb3JkaW5hdGVzIHNvIHRoYXQgdGhlIG91dHNpZGUgb2YgdGhlIHN0cm9rZSBpcyBhbGlnbmVkIHRvIHRoZSBlZGdlc1xuICAgICAgICB5ICs9IGxpbmVXaWR0aCAvIDI7XG4gICAgICAgIHggKz0gbGluZVdpZHRoIC8gMjtcbiAgICAgICAgc2l6ZSAtPSBsaW5lV2lkdGg7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyYWRpaSkpIHtcbiAgICAgICAgICAgIHJhZGlpID0gW3JhZGlpLCByYWRpaSwgcmFkaWksIHJhZGlpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSYWRpdXMgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gaGFsZiB0aGUgc2l6ZSBvciBsZXNzIHRoYW4gemVyb1xuICAgICAgICByYWRpaSA9IHJhZGlpLm1hcChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgciA9IE1hdGgubWluKHIsIHNpemUgLyAyKTtcbiAgICAgICAgICAgIHJldHVybiAociA8IDApID8gMCA6IHI7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgclRvcExlZnQgPSByYWRpaVswXSB8fCAwO1xuICAgICAgICB2YXIgclRvcFJpZ2h0ID0gcmFkaWlbMV0gfHwgMDtcbiAgICAgICAgdmFyIHJCb3R0b21SaWdodCA9IHJhZGlpWzJdIHx8IDA7XG4gICAgICAgIHZhciByQm90dG9tTGVmdCA9IHJhZGlpWzNdIHx8IDA7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4ICsgclRvcExlZnQsIHkpO1xuICAgICAgICBjdHgubGluZVRvKHggKyBzaXplIC0gclRvcFJpZ2h0LCB5KTtcbiAgICAgICAgaWYgKHJUb3BSaWdodClcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyBzaXplLCB5LCB4ICsgc2l6ZSwgeSArIHJUb3BSaWdodCk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHNpemUsIHkgKyBzaXplIC0gckJvdHRvbVJpZ2h0KTtcbiAgICAgICAgaWYgKHJCb3R0b21SaWdodClcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyBzaXplLCB5ICsgc2l6ZSwgeCArIHNpemUgLSByQm90dG9tUmlnaHQsIHkgKyBzaXplKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgckJvdHRvbUxlZnQsIHkgKyBzaXplKTtcbiAgICAgICAgaWYgKHJCb3R0b21MZWZ0KVxuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIHNpemUsIHgsIHkgKyBzaXplIC0gckJvdHRvbUxlZnQpO1xuICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByVG9wTGVmdCk7XG4gICAgICAgIGlmIChyVG9wTGVmdClcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByVG9wTGVmdCwgeSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHNpbmdsZSBwb3NpdGlvbmFsIHBhdHRlcm4gZXllLlxuICAgICAqL1xuICAgIFFSQ29kZS5wcm90b3R5cGUuZHJhd1Bvc2l0aW9uaW5nUGF0dGVybiA9IGZ1bmN0aW9uIChjdHgsIGNlbGxTaXplLCBvZmZzZXQsIHJvdywgY29sLCBjb2xvciwgcmFkaWkpIHtcbiAgICAgICAgaWYgKHJhZGlpID09PSB2b2lkIDApIHsgcmFkaWkgPSBbMCwgMCwgMCwgMF07IH1cbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IE1hdGguY2VpbChjZWxsU2l6ZSk7XG4gICAgICAgIHZhciByYWRpaU91dGVyO1xuICAgICAgICB2YXIgcmFkaWlJbm5lcjtcbiAgICAgICAgaWYgKHR5cGVvZiByYWRpaSAhPT0gJ251bWJlcicgJiYgIUFycmF5LmlzQXJyYXkocmFkaWkpKSB7XG4gICAgICAgICAgICByYWRpaU91dGVyID0gcmFkaWkub3V0ZXIgfHwgMDtcbiAgICAgICAgICAgIHJhZGlpSW5uZXIgPSByYWRpaS5pbm5lciB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmFkaWlPdXRlciA9IHJhZGlpO1xuICAgICAgICAgICAgcmFkaWlJbm5lciA9IHJhZGlpT3V0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbG9yT3V0ZXI7XG4gICAgICAgIHZhciBjb2xvcklubmVyO1xuICAgICAgICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29sb3JPdXRlciA9IGNvbG9yLm91dGVyO1xuICAgICAgICAgICAgY29sb3JJbm5lciA9IGNvbG9yLmlubmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29sb3JPdXRlciA9IGNvbG9yO1xuICAgICAgICAgICAgY29sb3JJbm5lciA9IGNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIHZhciB5ID0gKHJvdyAqIGNlbGxTaXplKSArIG9mZnNldDtcbiAgICAgICAgdmFyIHggPSAoY29sICogY2VsbFNpemUpICsgb2Zmc2V0O1xuICAgICAgICB2YXIgc2l6ZSA9IGNlbGxTaXplICogNztcbiAgICAgICAgLy8gT3V0ZXIgYm94XG4gICAgICAgIHRoaXMuZHJhd1JvdW5kZWRTcXVhcmUobGluZVdpZHRoLCB4LCB5LCBzaXplLCBjb2xvck91dGVyLCByYWRpaU91dGVyLCBmYWxzZSwgY3R4KTtcbiAgICAgICAgLy8gSW5uZXIgYm94XG4gICAgICAgIHNpemUgPSBjZWxsU2l6ZSAqIDM7XG4gICAgICAgIHkgKz0gY2VsbFNpemUgKiAyO1xuICAgICAgICB4ICs9IGNlbGxTaXplICogMjtcbiAgICAgICAgdGhpcy5kcmF3Um91bmRlZFNxdWFyZShsaW5lV2lkdGgsIHgsIHksIHNpemUsIGNvbG9ySW5uZXIsIHJhZGlpSW5uZXIsIHRydWUsIGN0eCk7XG4gICAgfTtcbiAgICA7XG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBkb3QgaW5zaWRlIGEgcG9zaXRpb25hbCBwYXR0ZXJuIHpvbmUuXG4gICAgICovXG4gICAgUVJDb2RlLnByb3RvdHlwZS5pc0luUG9zaXRpb25pblpvbmUgPSBmdW5jdGlvbiAoY29sLCByb3csIHpvbmVzKSB7XG4gICAgICAgIHJldHVybiB6b25lcy5zb21lKGZ1bmN0aW9uICh6b25lKSB7IHJldHVybiAocm93ID49IHpvbmUucm93ICYmIHJvdyA8PSB6b25lLnJvdyArIDcgJiZcbiAgICAgICAgICAgIGNvbCA+PSB6b25lLmNvbCAmJiBjb2wgPD0gem9uZS5jb2wgKyA3KTsgfSk7XG4gICAgfTtcbiAgICBRUkNvZGUucHJvdG90eXBlLnRyYW5zZm9ybVBpeGVsTGVuZ3RoSW50b051bWJlck9mQ2VsbHMgPSBmdW5jdGlvbiAocGl4ZWxMZW5ndGgsIGNlbGxTaXplKSB7XG4gICAgICAgIHJldHVybiBwaXhlbExlbmd0aCAvIGNlbGxTaXplO1xuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS5pc0Nvb3JkaW5hdGVJbkltYWdlID0gZnVuY3Rpb24gKGNvbCwgcm93LCBkV2lkdGhMb2dvLCBkSGVpZ2h0TG9nbywgZHhMb2dvLCBkeUxvZ28sIGNlbGxTaXplLCBsb2dvSW1hZ2UpIHtcbiAgICAgICAgaWYgKGxvZ29JbWFnZSkge1xuICAgICAgICAgICAgdmFyIG51bWJlck9mQ2VsbHNNYXJnaW4gPSAyO1xuICAgICAgICAgICAgdmFyIGZpcnN0Um93T2ZMb2dvID0gdGhpcy50cmFuc2Zvcm1QaXhlbExlbmd0aEludG9OdW1iZXJPZkNlbGxzKGR4TG9nbywgY2VsbFNpemUpO1xuICAgICAgICAgICAgdmFyIGZpcnN0Q29sdW1uT2ZMb2dvID0gdGhpcy50cmFuc2Zvcm1QaXhlbExlbmd0aEludG9OdW1iZXJPZkNlbGxzKGR5TG9nbywgY2VsbFNpemUpO1xuICAgICAgICAgICAgdmFyIGxvZ29XaWR0aEluQ2VsbHMgPSB0aGlzLnRyYW5zZm9ybVBpeGVsTGVuZ3RoSW50b051bWJlck9mQ2VsbHMoZFdpZHRoTG9nbywgY2VsbFNpemUpIC0gMTtcbiAgICAgICAgICAgIHZhciBsb2dvSGVpZ2h0SW5DZWxscyA9IHRoaXMudHJhbnNmb3JtUGl4ZWxMZW5ndGhJbnRvTnVtYmVyT2ZDZWxscyhkSGVpZ2h0TG9nbywgY2VsbFNpemUpIC0gMTtcbiAgICAgICAgICAgIHJldHVybiByb3cgPj0gZmlyc3RSb3dPZkxvZ28gLSBudW1iZXJPZkNlbGxzTWFyZ2luICYmIHJvdyA8PSBmaXJzdFJvd09mTG9nbyArIGxvZ29XaWR0aEluQ2VsbHMgKyBudW1iZXJPZkNlbGxzTWFyZ2luIC8vIGNoZWNrIHJvd3NcbiAgICAgICAgICAgICAgICAmJiBjb2wgPj0gZmlyc3RDb2x1bW5PZkxvZ28gLSBudW1iZXJPZkNlbGxzTWFyZ2luICYmIGNvbCA8PSBmaXJzdENvbHVtbk9mTG9nbyArIGxvZ29IZWlnaHRJbkNlbGxzICsgbnVtYmVyT2ZDZWxsc01hcmdpbjsgLy8gY2hlY2sgY29sc1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRUkNvZGUucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuICFpc0VxdWFsKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG4gICAgfTtcbiAgICBRUkNvZGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgUVJDb2RlLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfTtcbiAgICBRUkNvZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLnByb3BzLCB2YWx1ZSA9IF9iLnZhbHVlLCBlY0xldmVsID0gX2IuZWNMZXZlbCwgZW5hYmxlQ09SUyA9IF9iLmVuYWJsZUNPUlMsIGJnQ29sb3IgPSBfYi5iZ0NvbG9yLCBmZ0NvbG9yID0gX2IuZmdDb2xvciwgbG9nb0ltYWdlID0gX2IubG9nb0ltYWdlLCBsb2dvT3BhY2l0eSA9IF9iLmxvZ29PcGFjaXR5LCBsb2dvT25Mb2FkID0gX2IubG9nb09uTG9hZCwgcmVtb3ZlUXJDb2RlQmVoaW5kTG9nbyA9IF9iLnJlbW92ZVFyQ29kZUJlaGluZExvZ28sIHFyU3R5bGUgPSBfYi5xclN0eWxlLCBleWVSYWRpdXMgPSBfYi5leWVSYWRpdXMsIGV5ZUNvbG9yID0gX2IuZXllQ29sb3IsIGxvZ29QYWRkaW5nU3R5bGUgPSBfYi5sb2dvUGFkZGluZ1N0eWxlO1xuICAgICAgICAvLyBqdXN0IG1ha2Ugc3VyZSB0aGF0IHRoZXNlIHBhcmFtcyBhcmUgcGFzc2VkIGFzIG51bWJlcnNcbiAgICAgICAgdmFyIHNpemUgPSArdGhpcy5wcm9wcy5zaXplO1xuICAgICAgICB2YXIgcXVpZXRab25lID0gK3RoaXMucHJvcHMucXVpZXRab25lO1xuICAgICAgICB2YXIgbG9nb1dpZHRoID0gdGhpcy5wcm9wcy5sb2dvV2lkdGggPyArdGhpcy5wcm9wcy5sb2dvV2lkdGggOiAwO1xuICAgICAgICB2YXIgbG9nb0hlaWdodCA9IHRoaXMucHJvcHMubG9nb0hlaWdodCA/ICt0aGlzLnByb3BzLmxvZ29IZWlnaHQgOiAwO1xuICAgICAgICB2YXIgbG9nb1BhZGRpbmcgPSB0aGlzLnByb3BzLmxvZ29QYWRkaW5nID8gK3RoaXMucHJvcHMubG9nb1BhZGRpbmcgOiAwO1xuICAgICAgICB2YXIgcXJDb2RlID0gcXJHZW5lcmF0b3IoMCwgZWNMZXZlbCk7XG4gICAgICAgIHFyQ29kZS5hZGREYXRhKHRoaXMudXRmMTZ0bzgodmFsdWUpKTtcbiAgICAgICAgcXJDb2RlLm1ha2UoKTtcbiAgICAgICAgdmFyIGNhbnZhcyA9IChfYSA9IHRoaXMuY2FudmFzUmVmKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudDtcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB2YXIgY2FudmFzU2l6ZSA9IHNpemUgKyAoMiAqIHF1aWV0Wm9uZSk7XG4gICAgICAgIHZhciBsZW5ndGggPSBxckNvZGUuZ2V0TW9kdWxlQ291bnQoKTtcbiAgICAgICAgdmFyIGNlbGxTaXplID0gc2l6ZSAvIGxlbmd0aDtcbiAgICAgICAgdmFyIHNjYWxlID0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoID0gY2FudmFzU2l6ZSAqIHNjYWxlO1xuICAgICAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNTaXplLCBjYW52YXNTaXplKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHF1aWV0Wm9uZTtcbiAgICAgICAgdmFyIHBvc2l0aW9uaW5nWm9uZXMgPSBbXG4gICAgICAgICAgICB7IHJvdzogMCwgY29sOiAwIH0sXG4gICAgICAgICAgICB7IHJvdzogMCwgY29sOiBsZW5ndGggLSA3IH0sXG4gICAgICAgICAgICB7IHJvdzogbGVuZ3RoIC0gNywgY29sOiAwIH0sXG4gICAgICAgIF07XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGZnQ29sb3I7XG4gICAgICAgIGlmIChxclN0eWxlID09PSAnZG90cycpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IGNlbGxTaXplIC8gMjtcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBsZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdywgY29sKSAmJiAhdGhpcy5pc0luUG9zaXRpb25pblpvbmUocm93LCBjb2wsIHBvc2l0aW9uaW5nWm9uZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYXJjKE1hdGgucm91bmQoY29sICogY2VsbFNpemUpICsgcmFkaXVzICsgb2Zmc2V0LCBNYXRoLnJvdW5kKHJvdyAqIGNlbGxTaXplKSArIHJhZGl1cyArIG9mZnNldCwgKHJhZGl1cyAvIDEwMCkgKiA3NSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocXJTdHlsZSA9PT0gJ2ZsdWlkJykge1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGguY2VpbChjZWxsU2l6ZSAvIDIpO1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbGVuZ3RoOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFyQ29kZS5pc0Rhcmsocm93LCBjb2wpICYmICF0aGlzLmlzSW5Qb3NpdGlvbmluWm9uZShyb3csIGNvbCwgcG9zaXRpb25pbmdab25lcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3VuZGVkQ29ybmVycyA9IFtmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07IC8vIHRvcC1sZWZ0LCB0b3AtcmlnaHQsIGJvdHRvbS1yaWdodCwgYm90dG9tLWxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocm93ID4gMCAmJiAhcXJDb2RlLmlzRGFyayhyb3cgLSAxLCBjb2wpKSAmJiAoY29sID4gMCAmJiAhcXJDb2RlLmlzRGFyayhyb3csIGNvbCAtIDEpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZGVkQ29ybmVyc1swXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdyA+IDAgJiYgIXFyQ29kZS5pc0Rhcmsocm93IC0gMSwgY29sKSkgJiYgKGNvbCA8IGxlbmd0aCAtIDEgJiYgIXFyQ29kZS5pc0Rhcmsocm93LCBjb2wgKyAxKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRlZENvcm5lcnNbMV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyb3cgPCBsZW5ndGggLSAxICYmICFxckNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbCkpICYmIChjb2wgPCBsZW5ndGggLSAxICYmICFxckNvZGUuaXNEYXJrKHJvdywgY29sICsgMSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kZWRDb3JuZXJzWzJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocm93IDwgbGVuZ3RoIC0gMSAmJiAhcXJDb2RlLmlzRGFyayhyb3cgKyAxLCBjb2wpKSAmJiAoY29sID4gMCAmJiAhcXJDb2RlLmlzRGFyayhyb3csIGNvbCAtIDEpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3VuZGVkQ29ybmVyc1szXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IChNYXRoLmNlaWwoKGNvbCArIDEpICogY2VsbFNpemUpIC0gTWF0aC5mbG9vcihjb2wgKiBjZWxsU2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSAoTWF0aC5jZWlsKChyb3cgKyAxKSAqIGNlbGxTaXplKSAtIE1hdGguZmxvb3Iocm93ICogY2VsbFNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmZ0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFyYyhNYXRoLnJvdW5kKGNvbCAqIGNlbGxTaXplKSArIHJhZGl1cyArIG9mZnNldCwgTWF0aC5yb3VuZChyb3cgKiBjZWxsU2l6ZSkgKyByYWRpdXMgKyBvZmZzZXQsIHJhZGl1cywgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJvdW5kZWRDb3JuZXJzWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChNYXRoLnJvdW5kKGNvbCAqIGNlbGxTaXplKSArIG9mZnNldCwgTWF0aC5yb3VuZChyb3cgKiBjZWxsU2l6ZSkgKyBvZmZzZXQsIHcgLyAyLCBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJvdW5kZWRDb3JuZXJzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChNYXRoLnJvdW5kKGNvbCAqIGNlbGxTaXplKSArIG9mZnNldCArIE1hdGguZmxvb3IodyAvIDIpLCBNYXRoLnJvdW5kKHJvdyAqIGNlbGxTaXplKSArIG9mZnNldCwgdyAvIDIsIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcm91bmRlZENvcm5lcnNbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KE1hdGgucm91bmQoY29sICogY2VsbFNpemUpICsgb2Zmc2V0ICsgTWF0aC5mbG9vcih3IC8gMiksIE1hdGgucm91bmQocm93ICogY2VsbFNpemUpICsgb2Zmc2V0ICsgTWF0aC5mbG9vcihoIC8gMiksIHcgLyAyLCBoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJvdW5kZWRDb3JuZXJzWzNdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChNYXRoLnJvdW5kKGNvbCAqIGNlbGxTaXplKSArIG9mZnNldCwgTWF0aC5yb3VuZChyb3cgKiBjZWxsU2l6ZSkgKyBvZmZzZXQgKyBNYXRoLmZsb29yKGggLyAyKSwgdyAvIDIsIGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IGxlbmd0aDsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBsZW5ndGg7IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdywgY29sKSAmJiAhdGhpcy5pc0luUG9zaXRpb25pblpvbmUocm93LCBjb2wsIHBvc2l0aW9uaW5nWm9uZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ID0gKE1hdGguY2VpbCgoY29sICsgMSkgKiBjZWxsU2l6ZSkgLSBNYXRoLmZsb29yKGNvbCAqIGNlbGxTaXplKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IChNYXRoLmNlaWwoKHJvdyArIDEpICogY2VsbFNpemUpIC0gTWF0aC5mbG9vcihyb3cgKiBjZWxsU2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KE1hdGgucm91bmQoY29sICogY2VsbFNpemUpICsgb2Zmc2V0LCBNYXRoLnJvdW5kKHJvdyAqIGNlbGxTaXplKSArIG9mZnNldCwgdywgaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHJhdyBwb3NpdGlvbmluZyBwYXR0ZXJuc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9jID0gcG9zaXRpb25pbmdab25lc1tpXSwgcm93ID0gX2Mucm93LCBjb2wgPSBfYy5jb2w7XG4gICAgICAgICAgICB2YXIgcmFkaWkgPSBleWVSYWRpdXM7XG4gICAgICAgICAgICB2YXIgY29sb3IgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyYWRpaSkpIHtcbiAgICAgICAgICAgICAgICByYWRpaSA9IHJhZGlpW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByYWRpaSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJhZGlpID0gW3JhZGlpLCByYWRpaSwgcmFkaWksIHJhZGlpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZXllQ29sb3IpIHsgLy8gaWYgbm90IHNwZWNpZmllZCwgZXllIGNvbG9yIGlzIHRoZSBzYW1lIGFzIGZvcmVncm91bmQsIFxuICAgICAgICAgICAgICAgIGNvbG9yID0gZmdDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV5ZUNvbG9yKSkgeyAvLyBpZiBhcnJheSwgd2UgcGFzcyB0aGUgc2luZ2xlIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gZXllQ29sb3JbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGV5ZUNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhd1Bvc2l0aW9uaW5nUGF0dGVybihjdHgsIGNlbGxTaXplLCBvZmZzZXQsIHJvdywgY29sLCBjb2xvciwgcmFkaWkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2dvSW1hZ2UpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZV8xID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICBpZiAoZW5hYmxlQ09SUykge1xuICAgICAgICAgICAgICAgIGltYWdlXzEuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltYWdlXzEub25sb2FkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgIHZhciBkV2lkdGhMb2dvID0gbG9nb1dpZHRoIHx8IHNpemUgKiAwLjI7XG4gICAgICAgICAgICAgICAgdmFyIGRIZWlnaHRMb2dvID0gbG9nb0hlaWdodCB8fCBkV2lkdGhMb2dvO1xuICAgICAgICAgICAgICAgIHZhciBkeExvZ28gPSAoKHNpemUgLSBkV2lkdGhMb2dvKSAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciBkeUxvZ28gPSAoKHNpemUgLSBkSGVpZ2h0TG9nbykgLyAyKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlUXJDb2RlQmVoaW5kTG9nbyB8fCBsb2dvUGFkZGluZykge1xuICAgICAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGJnQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiZ0NvbG9yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZFdpZHRoTG9nb1BhZGRpbmcgPSBkV2lkdGhMb2dvICsgKDIgKiBsb2dvUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkSGVpZ2h0TG9nb1BhZGRpbmcgPSBkSGVpZ2h0TG9nbyArICgyICogbG9nb1BhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHhMb2dvUGFkZGluZyA9IGR4TG9nbyArIG9mZnNldCAtIGxvZ29QYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHlMb2dvUGFkZGluZyA9IGR5TG9nbyArIG9mZnNldCAtIGxvZ29QYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9nb1BhZGRpbmdTdHlsZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeENlbnRlckxvZ29QYWRkaW5nID0gZHhMb2dvUGFkZGluZyArIChkV2lkdGhMb2dvUGFkZGluZyAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5Q2VudGVyTG9nb1BhZGRpbmcgPSBkeUxvZ29QYWRkaW5nICsgKGRIZWlnaHRMb2dvUGFkZGluZyAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmVsbGlwc2UoZHhDZW50ZXJMb2dvUGFkZGluZywgZHlDZW50ZXJMb2dvUGFkZGluZywgZFdpZHRoTG9nb1BhZGRpbmcgLyAyLCBkSGVpZ2h0TG9nb1BhZGRpbmcgLyAyLCAwLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KGR4TG9nb1BhZGRpbmcsIGR5TG9nb1BhZGRpbmcsIGRXaWR0aExvZ29QYWRkaW5nLCBkSGVpZ2h0TG9nb1BhZGRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxvZ29PcGFjaXR5O1xuICAgICAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2VfMSwgZHhMb2dvICsgb2Zmc2V0LCBkeUxvZ28gKyBvZmZzZXQsIGRXaWR0aExvZ28sIGRIZWlnaHRMb2dvKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIGlmIChsb2dvT25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ29PbkxvYWQoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGltYWdlXzEuc3JjID0gbG9nb0ltYWdlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRUkNvZGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcXJTaXplID0gK3RoaXMucHJvcHMuc2l6ZSArICgyICogK3RoaXMucHJvcHMucXVpZXRab25lKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwgeyBpZDogKF9hID0gdGhpcy5wcm9wcy5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3JlYWN0LXFyY29kZS1sb2dvJywgaGVpZ2h0OiBxclNpemUsIHdpZHRoOiBxclNpemUsIHN0eWxlOiBfX2Fzc2lnbih7IGhlaWdodDogcXJTaXplICsgJ3B4Jywgd2lkdGg6IHFyU2l6ZSArICdweCcgfSwgdGhpcy5wcm9wcy5zdHlsZSksIHJlZjogdGhpcy5jYW52YXNSZWYgfSk7XG4gICAgfTtcbiAgICBRUkNvZGUuZGVmYXVsdFByb3BzID0ge1xuICAgICAgICB2YWx1ZTogJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvJyxcbiAgICAgICAgZWNMZXZlbDogJ00nLFxuICAgICAgICBlbmFibGVDT1JTOiBmYWxzZSxcbiAgICAgICAgc2l6ZTogMTUwLFxuICAgICAgICBxdWlldFpvbmU6IDEwLFxuICAgICAgICBiZ0NvbG9yOiAnI0ZGRkZGRicsXG4gICAgICAgIGZnQ29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgbG9nb09wYWNpdHk6IDEsXG4gICAgICAgIHFyU3R5bGU6ICdzcXVhcmVzJyxcbiAgICAgICAgZXllUmFkaXVzOiBbMCwgMCwgMF0sXG4gICAgICAgIGxvZ29QYWRkaW5nU3R5bGU6ICdzcXVhcmUnXG4gICAgfTtcbiAgICByZXR1cm4gUVJDb2RlO1xufShSZWFjdC5Db21wb25lbnQpKTtcbmV4cG9ydHMuUVJDb2RlID0gUVJDb2RlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-qrcode-logo/dist/index.js\n");

/***/ })

};
;